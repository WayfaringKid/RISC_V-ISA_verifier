{
  "instructions": [
{
  "mnemonic": "add",
  "name": "add",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ADD  => rs1_val + rs2_val,\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\n    RISCV_AND  => rs1_val & rs2_val,\n    RISCV_OR   => rs1_val | rs2_val,\n    RISCV_XOR  => rs1_val ^ rs2_val,\n    RISCV_SLL  => if   sizeof(xlen) == 32\n                  then rs1_val << (rs2_val[4..0])\n                  else rs1_val << (rs2_val[5..0]),\n    RISCV_SRL  => if   sizeof(xlen) == 32\n                  then rs1_val >> (rs2_val[4..0])\n                  else rs1_val >> (rs2_val[5..0]),\n    RISCV_SUB  => rs1_val - rs2_val,\n    RISCV_SRA  => if   sizeof(xlen) == 32\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe R-type (Register-type) instruction format is used for operations\nthat involve three registers. The specific operation is determined\nby the opcode and funct7 fields. The result is written to the\ndestination register (rd), and the source operands are specified\nby the source registers (rs1 and rs2). The format is common for\narithmetic, logical, and shift operations.\n "
},
{
  "mnemonic": "add.uw",
  "name": "add unsigned word",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [ "Zba" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let shamt : bits(2) = match op {\n    RISCV_ADDUW    => 0b00,\n    RISCV_SH1ADDUW => 0b01,\n    RISCV_SH2ADDUW => 0b10,\n    RISCV_SH3ADDUW => 0b11\n  };\n  let result : xlenbits = (zero_extend(rs1_val[31..0]) << shamt) + rs2_val;\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "addi",
  "name": "add immediate",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false } ],
  "syntax": "rd,rs1,imm",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "encdec_iop(op)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let immext : xlenbits = sign_extend(imm);\n  let result : xlenbits = match op {\n    RISCV_ADDI  => rs1_val + immext,\n    RISCV_SLTI  => zero_extend(bool_to_bits(rs1_val <_s immext)),\n    RISCV_SLTIU => zero_extend(bool_to_bits(rs1_val <_u immext)),\n    RISCV_ANDI  => rs1_val & immext,\n    RISCV_ORI   => rs1_val | immext,\n    RISCV_XORI  => rs1_val ^ immext\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe ITYPE instruction operates on an immediate value, adding, comparing, or\nperforming bitwise operations with the contents of register rs1.\nThe immediate value, rs1, and the operation code (iop) determine the operation.\nThe result is stored in register rd.\nThe supported immediate operations (iop) include:\n  - \"addi\"  : Add immediate\n  - \"slti\"  : Set less than immediate (signed)\n  - \"sltiu\" : Set less than immediate (unsigned)\n  - \"andi\"  : AND immediate\n  - \"ori\"   : OR immediate\n  - \"xori\"  : XOR immediate\n\nNote: The immediate value is sign-extended before performing the operation.\n "
},
{
  "mnemonic": "addiw",
  "name": "add immediate word",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false } ],
  "syntax": "rd,rs1,imm",
  "format": "I",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0011011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let result : xlenbits = sign_extend(imm) + X(rs1);\n  X(rd) = sign_extend(result[31..0]);\n  RETIRE_SUCCESS\n}",
  "description": "\nThe ADDIW instruction involves adding a sign-extended\n12-bit immediate value to the content of register rs1. The result is a 32-bit\nvalue, and overflow is disregarded. The final outcome is the lower 32 bits of\nthe result, sign-extended to 64 bits. If the immediate value is set to zero\nin the ADDIW rd, rs1, 0 operation, the sign-extension of the lower 32 bits\nof register rs1 is written to register rd.\n "
},
{
  "mnemonic": "addw",
  "name": "add word (RV64)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = (X(rs1))[31..0];\n  let rs2_val = (X(rs2))[31..0];\n  let result : bits(32) = match op {\n    RISCV_ADDW => rs1_val + rs2_val,\n    RISCV_SUBW => rs1_val - rs2_val,\n    RISCV_SLLW => rs1_val << (rs2_val[4..0]),\n    RISCV_SRLW => rs1_val >> (rs2_val[4..0]),\n    RISCV_SRAW => shift_right_arith32(rs1_val, rs2_val[4..0])\n  };\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "\nThe RTYPEW instruction set operates on 32-bit values,\nand the result is sign-extended to 64 bits. The available operations are\nADDW (addition), SUBW (subtraction), SLLW (logical left shift),\nSRLW (logical right shift), and SRAW (arithmetic right shift).\nThese operations are only applicable when the width of the target\narchitecture is 64 bits.\n "
},
{
  "mnemonic": "aes32dsi",
  "name": "AES final round decrypt (RV32)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "bs", "type": "bits(2)", "optional": false } ],
  "syntax": "rd,rs1,rs2,bs",
  "format": "TBD",
  "fields": [ { "field": "bs", "size": 2 }, { "field": "0b10101", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zknd" ],
  "function": "{\n  let shamt   : bits( 5) = bs @ 0b000; /* shamt = bs*8 */\n  let si      : bits( 8) = (X(rs2) >> shamt)[7..0]; /* SBox Input */\n  let so      : bits(32) = 0x000000 @ aes_sbox_inv(si);\n  let result  : bits(32) = X(rs1)[31..0] ^ (so <<< shamt);\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "aes32dsmi",
  "name": "AES middle round decrypt (RV32)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "bs", "type": "bits(2)", "optional": false } ],
  "syntax": "rd,rs1,rs2,bs",
  "format": "TBD",
  "fields": [ { "field": "bs", "size": 2 }, { "field": "0b10111", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zknd" ],
  "function": "{\n  let shamt   : bits( 5) = bs @ 0b000; /* shamt = bs*8 */\n  let si      : bits( 8) = (X(rs2) >> shamt)[7..0]; /* SBox Input */\n  let so      : bits( 8) = aes_sbox_inv(si);\n  let mixed   : bits(32) = aes_mixcolumn_byte_inv(so);\n  let result  : bits(32) = X(rs1)[31..0] ^ (mixed <<< shamt);\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "aes32esi",
  "name": "AES final round encrypt (RV32)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "bs", "type": "bits(2)", "optional": false } ],
  "syntax": "rd,rs1,rs2,bs",
  "format": "TBD",
  "fields": [ { "field": "bs", "size": 2 }, { "field": "0b10001", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zkne" ],
  "function": "{\n  let shamt   : bits( 5) = bs @ 0b000; /* shamt = bs*8 */\n  let si      : bits( 8) = (X(rs2) >> shamt)[7..0]; /* SBox Input */\n  let so      : bits(32) = 0x000000 @ aes_sbox_fwd(si);\n  let result  : bits(32) = X(rs1)[31..0] ^ (so <<< shamt);\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "aes32esmi",
  "name": "AES middle round encrypt (RV32)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "bs", "type": "bits(2)", "optional": false } ],
  "syntax": "rd,rs1,rs2,bs",
  "format": "TBD",
  "fields": [ { "field": "bs", "size": 2 }, { "field": "0b10011", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zkne" ],
  "function": "{\n  let shamt   : bits( 5) = bs @ 0b000; /* shamt = bs*8 */\n  let si      : bits( 8) = (X(rs2) >> shamt)[7..0]; /* SBox Input */\n  let so      : bits( 8) = aes_sbox_fwd(si);\n  let mixed   : bits(32) = aes_mixcolumn_byte_fwd(so);\n  let result  : bits(32) = X(rs1)[31..0] ^ (mixed <<< shamt);\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "aes64ds",
  "name": "AES decrypt final round (RV64)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b00", "size": 2 }, { "field": "0b11101", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zknd" ],
  "function": "{\n  assert(sizeof(xlen) == 64);\n  let sr : bits(64) = aes_rv64_shiftrows_inv(X(rs2), X(rs1));\n  let wd : bits(64) = sr[63..0];\n  X(rd) = aes_apply_inv_sbox_to_each_byte(wd);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "aes64dsm",
  "name": "AES decrypt middle round (RV64)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b00", "size": 2 }, { "field": "0b11111", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zknd" ],
  "function": "{\n  assert(sizeof(xlen) == 64);\n  let sr : bits(64) = aes_rv64_shiftrows_inv(X(rs2), X(rs1));\n  let wd : bits(64) = sr[63..0];\n  let sb : bits(64) = aes_apply_inv_sbox_to_each_byte(wd);\n  X(rd) = aes_mixcolumn_inv(sb[63..32]) @ aes_mixcolumn_inv(sb[31..0]);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "aes64es",
  "name": "AES encrypt final round instruction (RV64)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b00", "size": 2 }, { "field": "0b11001", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zkne" ],
  "function": "{\n  assert(sizeof(xlen) == 64);\n  let sr : bits(64) = aes_rv64_shiftrows_fwd(X(rs2), X(rs1));\n  let wd : bits(64) = sr[63..0];\n  X(rd) = aes_apply_fwd_sbox_to_each_byte(wd);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "aes64esm",
  "name": "AES encrypt middle round instruction (RV64)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b00", "size": 2 }, { "field": "0b11011", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zkne" ],
  "function": "{\n  assert(sizeof(xlen) == 64);\n  let sr : bits(64) = aes_rv64_shiftrows_fwd(X(rs2), X(rs1));\n  let wd : bits(64) = sr[63..0];\n  let sb : bits(64) = aes_apply_fwd_sbox_to_each_byte(wd);\n  X(rd)  = aes_mixcolumn_fwd(sb[63..32]) @ aes_mixcolumn_fwd(sb[31..0]);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "aes64im",
  "name": "AES Decrypt KeySchedule MixColumns (RV64)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b00", "size": 2 }, { "field": "0b11000", "size": 5 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zknd" ],
  "function": "{\n  assert(sizeof(xlen) == 64);\n  let w0 : bits(32) = aes_mixcolumn_inv(X(rs1)[31.. 0]);\n  let w1 : bits(32) = aes_mixcolumn_inv(X(rs1)[63..32]);\n  X(rd)  = w1 @ w0;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "aes64ks1i",
  "name": "AES Key Schedule Instruction 1 (RV64)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rnum", "type": "bits(4)", "optional": false } ],
  "syntax": "rd,rs1,rnum",
  "format": "TBD",
  "fields": [ { "field": "0b00", "size": 2 }, { "field": "0b11000", "size": 5 }, { "field": "0b1", "size": 1 }, { "field": "rnum", "size": 4 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zkne","Zknd" ],
  "function": "{\n  assert(sizeof(xlen) == 64);\n  let prev     : bits(32) = X(rs1)[63..32];\n  let subwords : bits(32) = aes_subword_fwd(prev);\n  let result   : bits(32) = if (rnum == 0xA) then subwords\n                            else (subwords >>> 8) ^ aes_decode_rcon(rnum);\n  X(rd) = result @ result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "aes64ks2",
  "name": "AES Key Schedule Instruction 2 (RV64)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b01", "size": 2 }, { "field": "0b11111", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zkne","Zknd" ],
  "function": "{\n  assert(sizeof(xlen) == 64);\n  let w0 : bits(32) = X(rs1)[63..32] ^ X(rs2)[31..0];\n  let w1 : bits(32) = X(rs1)[63..32] ^ X(rs2)[31..0] ^ X(rs2)[63..32];\n  X(rd)  = w1 @ w0;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoadd.b",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoadd.b.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoadd.b.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoadd.b.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoadd.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoadd.d.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoadd.d.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoadd.d.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoadd.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoadd.h.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoadd.h.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoadd.h.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoadd.w",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoadd.w.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoadd.w.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoadd.w.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoand.b",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoand.b.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoand.b.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoand.b.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoand.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoand.d.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoand.d.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoand.d.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoand.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoand.h.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoand.h.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoand.h.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoand.w",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoand.w.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoand.w.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoand.w.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomax.b",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomax.b.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomax.b.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomax.b.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomax.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomax.d.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomax.d.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomax.d.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomax.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomax.h.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomax.h.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomax.h.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomax.w",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomax.w.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomax.w.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomax.w.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomaxu.b",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomaxu.b.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomaxu.b.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomaxu.b.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomaxu.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomaxu.d.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomaxu.d.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomaxu.d.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomaxu.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomaxu.h.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomaxu.h.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomaxu.h.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomaxu.w",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomaxu.w.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomaxu.w.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomaxu.w.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomin.b",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomin.b.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomin.b.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomin.b.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomin.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomin.d.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomin.d.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomin.d.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomin.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomin.h.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomin.h.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomin.h.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomin.w",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomin.w.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomin.w.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amomin.w.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amominu.b",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amominu.b.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amominu.b.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amominu.b.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amominu.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amominu.d.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amominu.d.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amominu.d.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amominu.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amominu.h.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amominu.h.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amominu.h.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amominu.w",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amominu.w.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amominu.w.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amominu.w.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoor.b",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoor.b.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoor.b.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoor.b.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoor.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoor.d.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoor.d.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoor.d.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoor.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoor.h.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoor.h.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoor.h.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoor.w",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoor.w.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoor.w.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoor.w.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoswap.b",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoswap.b.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoswap.b.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoswap.b.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoswap.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoswap.d.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoswap.d.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoswap.d.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoswap.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoswap.h.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoswap.h.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoswap.h.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoswap.w",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoswap.w.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoswap.w.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoswap.w.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoxor.b",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoxor.b.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoxor.b.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoxor.b.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoxor.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoxor.d.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoxor.d.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoxor.d.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoxor.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoxor.h.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoxor.h.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoxor.h.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoxor.w",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoxor.w.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoxor.w.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "amoxor.w.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_amoop(op)", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zaamo" ],
  "function": "{\n  let 'width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Some extensions perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, ReadWrite(Data, Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n          let rs2_val = X(rs2)[width_bytes * 8 - 1 .. 0];\n          match eares {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              match mem_read(ReadWrite(Data, Data), addr, width_bytes, aq, aq & rl, true) {\n                MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                MemValue(loaded) => {\n                  let result : bits('width_bytes * 8) =\n                    match op {\n                      AMOSWAP => rs2_val,\n                      AMOADD  => rs2_val + loaded,\n                      AMOXOR  => rs2_val ^ loaded,\n                      AMOAND  => rs2_val & loaded,\n                      AMOOR   => rs2_val | loaded,\n                      AMOMIN  => if rs2_val <_s loaded then rs2_val else loaded,\n                      AMOMAX  => if rs2_val >_s loaded then rs2_val else loaded,\n                      AMOMINU => if rs2_val <_u loaded then rs2_val else loaded,\n                      AMOMAXU => if rs2_val >_u loaded then rs2_val else loaded,\n                    };\n                  match mem_write_value(addr, width_bytes, sign_extend(result), aq & rl, rl, true) {\n                    MemValue(true)  => { X(rd) = sign_extend(loaded); RETIRE_SUCCESS },\n                    MemValue(false) => { internal_error(__FILE__, __LINE__, \"AMO got false from mem_write_value\") },\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "and",
  "name": "AND",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ADD  => rs1_val + rs2_val,\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\n    RISCV_AND  => rs1_val & rs2_val,\n    RISCV_OR   => rs1_val | rs2_val,\n    RISCV_XOR  => rs1_val ^ rs2_val,\n    RISCV_SLL  => if   sizeof(xlen) == 32\n                  then rs1_val << (rs2_val[4..0])\n                  else rs1_val << (rs2_val[5..0]),\n    RISCV_SRL  => if   sizeof(xlen) == 32\n                  then rs1_val >> (rs2_val[4..0])\n                  else rs1_val >> (rs2_val[5..0]),\n    RISCV_SUB  => rs1_val - rs2_val,\n    RISCV_SRA  => if   sizeof(xlen) == 32\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe R-type (Register-type) instruction format is used for operations\nthat involve three registers. The specific operation is determined\nby the opcode and funct7 fields. The result is written to the\ndestination register (rd), and the source operands are specified\nby the source registers (rs1 and rs2). The format is common for\narithmetic, logical, and shift operations.\n "
},
{
  "mnemonic": "andi",
  "name": "AND immediate",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false } ],
  "syntax": "rd,rs1,imm",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "encdec_iop(op)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let immext : xlenbits = sign_extend(imm);\n  let result : xlenbits = match op {\n    RISCV_ADDI  => rs1_val + immext,\n    RISCV_SLTI  => zero_extend(bool_to_bits(rs1_val <_s immext)),\n    RISCV_SLTIU => zero_extend(bool_to_bits(rs1_val <_u immext)),\n    RISCV_ANDI  => rs1_val & immext,\n    RISCV_ORI   => rs1_val | immext,\n    RISCV_XORI  => rs1_val ^ immext\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe ITYPE instruction operates on an immediate value, adding, comparing, or\nperforming bitwise operations with the contents of register rs1.\nThe immediate value, rs1, and the operation code (iop) determine the operation.\nThe result is stored in register rd.\nThe supported immediate operations (iop) include:\n  - \"addi\"  : Add immediate\n  - \"slti\"  : Set less than immediate (signed)\n  - \"sltiu\" : Set less than immediate (unsigned)\n  - \"andi\"  : AND immediate\n  - \"ori\"   : OR immediate\n  - \"xori\"  : XOR immediate\n\nNote: The immediate value is sign-extended before performing the operation.\n "
},
{
  "mnemonic": "andn",
  "name": "AND with inverted operand",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0110000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbb","Zbkb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ANDN => rs1_val & ~(rs2_val),\n    RISCV_ORN  => rs1_val | ~(rs2_val),\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_ROL  => if sizeof(xlen) == 32\n                  then rs1_val <<< rs2_val[4..0]\n                  else rs1_val <<< rs2_val[5..0],\n    RISCV_ROR  => if sizeof(xlen) == 32\n                  then rs1_val >>> rs2_val[4..0]\n                  else rs1_val >>> rs2_val[5..0]\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "auipc",
  "name": "add upper immediate to PC",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(20)", "optional": false } ],
  "syntax": "rd,imm",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 20 }, { "field": "rd", "size": 5 }, { "field": "encdec_uop(op)", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let off : xlenbits = sign_extend(imm @ 0x000);\n  let ret : xlenbits = match op {\n    RISCV_LUI   => off,\n    RISCV_AUIPC => get_arch_pc() + off\n  };\n  X(rd) = ret;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "bclr",
  "name": "single-bit clear (register)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010100", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbs" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let mask : xlenbits = if sizeof(xlen) == 32\n                        then zero_extend(0b1) << rs2_val[4..0]\n                        else zero_extend(0b1) << rs2_val[5..0];\n  let result : xlenbits = match op {\n    RISCV_BCLR => rs1_val & ~(mask),\n    RISCV_BEXT => zero_extend(bool_to_bits((rs1_val & mask) != zeros())),\n    RISCV_BINV => rs1_val ^ mask,\n    RISCV_BSET => rs1_val | mask\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "bclri",
  "name": "single-bit clear (immediate)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "shamt", "type": "bits(6)", "optional": false } ],
  "syntax": "rd,rs1,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b001010", "size": 6 }, { "field": "shamt", "size": 6 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zbs" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let mask : xlenbits = if sizeof(xlen) == 32\n                        then zero_extend(0b1) << shamt[4..0]\n                        else zero_extend(0b1) << shamt;\n  let result : xlenbits = match op {\n    RISCV_BCLRI => rs1_val & ~(mask),\n    RISCV_BEXTI => zero_extend(bool_to_bits((rs1_val & mask) != zeros())),\n    RISCV_BINVI => rs1_val ^ mask,\n    RISCV_BSETI => rs1_val | mask\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "beq",
  "name": "conditional branch",
  "operands": [ { "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(13)", "optional": false } ],
  "syntax": "rs1,rs2,imm",
  "format": "TBD",
  "fields": [ { "field": "imm7_6", "size": 1 }, { "field": "imm7_5_0", "size": 6 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_bop(op)", "size": 3 }, { "field": "imm5_4_1", "size": 4 }, { "field": "imm5_0", "size": 1 }, { "field": "0b1100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let taken : bool = match op {\n    RISCV_BEQ  => rs1_val == rs2_val,\n    RISCV_BNE  => rs1_val != rs2_val,\n    RISCV_BLT  => rs1_val <_s rs2_val,\n    RISCV_BGE  => rs1_val >=_s rs2_val,\n    RISCV_BLTU => rs1_val <_u rs2_val,\n    RISCV_BGEU => rs1_val >=_u rs2_val\n  };\n  let t : xlenbits = PC + sign_extend(imm);\n  if taken then {\n    /* Extensions get the first checks on the prospective target address. */\n    match ext_control_check_pc(t) {\n      Ext_ControlAddr_Error(e) => {\n        ext_handle_control_check_error(e);\n        RETIRE_FAIL\n      },\n      Ext_ControlAddr_OK(target) => {\n        if bit_to_bool(target[1]) & not(extensionEnabled(Ext_Zca)) then {\n          handle_mem_exception(target, E_Fetch_Addr_Align());\n          RETIRE_FAIL;\n        } else {\n          set_next_pc(target);\n          RETIRE_SUCCESS\n        }\n      }\n    }\n  } else RETIRE_SUCCESS\n}",
  "description": "\nThe target address for this branch instruction is determined by combining\nthe sign-extended 13-bit immediate value with the contents of register rs1.\nAdditionally, the least-significant bit of the result is set to zero.\nThe condition for the branch is based on the specified operation (bop),\nwhich can be one of the following mnemonic codes:\n  - \"beq\"   : Branch if equal\n  - \"bne\"   : Branch if not equal\n  - \"blt\"   : Branch if less than (signed)\n  - \"bge\"   : Branch if greater than or equal to (signed)\n  - \"bltu\"  : Branch if less than (unsigned)\n  - \"bgeu\"  : Branch if greater than or equal to (unsigned)\n\nThe branch is taken if the specified condition is true, leading to a jump\nto the target address. If the branch is not taken, the execution proceeds\nto the next instruction.\n "
},
{
  "mnemonic": "bext",
  "name": "single-bit extract (register)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010100", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbs" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let mask : xlenbits = if sizeof(xlen) == 32\n                        then zero_extend(0b1) << rs2_val[4..0]\n                        else zero_extend(0b1) << rs2_val[5..0];\n  let result : xlenbits = match op {\n    RISCV_BCLR => rs1_val & ~(mask),\n    RISCV_BEXT => zero_extend(bool_to_bits((rs1_val & mask) != zeros())),\n    RISCV_BINV => rs1_val ^ mask,\n    RISCV_BSET => rs1_val | mask\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "bexti",
  "name": "single-bit extract (immediate)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "shamt", "type": "bits(6)", "optional": false } ],
  "syntax": "rd,rs1,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b001010", "size": 6 }, { "field": "shamt", "size": 6 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zbs" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let mask : xlenbits = if sizeof(xlen) == 32\n                        then zero_extend(0b1) << shamt[4..0]\n                        else zero_extend(0b1) << shamt;\n  let result : xlenbits = match op {\n    RISCV_BCLRI => rs1_val & ~(mask),\n    RISCV_BEXTI => zero_extend(bool_to_bits((rs1_val & mask) != zeros())),\n    RISCV_BINVI => rs1_val ^ mask,\n    RISCV_BSETI => rs1_val | mask\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "bge",
  "name": "conditional branch",
  "operands": [ { "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(13)", "optional": false } ],
  "syntax": "rs1,rs2,imm",
  "format": "TBD",
  "fields": [ { "field": "imm7_6", "size": 1 }, { "field": "imm7_5_0", "size": 6 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_bop(op)", "size": 3 }, { "field": "imm5_4_1", "size": 4 }, { "field": "imm5_0", "size": 1 }, { "field": "0b1100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let taken : bool = match op {\n    RISCV_BEQ  => rs1_val == rs2_val,\n    RISCV_BNE  => rs1_val != rs2_val,\n    RISCV_BLT  => rs1_val <_s rs2_val,\n    RISCV_BGE  => rs1_val >=_s rs2_val,\n    RISCV_BLTU => rs1_val <_u rs2_val,\n    RISCV_BGEU => rs1_val >=_u rs2_val\n  };\n  let t : xlenbits = PC + sign_extend(imm);\n  if taken then {\n    /* Extensions get the first checks on the prospective target address. */\n    match ext_control_check_pc(t) {\n      Ext_ControlAddr_Error(e) => {\n        ext_handle_control_check_error(e);\n        RETIRE_FAIL\n      },\n      Ext_ControlAddr_OK(target) => {\n        if bit_to_bool(target[1]) & not(extensionEnabled(Ext_Zca)) then {\n          handle_mem_exception(target, E_Fetch_Addr_Align());\n          RETIRE_FAIL;\n        } else {\n          set_next_pc(target);\n          RETIRE_SUCCESS\n        }\n      }\n    }\n  } else RETIRE_SUCCESS\n}",
  "description": "\nThe target address for this branch instruction is determined by combining\nthe sign-extended 13-bit immediate value with the contents of register rs1.\nAdditionally, the least-significant bit of the result is set to zero.\nThe condition for the branch is based on the specified operation (bop),\nwhich can be one of the following mnemonic codes:\n  - \"beq\"   : Branch if equal\n  - \"bne\"   : Branch if not equal\n  - \"blt\"   : Branch if less than (signed)\n  - \"bge\"   : Branch if greater than or equal to (signed)\n  - \"bltu\"  : Branch if less than (unsigned)\n  - \"bgeu\"  : Branch if greater than or equal to (unsigned)\n\nThe branch is taken if the specified condition is true, leading to a jump\nto the target address. If the branch is not taken, the execution proceeds\nto the next instruction.\n "
},
{
  "mnemonic": "bgeu",
  "name": "conditional branch",
  "operands": [ { "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(13)", "optional": false } ],
  "syntax": "rs1,rs2,imm",
  "format": "TBD",
  "fields": [ { "field": "imm7_6", "size": 1 }, { "field": "imm7_5_0", "size": 6 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_bop(op)", "size": 3 }, { "field": "imm5_4_1", "size": 4 }, { "field": "imm5_0", "size": 1 }, { "field": "0b1100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let taken : bool = match op {\n    RISCV_BEQ  => rs1_val == rs2_val,\n    RISCV_BNE  => rs1_val != rs2_val,\n    RISCV_BLT  => rs1_val <_s rs2_val,\n    RISCV_BGE  => rs1_val >=_s rs2_val,\n    RISCV_BLTU => rs1_val <_u rs2_val,\n    RISCV_BGEU => rs1_val >=_u rs2_val\n  };\n  let t : xlenbits = PC + sign_extend(imm);\n  if taken then {\n    /* Extensions get the first checks on the prospective target address. */\n    match ext_control_check_pc(t) {\n      Ext_ControlAddr_Error(e) => {\n        ext_handle_control_check_error(e);\n        RETIRE_FAIL\n      },\n      Ext_ControlAddr_OK(target) => {\n        if bit_to_bool(target[1]) & not(extensionEnabled(Ext_Zca)) then {\n          handle_mem_exception(target, E_Fetch_Addr_Align());\n          RETIRE_FAIL;\n        } else {\n          set_next_pc(target);\n          RETIRE_SUCCESS\n        }\n      }\n    }\n  } else RETIRE_SUCCESS\n}",
  "description": "\nThe target address for this branch instruction is determined by combining\nthe sign-extended 13-bit immediate value with the contents of register rs1.\nAdditionally, the least-significant bit of the result is set to zero.\nThe condition for the branch is based on the specified operation (bop),\nwhich can be one of the following mnemonic codes:\n  - \"beq\"   : Branch if equal\n  - \"bne\"   : Branch if not equal\n  - \"blt\"   : Branch if less than (signed)\n  - \"bge\"   : Branch if greater than or equal to (signed)\n  - \"bltu\"  : Branch if less than (unsigned)\n  - \"bgeu\"  : Branch if greater than or equal to (unsigned)\n\nThe branch is taken if the specified condition is true, leading to a jump\nto the target address. If the branch is not taken, the execution proceeds\nto the next instruction.\n "
},
{
  "mnemonic": "binv",
  "name": "single-bit invert (register)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010100", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbs" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let mask : xlenbits = if sizeof(xlen) == 32\n                        then zero_extend(0b1) << rs2_val[4..0]\n                        else zero_extend(0b1) << rs2_val[5..0];\n  let result : xlenbits = match op {\n    RISCV_BCLR => rs1_val & ~(mask),\n    RISCV_BEXT => zero_extend(bool_to_bits((rs1_val & mask) != zeros())),\n    RISCV_BINV => rs1_val ^ mask,\n    RISCV_BSET => rs1_val | mask\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "binvi",
  "name": "single-bit invert (immediate)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "shamt", "type": "bits(6)", "optional": false } ],
  "syntax": "rd,rs1,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b001010", "size": 6 }, { "field": "shamt", "size": 6 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zbs" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let mask : xlenbits = if sizeof(xlen) == 32\n                        then zero_extend(0b1) << shamt[4..0]\n                        else zero_extend(0b1) << shamt;\n  let result : xlenbits = match op {\n    RISCV_BCLRI => rs1_val & ~(mask),\n    RISCV_BEXTI => zero_extend(bool_to_bits((rs1_val & mask) != zeros())),\n    RISCV_BINVI => rs1_val ^ mask,\n    RISCV_BSETI => rs1_val | mask\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "blt",
  "name": "conditional branch",
  "operands": [ { "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(13)", "optional": false } ],
  "syntax": "rs1,rs2,imm",
  "format": "TBD",
  "fields": [ { "field": "imm7_6", "size": 1 }, { "field": "imm7_5_0", "size": 6 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_bop(op)", "size": 3 }, { "field": "imm5_4_1", "size": 4 }, { "field": "imm5_0", "size": 1 }, { "field": "0b1100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let taken : bool = match op {\n    RISCV_BEQ  => rs1_val == rs2_val,\n    RISCV_BNE  => rs1_val != rs2_val,\n    RISCV_BLT  => rs1_val <_s rs2_val,\n    RISCV_BGE  => rs1_val >=_s rs2_val,\n    RISCV_BLTU => rs1_val <_u rs2_val,\n    RISCV_BGEU => rs1_val >=_u rs2_val\n  };\n  let t : xlenbits = PC + sign_extend(imm);\n  if taken then {\n    /* Extensions get the first checks on the prospective target address. */\n    match ext_control_check_pc(t) {\n      Ext_ControlAddr_Error(e) => {\n        ext_handle_control_check_error(e);\n        RETIRE_FAIL\n      },\n      Ext_ControlAddr_OK(target) => {\n        if bit_to_bool(target[1]) & not(extensionEnabled(Ext_Zca)) then {\n          handle_mem_exception(target, E_Fetch_Addr_Align());\n          RETIRE_FAIL;\n        } else {\n          set_next_pc(target);\n          RETIRE_SUCCESS\n        }\n      }\n    }\n  } else RETIRE_SUCCESS\n}",
  "description": "\nThe target address for this branch instruction is determined by combining\nthe sign-extended 13-bit immediate value with the contents of register rs1.\nAdditionally, the least-significant bit of the result is set to zero.\nThe condition for the branch is based on the specified operation (bop),\nwhich can be one of the following mnemonic codes:\n  - \"beq\"   : Branch if equal\n  - \"bne\"   : Branch if not equal\n  - \"blt\"   : Branch if less than (signed)\n  - \"bge\"   : Branch if greater than or equal to (signed)\n  - \"bltu\"  : Branch if less than (unsigned)\n  - \"bgeu\"  : Branch if greater than or equal to (unsigned)\n\nThe branch is taken if the specified condition is true, leading to a jump\nto the target address. If the branch is not taken, the execution proceeds\nto the next instruction.\n "
},
{
  "mnemonic": "bltu",
  "name": "conditional branch",
  "operands": [ { "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(13)", "optional": false } ],
  "syntax": "rs1,rs2,imm",
  "format": "TBD",
  "fields": [ { "field": "imm7_6", "size": 1 }, { "field": "imm7_5_0", "size": 6 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_bop(op)", "size": 3 }, { "field": "imm5_4_1", "size": 4 }, { "field": "imm5_0", "size": 1 }, { "field": "0b1100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let taken : bool = match op {\n    RISCV_BEQ  => rs1_val == rs2_val,\n    RISCV_BNE  => rs1_val != rs2_val,\n    RISCV_BLT  => rs1_val <_s rs2_val,\n    RISCV_BGE  => rs1_val >=_s rs2_val,\n    RISCV_BLTU => rs1_val <_u rs2_val,\n    RISCV_BGEU => rs1_val >=_u rs2_val\n  };\n  let t : xlenbits = PC + sign_extend(imm);\n  if taken then {\n    /* Extensions get the first checks on the prospective target address. */\n    match ext_control_check_pc(t) {\n      Ext_ControlAddr_Error(e) => {\n        ext_handle_control_check_error(e);\n        RETIRE_FAIL\n      },\n      Ext_ControlAddr_OK(target) => {\n        if bit_to_bool(target[1]) & not(extensionEnabled(Ext_Zca)) then {\n          handle_mem_exception(target, E_Fetch_Addr_Align());\n          RETIRE_FAIL;\n        } else {\n          set_next_pc(target);\n          RETIRE_SUCCESS\n        }\n      }\n    }\n  } else RETIRE_SUCCESS\n}",
  "description": "\nThe target address for this branch instruction is determined by combining\nthe sign-extended 13-bit immediate value with the contents of register rs1.\nAdditionally, the least-significant bit of the result is set to zero.\nThe condition for the branch is based on the specified operation (bop),\nwhich can be one of the following mnemonic codes:\n  - \"beq\"   : Branch if equal\n  - \"bne\"   : Branch if not equal\n  - \"blt\"   : Branch if less than (signed)\n  - \"bge\"   : Branch if greater than or equal to (signed)\n  - \"bltu\"  : Branch if less than (unsigned)\n  - \"bgeu\"  : Branch if greater than or equal to (unsigned)\n\nThe branch is taken if the specified condition is true, leading to a jump\nto the target address. If the branch is not taken, the execution proceeds\nto the next instruction.\n "
},
{
  "mnemonic": "bne",
  "name": "conditional branch",
  "operands": [ { "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(13)", "optional": false } ],
  "syntax": "rs1,rs2,imm",
  "format": "TBD",
  "fields": [ { "field": "imm7_6", "size": 1 }, { "field": "imm7_5_0", "size": 6 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_bop(op)", "size": 3 }, { "field": "imm5_4_1", "size": 4 }, { "field": "imm5_0", "size": 1 }, { "field": "0b1100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let taken : bool = match op {\n    RISCV_BEQ  => rs1_val == rs2_val,\n    RISCV_BNE  => rs1_val != rs2_val,\n    RISCV_BLT  => rs1_val <_s rs2_val,\n    RISCV_BGE  => rs1_val >=_s rs2_val,\n    RISCV_BLTU => rs1_val <_u rs2_val,\n    RISCV_BGEU => rs1_val >=_u rs2_val\n  };\n  let t : xlenbits = PC + sign_extend(imm);\n  if taken then {\n    /* Extensions get the first checks on the prospective target address. */\n    match ext_control_check_pc(t) {\n      Ext_ControlAddr_Error(e) => {\n        ext_handle_control_check_error(e);\n        RETIRE_FAIL\n      },\n      Ext_ControlAddr_OK(target) => {\n        if bit_to_bool(target[1]) & not(extensionEnabled(Ext_Zca)) then {\n          handle_mem_exception(target, E_Fetch_Addr_Align());\n          RETIRE_FAIL;\n        } else {\n          set_next_pc(target);\n          RETIRE_SUCCESS\n        }\n      }\n    }\n  } else RETIRE_SUCCESS\n}",
  "description": "\nThe target address for this branch instruction is determined by combining\nthe sign-extended 13-bit immediate value with the contents of register rs1.\nAdditionally, the least-significant bit of the result is set to zero.\nThe condition for the branch is based on the specified operation (bop),\nwhich can be one of the following mnemonic codes:\n  - \"beq\"   : Branch if equal\n  - \"bne\"   : Branch if not equal\n  - \"blt\"   : Branch if less than (signed)\n  - \"bge\"   : Branch if greater than or equal to (signed)\n  - \"bltu\"  : Branch if less than (unsigned)\n  - \"bgeu\"  : Branch if greater than or equal to (unsigned)\n\nThe branch is taken if the specified condition is true, leading to a jump\nto the target address. If the branch is not taken, the execution proceeds\nto the next instruction.\n "
},
{
  "mnemonic": "brev8",
  "name": "reverse bits in bytes",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b011010000111", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zbkb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  var result : xlenbits = zeros();\n  foreach (i from 0 to (sizeof(xlen) - 8) by 8)\n    result[i+7..i] = reverse(rs1_val[i+7..i]);\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "bset",
  "name": "single-bit set (register)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010100", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbs" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let mask : xlenbits = if sizeof(xlen) == 32\n                        then zero_extend(0b1) << rs2_val[4..0]\n                        else zero_extend(0b1) << rs2_val[5..0];\n  let result : xlenbits = match op {\n    RISCV_BCLR => rs1_val & ~(mask),\n    RISCV_BEXT => zero_extend(bool_to_bits((rs1_val & mask) != zeros())),\n    RISCV_BINV => rs1_val ^ mask,\n    RISCV_BSET => rs1_val | mask\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "bseti",
  "name": "single-bit set (immediate)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "shamt", "type": "bits(6)", "optional": false } ],
  "syntax": "rd,rs1,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b001010", "size": 6 }, { "field": "shamt", "size": 6 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zbs" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let mask : xlenbits = if sizeof(xlen) == 32\n                        then zero_extend(0b1) << shamt[4..0]\n                        else zero_extend(0b1) << shamt;\n  let result : xlenbits = match op {\n    RISCV_BCLRI => rs1_val & ~(mask),\n    RISCV_BEXTI => zero_extend(bool_to_bits((rs1_val & mask) != zeros())),\n    RISCV_BINVI => rs1_val ^ mask,\n    RISCV_BSETI => rs1_val | mask\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.add",
  "name": "add (compressed)",
  "operands": [ { "name": "rsd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rsd,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b1", "size": 1 }, { "field": "rsd", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "0b10", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "execute(RTYPE(rs2, rsd, rsd, RISCV_ADD))",
  "description": "TBD"
},
{
  "mnemonic": "c.add.hint.",
  "name": "TBD",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rs2",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b1", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "0b10", "size": 2 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "c.addi",
  "name": "add immediate (compressed)",
  "operands": [ { "name": "rsd", "type": "regidx", "optional": false },{ "name": "nzi", "type": "bits(6)", "optional": false } ],
  "syntax": "rsd,nzi",
  "format": "TBD",
  "fields": [ { "field": "0b000", "size": 3 }, { "field": "nzi5", "size": 1 }, { "field": "rsd", "size": 5 }, { "field": "nzi40", "size": 5 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let imm : bits(12) = sign_extend(nzi);\n  execute(ITYPE(imm, rsd, rsd, RISCV_ADDI))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.addi.hint.",
  "name": "TBD",
  "operands": [ { "name": "rsd", "type": "regidx", "optional": false } ],
  "syntax": "rsd",
  "format": "TBD",
  "fields": [ { "field": "0b000", "size": 3 }, { "field": "0b0", "size": 1 }, { "field": "rsd", "size": 5 }, { "field": "0b00000", "size": 5 }, { "field": "0b01", "size": 2 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "c.addi16sp",
  "name": "TBD",
  "operands": [ { "name": "imm", "type": "bits(6)", "optional": false } ],
  "syntax": "imm",
  "format": "TBD",
  "fields": [ { "field": "0b011", "size": 3 }, { "field": "nzi9", "size": 1 }, { "field": "0b00010", "size": 5 }, { "field": "nzi4", "size": 1 }, { "field": "nzi6", "size": 1 }, { "field": "nzi87", "size": 2 }, { "field": "nzi5", "size": 1 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let imm : bits(12) = sign_extend(imm @ 0x0);\n  execute(ITYPE(imm, sp, sp, RISCV_ADDI))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.addi4spn",
  "name": "add zero-extend non-zero immediate scaled by 4 to stack pointer (compressed)",
  "operands": [ { "name": "rdc", "type": "cregidx", "optional": false },{ "name": "nzimm", "type": "bits(8)", "optional": false } ],
  "syntax": "rdc,nzimm,0b00",
  "format": "TBD",
  "fields": [ { "field": "0b000", "size": 3 }, { "field": "nz54", "size": 2 }, { "field": "nz96", "size": 4 }, { "field": "nz2", "size": 1 }, { "field": "nz3", "size": 1 }, { "field": "rd", "size": 3 }, { "field": "0b00", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let imm : bits(12) = (0b00 @ nzimm @ 0b00);\n  let rd = creg2reg_idx(rdc);\n  execute(ITYPE(imm, sp, rd, RISCV_ADDI))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.addiw",
  "name": "add immediate word (compressed) (RV64)",
  "operands": [ { "name": "rsd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(6)", "optional": false } ],
  "syntax": "rsd,imm",
  "format": "TBD",
  "fields": [ { "field": "0b001", "size": 3 }, { "field": "imm5", "size": 1 }, { "field": "rsd", "size": 5 }, { "field": "imm40", "size": 5 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "execute(ADDIW(sign_extend(imm), rsd, rsd))",
  "description": "TBD"
},
{
  "mnemonic": "c.addw",
  "name": "add word (compressed) (RV64)",
  "operands": [ { "name": "rsd", "type": "cregidx", "optional": false },{ "name": "rs2", "type": "cregidx", "optional": false } ],
  "syntax": "rsd,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b1", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "rsd", "size": 3 }, { "field": "0b01", "size": 2 }, { "field": "rs2", "size": 3 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let rsd = creg2reg_idx(rsd);\n  let rs2 = creg2reg_idx(rs2);\n  execute(RTYPEW(rs2, rsd, rsd, RISCV_ADDW))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.and",
  "name": "AND (compressed)",
  "operands": [ { "name": "rsd", "type": "cregidx", "optional": false },{ "name": "rs2", "type": "cregidx", "optional": false } ],
  "syntax": "rsd,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "rsd", "size": 3 }, { "field": "0b11", "size": 2 }, { "field": "rs2", "size": 3 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let rsd = creg2reg_idx(rsd);\n  let rs2 = creg2reg_idx(rs2);\n  execute(RTYPE(rs2, rsd, rsd, RISCV_AND))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.andi",
  "name": "AND immediate (compressed)",
  "operands": [ { "name": "rsd", "type": "cregidx", "optional": false },{ "name": "imm", "type": "bits(6)", "optional": false } ],
  "syntax": "rsd,imm",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "i5", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "rsd", "size": 3 }, { "field": "i40", "size": 5 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let rsd = creg2reg_idx(rsd);\n  execute(ITYPE(sign_extend(imm), rsd, rsd, RISCV_ANDI))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.beqz",
  "name": "branch if equals zero (compressed)",
  "operands": [ { "name": "rs", "type": "cregidx", "optional": false },{ "name": "imm", "type": "bits(8)", "optional": false } ],
  "syntax": "rs,imm",
  "format": "TBD",
  "fields": [ { "field": "0b110", "size": 3 }, { "field": "i8", "size": 1 }, { "field": "i43", "size": 2 }, { "field": "rs", "size": 3 }, { "field": "i76", "size": 2 }, { "field": "i21", "size": 2 }, { "field": "i5", "size": 1 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "execute(BTYPE(sign_extend(imm @ 0b0), zreg, creg2reg_idx(rs), RISCV_BEQ))",
  "description": "TBD"
},
{
  "mnemonic": "c.bnez",
  "name": "branch if not equals zero (compressed)",
  "operands": [ { "name": "rs", "type": "cregidx", "optional": false },{ "name": "imm", "type": "bits(8)", "optional": false } ],
  "syntax": "rs,imm",
  "format": "TBD",
  "fields": [ { "field": "0b111", "size": 3 }, { "field": "i8", "size": 1 }, { "field": "i43", "size": 2 }, { "field": "rs", "size": 3 }, { "field": "i76", "size": 2 }, { "field": "i21", "size": 2 }, { "field": "i5", "size": 1 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "execute(BTYPE(sign_extend(imm @ 0b0), zreg, creg2reg_idx(rs), RISCV_BNE))",
  "description": "TBD"
},
{
  "mnemonic": "c.ebreak",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b1", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "0b00000", "size": 5 }, { "field": "0b10", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "execute(EBREAK())",
  "description": "TBD"
},
{
  "mnemonic": "c.fld",
  "name": "load double-precision floating point (compressed)",
  "operands": [ { "name": "rdc", "type": "cregidx", "optional": false },{ "name": "rsc", "type": "cregidx", "optional": false },{ "name": "uimm", "type": "bits(5)", "optional": false } ],
  "syntax": "rdc,rsc,uimm,0b000",
  "format": "TBD",
  "fields": [ { "field": "0b001", "size": 3 }, { "field": "ui53", "size": 3 }, { "field": "rs1", "size": 3 }, { "field": "ui76", "size": 2 }, { "field": "rd", "size": 3 }, { "field": "0b00", "size": 2 } ],
  "extensions": [ "Zcd" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm @ 0b000);\n  let rd = creg2reg_idx(rdc);\n  let rs = creg2reg_idx(rsc);\n  execute(LOAD_FP(imm, rs, rd, DOUBLE))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.fldsp",
  "name": "load double-precision floating point from stack pointer (compressed)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "uimm", "type": "bits(6)", "optional": false } ],
  "syntax": "rd,uimm",
  "format": "TBD",
  "fields": [ { "field": "0b001", "size": 3 }, { "field": "ui5", "size": 1 }, { "field": "rd", "size": 5 }, { "field": "ui43", "size": 2 }, { "field": "ui86", "size": 3 }, { "field": "0b10", "size": 2 } ],
  "extensions": [ "Zcd" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm @ 0b000);\n  execute(LOAD_FP(imm, sp, rd, DOUBLE))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.flw",
  "name": "TBD",
  "operands": [ { "name": "rdc", "type": "cregidx", "optional": false },{ "name": "rsc", "type": "cregidx", "optional": false },{ "name": "uimm", "type": "bits(5)", "optional": false } ],
  "syntax": "rdc,rsc,uimm,0b00",
  "format": "TBD",
  "fields": [ { "field": "0b011", "size": 3 }, { "field": "ui53", "size": 3 }, { "field": "rs1", "size": 3 }, { "field": "ui2", "size": 1 }, { "field": "ui6", "size": 1 }, { "field": "rd", "size": 3 }, { "field": "0b00", "size": 2 } ],
  "extensions": [ "Zcf" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm @ 0b00);\n  let rd = creg2reg_idx(rdc);\n  let rs = creg2reg_idx(rsc);\n  execute(LOAD_FP(imm, rs, rd, WORD))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.flwsp",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(6)", "optional": false } ],
  "syntax": "rd,imm",
  "format": "TBD",
  "fields": [ { "field": "0b011", "size": 3 }, { "field": "ui5", "size": 1 }, { "field": "rd", "size": 5 }, { "field": "ui42", "size": 3 }, { "field": "ui76", "size": 2 }, { "field": "0b10", "size": 2 } ],
  "extensions": [ "Zcf" ],
  "function": "{\n  let imm : bits(12) = zero_extend(imm @ 0b00);\n  execute(LOAD_FP(imm, sp, rd, WORD))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.fsd",
  "name": "store double-precision floating point (compressed)",
  "operands": [ { "name": "rsc1", "type": "cregidx", "optional": false },{ "name": "rsc2", "type": "cregidx", "optional": false },{ "name": "uimm", "type": "bits(5)", "optional": false } ],
  "syntax": "rsc1,rsc2,uimm,0b000",
  "format": "TBD",
  "fields": [ { "field": "0b101", "size": 3 }, { "field": "ui53", "size": 3 }, { "field": "rs1", "size": 3 }, { "field": "ui76", "size": 2 }, { "field": "rs2", "size": 3 }, { "field": "0b00", "size": 2 } ],
  "extensions": [ "Zcd" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm @ 0b000);\n  let rs1 = creg2reg_idx(rsc1);\n  let rs2 = creg2reg_idx(rsc2);\n  execute(STORE_FP(imm, rs2, rs1, DOUBLE))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.fsdsp",
  "name": "store double-precision floating point to stack pointer (compressed)",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "uimm", "type": "bits(6)", "optional": false } ],
  "syntax": "rs2,uimm",
  "format": "TBD",
  "fields": [ { "field": "0b101", "size": 3 }, { "field": "ui53", "size": 3 }, { "field": "ui86", "size": 3 }, { "field": "rs2", "size": 5 }, { "field": "0b10", "size": 2 } ],
  "extensions": [ "Zcd" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm @ 0b000);\n  execute(STORE_FP(imm, rs2, sp, DOUBLE))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.fsw",
  "name": "TBD",
  "operands": [ { "name": "rsc1", "type": "cregidx", "optional": false },{ "name": "rsc2", "type": "cregidx", "optional": false },{ "name": "uimm", "type": "bits(5)", "optional": false } ],
  "syntax": "rsc1,rsc2,uimm,0b00",
  "format": "TBD",
  "fields": [ { "field": "0b111", "size": 3 }, { "field": "ui53", "size": 3 }, { "field": "rs1", "size": 3 }, { "field": "ui2", "size": 1 }, { "field": "ui6", "size": 1 }, { "field": "rs2", "size": 3 }, { "field": "0b00", "size": 2 } ],
  "extensions": [ "Zcf" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm @ 0b00);\n  let rs1 = creg2reg_idx(rsc1);\n  let rs2 = creg2reg_idx(rsc2);\n  execute(STORE_FP(imm, rs2, rs1, WORD))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.fswsp",
  "name": "TBD",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "uimm", "type": "bits(6)", "optional": false } ],
  "syntax": "rs2,uimm",
  "format": "TBD",
  "fields": [ { "field": "0b111", "size": 3 }, { "field": "ui52", "size": 4 }, { "field": "ui76", "size": 2 }, { "field": "rs2", "size": 5 }, { "field": "0b10", "size": 2 } ],
  "extensions": [ "Zcf" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm @ 0b00);\n  execute(STORE_FP(imm, rs2, sp, WORD))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.illegal",
  "name": "TBD",
  "operands": [ { "name": "s", "type": "half", "optional": false } ],
  "syntax": "s",
  "format": "TBD",
  "fields": [ { "field": "s", "size": 16 } ],
  "extensions": [  ],
  "function": "{ handle_illegal(); RETIRE_FAIL }",
  "description": "TBD"
},
{
  "mnemonic": "c.j",
  "name": "TBD",
  "operands": [ { "name": "imm", "type": "bits(11)", "optional": false } ],
  "syntax": "imm",
  "format": "TBD",
  "fields": [ { "field": "0b101", "size": 3 }, { "field": "i11", "size": 1 }, { "field": "i4", "size": 1 }, { "field": "i98", "size": 2 }, { "field": "i10", "size": 1 }, { "field": "i6", "size": 1 }, { "field": "i7", "size": 1 }, { "field": "i31", "size": 3 }, { "field": "i5", "size": 1 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "execute(RISCV_JAL(sign_extend(imm @ 0b0), zreg))",
  "description": "TBD"
},
{
  "mnemonic": "c.jal",
  "name": "TBD",
  "operands": [ { "name": "imm", "type": "bits(11)", "optional": false } ],
  "syntax": "imm,0b0",
  "format": "TBD",
  "fields": [ { "field": "0b001", "size": 3 }, { "field": "i11", "size": 1 }, { "field": "i4", "size": 1 }, { "field": "i98", "size": 2 }, { "field": "i10", "size": 1 }, { "field": "i6", "size": 1 }, { "field": "i7", "size": 1 }, { "field": "i31", "size": 3 }, { "field": "i5", "size": 1 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "execute(RISCV_JAL(sign_extend(imm @ 0b0), ra))",
  "description": "TBD"
},
{
  "mnemonic": "c.jalr",
  "name": "TBD",
  "operands": [ { "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs1",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b1", "size": 1 }, { "field": "rs1", "size": 5 }, { "field": "0b00000", "size": 5 }, { "field": "0b10", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "execute(RISCV_JALR(zero_extend(0b0), rs1, ra))",
  "description": "TBD"
},
{
  "mnemonic": "c.jr",
  "name": "TBD",
  "operands": [ { "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs1",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b0", "size": 1 }, { "field": "rs1", "size": 5 }, { "field": "0b00000", "size": 5 }, { "field": "0b10", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "execute(RISCV_JALR(zero_extend(0b0), rs1, zreg))",
  "description": "TBD"
},
{
  "mnemonic": "c.lbu",
  "name": "TBD",
  "operands": [ { "name": "rdc", "type": "cregidx", "optional": false },{ "name": "uimm", "type": "bits(2)", "optional": false },{ "name": "rs1c", "type": "cregidx", "optional": false } ],
  "syntax": "rdc,uimm(rs1c)",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rs1c", "size": 3 }, { "field": "uimm0", "size": 1 }, { "field": "uimm1", "size": 1 }, { "field": "rdc", "size": 3 }, { "field": "0b00", "size": 2 } ],
  "extensions": [ "Zcb" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm);\n  let rd = creg2reg_idx(rdc);\n  let rs1 = creg2reg_idx(rs1c);\n  execute(LOAD(imm, rs1, rd, true, BYTE, false, false))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.ld",
  "name": "load double-word (compressed)",
  "operands": [ { "name": "rdc", "type": "cregidx", "optional": false },{ "name": "rsc", "type": "cregidx", "optional": false },{ "name": "uimm", "type": "bits(5)", "optional": false } ],
  "syntax": "rdc,rsc,uimm,0b000",
  "format": "TBD",
  "fields": [ { "field": "0b011", "size": 3 }, { "field": "ui53", "size": 3 }, { "field": "rs1", "size": 3 }, { "field": "ui76", "size": 2 }, { "field": "rd", "size": 3 }, { "field": "0b00", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm @ 0b000);\n  let rd = creg2reg_idx(rdc);\n  let rs = creg2reg_idx(rsc);\n  execute(LOAD(imm, rs, rd, false, DOUBLE, false, false))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.ldsp",
  "name": "load double-word from stack pointer (compressed)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "uimm", "type": "bits(6)", "optional": false } ],
  "syntax": "rd,uimm",
  "format": "TBD",
  "fields": [ { "field": "0b011", "size": 3 }, { "field": "ui5", "size": 1 }, { "field": "rd", "size": 5 }, { "field": "ui43", "size": 2 }, { "field": "ui86", "size": 3 }, { "field": "0b10", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm @ 0b000);\n  execute(LOAD(imm, sp, rd, false, DOUBLE, false, false))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.lh",
  "name": "TBD",
  "operands": [ { "name": "rdc", "type": "cregidx", "optional": false },{ "name": "uimm", "type": "bits(2)", "optional": false },{ "name": "rs1c", "type": "cregidx", "optional": false } ],
  "syntax": "rdc,uimm(rs1c)",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rs1c", "size": 3 }, { "field": "0b1", "size": 1 }, { "field": "uimm1", "size": 1 }, { "field": "rdc", "size": 3 }, { "field": "0b00", "size": 2 } ],
  "extensions": [ "Zcb" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm);\n  let rd = creg2reg_idx(rdc);\n  let rs1 = creg2reg_idx(rs1c);\n  execute(LOAD(imm, rs1, rd, false, HALF, false, false))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.lhu",
  "name": "TBD",
  "operands": [ { "name": "rdc", "type": "cregidx", "optional": false },{ "name": "uimm", "type": "bits(2)", "optional": false },{ "name": "rs1c", "type": "cregidx", "optional": false } ],
  "syntax": "rdc,uimm(rs1c)",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rs1c", "size": 3 }, { "field": "0b0", "size": 1 }, { "field": "uimm1", "size": 1 }, { "field": "rdc", "size": 3 }, { "field": "0b00", "size": 2 } ],
  "extensions": [ "Zcb" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm);\n  let rd = creg2reg_idx(rdc);\n  let rs1 = creg2reg_idx(rs1c);\n  execute(LOAD(imm, rs1, rd, true, HALF, false, false))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.li",
  "name": "load immediate (compressed)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(6)", "optional": false } ],
  "syntax": "rd,imm",
  "format": "TBD",
  "fields": [ { "field": "0b010", "size": 3 }, { "field": "imm5", "size": 1 }, { "field": "rd", "size": 5 }, { "field": "imm40", "size": 5 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let imm : bits(12) = sign_extend(imm);\n  execute(ITYPE(imm, zreg, rd, RISCV_ADDI))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.li.hint.",
  "name": "TBD",
  "operands": [ { "name": "imm", "type": "bits(6)", "optional": false } ],
  "syntax": "imm",
  "format": "TBD",
  "fields": [ { "field": "0b010", "size": 3 }, { "field": "imm5", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "imm40", "size": 5 }, { "field": "0b01", "size": 2 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "c.lui",
  "name": "load upper immediate (compressed)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(6)", "optional": false } ],
  "syntax": "rd,imm",
  "format": "TBD",
  "fields": [ { "field": "0b011", "size": 3 }, { "field": "imm17", "size": 1 }, { "field": "rd", "size": 5 }, { "field": "imm1612", "size": 5 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let res : bits(20) = sign_extend(imm);\n  execute(UTYPE(res, rd, RISCV_LUI))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.lui.hint.",
  "name": "TBD",
  "operands": [ { "name": "imm", "type": "bits(6)", "optional": false } ],
  "syntax": "imm",
  "format": "TBD",
  "fields": [ { "field": "0b011", "size": 3 }, { "field": "imm17", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "imm1612", "size": 5 }, { "field": "0b01", "size": 2 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "c.lw",
  "name": "load word (compressed)",
  "operands": [ { "name": "rdc", "type": "cregidx", "optional": false },{ "name": "rsc", "type": "cregidx", "optional": false },{ "name": "uimm", "type": "bits(5)", "optional": false } ],
  "syntax": "rdc,rsc,uimm,0b00",
  "format": "TBD",
  "fields": [ { "field": "0b010", "size": 3 }, { "field": "ui53", "size": 3 }, { "field": "rs1", "size": 3 }, { "field": "ui2", "size": 1 }, { "field": "ui6", "size": 1 }, { "field": "rd", "size": 3 }, { "field": "0b00", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm @ 0b00);\n  let rd = creg2reg_idx(rdc);\n  let rs = creg2reg_idx(rsc);\n  execute(LOAD(imm, rs, rd, false, WORD, false, false))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.lwsp",
  "name": "load word from stack pointer (compressed)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "uimm", "type": "bits(6)", "optional": false } ],
  "syntax": "rd,uimm",
  "format": "TBD",
  "fields": [ { "field": "0b010", "size": 3 }, { "field": "ui5", "size": 1 }, { "field": "rd", "size": 5 }, { "field": "ui42", "size": 3 }, { "field": "ui76", "size": 2 }, { "field": "0b10", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm @ 0b00);\n  execute(LOAD(imm, sp, rd, false, WORD, false, false))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.mul",
  "name": "TBD",
  "operands": [ { "name": "rsdc", "type": "cregidx", "optional": false },{ "name": "rs2c", "type": "cregidx", "optional": false } ],
  "syntax": "rsdc,rs2c",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b111", "size": 3 }, { "field": "rsdc", "size": 3 }, { "field": "0b10", "size": 2 }, { "field": "rs2c", "size": 3 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zcb","M","Zmmul" ],
  "function": "{\n  let rd = creg2reg_idx(rsdc);\n  let rs = creg2reg_idx(rs2c);\n  execute(MUL(rs, rd, rd, struct { high = false, signed_rs1 = true, signed_rs2 = true }))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.mv",
  "name": "move (compressed)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b0", "size": 1 }, { "field": "rd", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "0b10", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "execute(RTYPE(rs2, zreg, rd, RISCV_ADD))",
  "description": "TBD"
},
{
  "mnemonic": "c.mv.hint.",
  "name": "TBD",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rs2",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b0", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "0b10", "size": 2 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "c.nop",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "0b000", "size": 3 }, { "field": "0b0", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "0b00000", "size": 5 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "c.nop.hint.",
  "name": "TBD",
  "operands": [ { "name": "imm", "type": "bits(6)", "optional": false } ],
  "syntax": "imm",
  "format": "TBD",
  "fields": [ { "field": "0b000", "size": 3 }, { "field": "im5", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "im40", "size": 5 }, { "field": "0b01", "size": 2 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "c.not",
  "name": "TBD",
  "operands": [ { "name": "rsdc", "type": "cregidx", "optional": false } ],
  "syntax": "rsdc",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b111", "size": 3 }, { "field": "rsdc", "size": 3 }, { "field": "0b11", "size": 2 }, { "field": "0b101", "size": 3 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zcb" ],
  "function": "{\n  let r = creg2reg_idx(rsdc);\n  X(r) = ~(X(r));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.or",
  "name": "OR (compressed)",
  "operands": [ { "name": "rsd", "type": "cregidx", "optional": false },{ "name": "rs2", "type": "cregidx", "optional": false } ],
  "syntax": "rsd,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "rsd", "size": 3 }, { "field": "0b10", "size": 2 }, { "field": "rs2", "size": 3 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let rsd = creg2reg_idx(rsd);\n  let rs2 = creg2reg_idx(rs2);\n  execute(RTYPE(rs2, rsd, rsd, RISCV_OR))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.sb",
  "name": "TBD",
  "operands": [ { "name": "rs2c", "type": "cregidx", "optional": false },{ "name": "uimm", "type": "bits(2)", "optional": false },{ "name": "rs1c", "type": "cregidx", "optional": false } ],
  "syntax": "rs2c,uimm(rs1c)",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b010", "size": 3 }, { "field": "rs1c", "size": 3 }, { "field": "uimm0", "size": 1 }, { "field": "uimm1", "size": 1 }, { "field": "rs2c", "size": 3 }, { "field": "0b00", "size": 2 } ],
  "extensions": [ "Zcb" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm);\n  let rs1 = creg2reg_idx(rs1c);\n  let rs2 = creg2reg_idx(rs2c);\n  execute(STORE(imm, rs2, rs1, BYTE, false, false))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.sd",
  "name": "store double-word (compressed)",
  "operands": [ { "name": "rsc1", "type": "cregidx", "optional": false },{ "name": "rsc2", "type": "cregidx", "optional": false },{ "name": "uimm", "type": "bits(5)", "optional": false } ],
  "syntax": "rsc1,rsc2,uimm,0b000",
  "format": "TBD",
  "fields": [ { "field": "0b111", "size": 3 }, { "field": "ui53", "size": 3 }, { "field": "rs1", "size": 3 }, { "field": "ui76", "size": 2 }, { "field": "rs2", "size": 3 }, { "field": "0b00", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm @ 0b000);\n  let rs1 = creg2reg_idx(rsc1);\n  let rs2 = creg2reg_idx(rsc2);\n  execute(STORE(imm, rs2, rs1, DOUBLE, false, false))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.sdsp",
  "name": "store double-word to stack pointer (compressed)",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "uimm", "type": "bits(6)", "optional": false } ],
  "syntax": "rs2,uimm",
  "format": "TBD",
  "fields": [ { "field": "0b111", "size": 3 }, { "field": "ui53", "size": 3 }, { "field": "ui86", "size": 3 }, { "field": "rs2", "size": 5 }, { "field": "0b10", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm @ 0b000);\n  execute(STORE(imm, rs2, sp, DOUBLE, false, false))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.sext.b",
  "name": "TBD",
  "operands": [ { "name": "rsdc", "type": "cregidx", "optional": false } ],
  "syntax": "rsdc",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b111", "size": 3 }, { "field": "rsdc", "size": 3 }, { "field": "0b11", "size": 2 }, { "field": "0b001", "size": 3 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zcb","Zbb" ],
  "function": "{\n  let rsd = creg2reg_idx(rsdc);\n  execute(ZBB_EXTOP(rsd, rsd, RISCV_SEXTB))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.sext.h",
  "name": "TBD",
  "operands": [ { "name": "rsdc", "type": "cregidx", "optional": false } ],
  "syntax": "rsdc",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b111", "size": 3 }, { "field": "rsdc", "size": 3 }, { "field": "0b11", "size": 2 }, { "field": "0b011", "size": 3 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zcb","Zbb" ],
  "function": "{\n  let rsd = creg2reg_idx(rsdc);\n  execute(ZBB_EXTOP(rsd, rsd,  RISCV_SEXTH))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.sh",
  "name": "TBD",
  "operands": [ { "name": "rs1c", "type": "cregidx", "optional": false },{ "name": "uimm", "type": "bits(2)", "optional": false },{ "name": "rs2c", "type": "cregidx", "optional": false } ],
  "syntax": "rs1c,uimm(rs2c)",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b011", "size": 3 }, { "field": "rs1c", "size": 3 }, { "field": "0b0", "size": 1 }, { "field": "uimm1", "size": 1 }, { "field": "rs2c", "size": 3 }, { "field": "0b00", "size": 2 } ],
  "extensions": [ "Zcb" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm);\n  let rs1 = creg2reg_idx(rs1c);\n  let rs2 = creg2reg_idx(rs2c);\n  execute(STORE(imm, rs2, rs1, HALF, false, false))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.slli",
  "name": "shift left (logical) immediate (compressed)",
  "operands": [ { "name": "rsd", "type": "regidx", "optional": false },{ "name": "shamt", "type": "bits(6)", "optional": false } ],
  "syntax": "rsd,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b000", "size": 3 }, { "field": "nzui5", "size": 1 }, { "field": "rsd", "size": 5 }, { "field": "nzui40", "size": 5 }, { "field": "0b10", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "execute(SHIFTIOP(shamt, rsd, rsd, RISCV_SLLI))",
  "description": "TBD"
},
{
  "mnemonic": "c.slli.hint.",
  "name": "TBD",
  "operands": [ { "name": "rsd", "type": "regidx", "optional": false },{ "name": "shamt", "type": "bits(6)", "optional": false } ],
  "syntax": "rsd,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b000", "size": 3 }, { "field": "nzui5", "size": 1 }, { "field": "rsd", "size": 5 }, { "field": "nzui40", "size": 5 }, { "field": "0b10", "size": 2 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "c.srai",
  "name": "shift right (arithmetic) immediate (compressed)",
  "operands": [ { "name": "rsd", "type": "cregidx", "optional": false },{ "name": "shamt", "type": "bits(6)", "optional": false } ],
  "syntax": "rsd,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "nzui5", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "rsd", "size": 3 }, { "field": "nzui40", "size": 5 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let rsd = creg2reg_idx(rsd);\n  execute(SHIFTIOP(shamt, rsd, rsd, RISCV_SRAI))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.srai.hint.",
  "name": "TBD",
  "operands": [ { "name": "rsd", "type": "cregidx", "optional": false } ],
  "syntax": "rsd",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "rsd", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b01", "size": 2 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "c.srli",
  "name": "shift right (logical) immediate (compressed)",
  "operands": [ { "name": "rsd", "type": "cregidx", "optional": false },{ "name": "shamt", "type": "bits(6)", "optional": false } ],
  "syntax": "rsd,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "nzui5", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "rsd", "size": 3 }, { "field": "nzui40", "size": 5 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let rsd = creg2reg_idx(rsd);\n  execute(SHIFTIOP(shamt, rsd, rsd, RISCV_SRLI))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.srli.hint.",
  "name": "TBD",
  "operands": [ { "name": "rsd", "type": "cregidx", "optional": false } ],
  "syntax": "rsd",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "rsd", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b01", "size": 2 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "c.sub",
  "name": "subtract (compressed)",
  "operands": [ { "name": "rsd", "type": "cregidx", "optional": false },{ "name": "rs2", "type": "cregidx", "optional": false } ],
  "syntax": "rsd,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "rsd", "size": 3 }, { "field": "0b00", "size": 2 }, { "field": "rs2", "size": 3 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let rsd = creg2reg_idx(rsd);\n  let rs2 = creg2reg_idx(rs2);\n  execute(RTYPE(rs2, rsd, rsd, RISCV_SUB))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.subw",
  "name": "subtract word (compressed) (RV64)",
  "operands": [ { "name": "rsd", "type": "cregidx", "optional": false },{ "name": "rs2", "type": "cregidx", "optional": false } ],
  "syntax": "rsd,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b1", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "rsd", "size": 3 }, { "field": "0b00", "size": 2 }, { "field": "rs2", "size": 3 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let rsd = creg2reg_idx(rsd);\n  let rs2 = creg2reg_idx(rs2);\n  execute(RTYPEW(rs2, rsd, rsd, RISCV_SUBW))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.sw",
  "name": "store word (compressed)",
  "operands": [ { "name": "rsc1", "type": "cregidx", "optional": false },{ "name": "rsc2", "type": "cregidx", "optional": false },{ "name": "uimm", "type": "bits(5)", "optional": false } ],
  "syntax": "rsc1,rsc2,uimm,0b00",
  "format": "TBD",
  "fields": [ { "field": "0b110", "size": 3 }, { "field": "ui53", "size": 3 }, { "field": "rs1", "size": 3 }, { "field": "ui2", "size": 1 }, { "field": "ui6", "size": 1 }, { "field": "rs2", "size": 3 }, { "field": "0b00", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm @ 0b00);\n  let rs1 = creg2reg_idx(rsc1);\n  let rs2 = creg2reg_idx(rsc2);\n  execute(STORE(imm, rs2, rs1, WORD, false, false))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.swsp",
  "name": "store word to stack pointer (compressed)",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "uimm", "type": "bits(6)", "optional": false } ],
  "syntax": "rs2,uimm",
  "format": "TBD",
  "fields": [ { "field": "0b110", "size": 3 }, { "field": "ui52", "size": 4 }, { "field": "ui76", "size": 2 }, { "field": "rs2", "size": 5 }, { "field": "0b10", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let imm : bits(12) = zero_extend(uimm @ 0b00);\n  execute(STORE(imm, rs2, sp, WORD, false, false))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.xor",
  "name": "exclusive OR (compressed)",
  "operands": [ { "name": "rsd", "type": "cregidx", "optional": false },{ "name": "rs2", "type": "cregidx", "optional": false } ],
  "syntax": "rsd,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "rsd", "size": 3 }, { "field": "0b01", "size": 2 }, { "field": "rs2", "size": 3 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zca" ],
  "function": "{\n  let rsd = creg2reg_idx(rsd);\n  let rs2 = creg2reg_idx(rs2);\n  execute(RTYPE(rs2, rsd, rsd, RISCV_XOR))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.zext.b",
  "name": "TBD",
  "operands": [ { "name": "rsdc", "type": "cregidx", "optional": false } ],
  "syntax": "rsdc",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b111", "size": 3 }, { "field": "rsdc", "size": 3 }, { "field": "0b11", "size": 2 }, { "field": "0b000", "size": 3 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zcb" ],
  "function": "{\n  let rsd = creg2reg_idx(rsdc);\n  X(rsd) = zero_extend(X(rsd)[7..0]);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.zext.h",
  "name": "TBD",
  "operands": [ { "name": "rsdc", "type": "cregidx", "optional": false } ],
  "syntax": "rsdc",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b111", "size": 3 }, { "field": "rsdc", "size": 3 }, { "field": "0b11", "size": 2 }, { "field": "0b010", "size": 3 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zcb","Zbb" ],
  "function": "{\n  let rsd = creg2reg_idx(rsdc);\n  execute(ZBB_EXTOP(rsd, rsd, RISCV_ZEXTH))\n}",
  "description": "TBD"
},
{
  "mnemonic": "c.zext.w",
  "name": "TBD",
  "operands": [ { "name": "rsdc", "type": "cregidx", "optional": false } ],
  "syntax": "rsdc",
  "format": "TBD",
  "fields": [ { "field": "0b100", "size": 3 }, { "field": "0b111", "size": 3 }, { "field": "rsdc", "size": 3 }, { "field": "0b11", "size": 2 }, { "field": "0b100", "size": 3 }, { "field": "0b01", "size": 2 } ],
  "extensions": [ "Zcb","Zba" ],
  "function": "{\n  let rsd = creg2reg_idx(rsdc);\n  execute (ZBA_RTYPEUW(0b00000, rsd, rsd, RISCV_ADDUW)) // Note 0b00000 is the regidx of the zero register\n}",
  "description": "TBD"
},
{
  "mnemonic": "cbo.clean",
  "name": "TBD",
  "operands": [ { "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_cbop(cbop)", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [ "Zicbom" ],
  "function": "match cbop {\n    CBO_CLEAN if cbo_clean_flush_enabled(cur_privilege) =>\n      process_clean_inval(rs1, cbop),\n    CBO_FLUSH if cbo_clean_flush_enabled(cur_privilege) =>\n      process_clean_inval(rs1, cbop),\n    CBO_INVAL if cbo_inval_enabled(cur_privilege) =>\n      process_clean_inval(rs1, if cbo_inval_as_inval(cur_privilege) then CBO_INVAL else CBO_FLUSH),\n    _ => {\n      handle_illegal();\n      RETIRE_FAIL\n    },\n  }",
  "description": "TBD"
},
{
  "mnemonic": "cbo.flush",
  "name": "TBD",
  "operands": [ { "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_cbop(cbop)", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [ "Zicbom" ],
  "function": "match cbop {\n    CBO_CLEAN if cbo_clean_flush_enabled(cur_privilege) =>\n      process_clean_inval(rs1, cbop),\n    CBO_FLUSH if cbo_clean_flush_enabled(cur_privilege) =>\n      process_clean_inval(rs1, cbop),\n    CBO_INVAL if cbo_inval_enabled(cur_privilege) =>\n      process_clean_inval(rs1, if cbo_inval_as_inval(cur_privilege) then CBO_INVAL else CBO_FLUSH),\n    _ => {\n      handle_illegal();\n      RETIRE_FAIL\n    },\n  }",
  "description": "TBD"
},
{
  "mnemonic": "cbo.inval",
  "name": "TBD",
  "operands": [ { "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "(rs1)",
  "format": "TBD",
  "fields": [ { "field": "encdec_cbop(cbop)", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [ "Zicbom" ],
  "function": "match cbop {\n    CBO_CLEAN if cbo_clean_flush_enabled(cur_privilege) =>\n      process_clean_inval(rs1, cbop),\n    CBO_FLUSH if cbo_clean_flush_enabled(cur_privilege) =>\n      process_clean_inval(rs1, cbop),\n    CBO_INVAL if cbo_inval_enabled(cur_privilege) =>\n      process_clean_inval(rs1, if cbo_inval_as_inval(cur_privilege) then CBO_INVAL else CBO_FLUSH),\n    _ => {\n      handle_illegal();\n      RETIRE_FAIL\n    },\n  }",
  "description": "TBD"
},
{
  "mnemonic": "cbo.zero",
  "name": "TBD",
  "operands": [ { "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b000000000100", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [ "Zicboz" ],
  "function": "{\n  if cbo_zero_enabled(cur_privilege) then {\n    let rs1_val = X(rs1);\n    let cache_block_size_exp = plat_cache_block_size_exp();\n    let cache_block_size = 2 ^ cache_block_size_exp;\n\n    // Offset from rs1 to the beginning of the cache block. This is 0 if rs1\n    // is aligned to the cache block, or negative if rs1 is misaligned.\n    let offset = (rs1_val & ~(zero_extend(ones(cache_block_size_exp)))) - rs1_val;\n\n    match ext_data_get_addr(rs1, offset, Write(Data), cache_block_size) {\n      Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        // \"An implementation may update the bytes in any order and with any granularity\n        //  and atomicity, including individual bytes.\"\n        //\n        // This implementation does a single atomic write.\n        match translateAddr(vaddr, Write(Data)) {\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          TR_Address(paddr, _) => {\n            let eares : MemoryOpResult(unit) = mem_write_ea(paddr, cache_block_size, false, false, false);\n            match (eares) {\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n              MemValue(_) => {\n                let res : MemoryOpResult(bool) = mem_write_value(paddr, cache_block_size, zeros(), false, false, false);\n                match (res) {\n                  MemValue(true) => RETIRE_SUCCESS,\n                  MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                }\n              }\n            }\n          }\n        }\n      },\n    }\n  } else {\n    handle_illegal();\n    RETIRE_FAIL\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "clmul",
  "name": "carry-less multiply (low-part)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000101", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbc","Zbkc" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  var result : xlenbits = zeros();\n  foreach (i from 0 to (xlen_val - 1))\n    if rs2_val[i] == bitone then result = result ^ (rs1_val << i);\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "clmulh",
  "name": "carry-less multiply (high-part)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000101", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbc","Zbkc" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  var result : xlenbits = zeros();\n  foreach (i from 0 to (xlen_val - 1))\n    if rs2_val[i] == bitone then result = result ^ (rs1_val >> (xlen_val - i));\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "clmulr",
  "name": "carry-less multiply (reversed)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000101", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbc" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  var result : xlenbits = zeros();\n  foreach (i from 0 to (xlen_val - 1))\n    if rs2_val[i] == bitone then result = result ^ (rs1_val >> (xlen_val - i - 1));\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "clz",
  "name": "count leading zero bits",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b011000000000", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zbb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  var result : nat = 0;\n  var done : bool = false;\n  foreach (i from (sizeof(xlen) - 1) downto 0)\n    if not(done) then if rs1_val[i] == bitzero\n                    then result = result + 1\n                    else done = true;\n  X(rd) = to_bits(sizeof(xlen), result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "clzw",
  "name": "count leading zero bits in word",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b011000000000", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0011011", "size": 7 } ],
  "extensions": [ "Zbb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  var result : nat = 0;\n  var done : bool = false;\n  foreach (i from 31 downto 0)\n    if not(done) then if rs1_val[i] == bitzero\n                    then result = result + 1\n                    else done = true;\n  X(rd) = to_bits(sizeof(xlen), result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "cpop",
  "name": "count set bits",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b011000000010", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zbb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  var result : nat = 0;\n  foreach (i from 0 to (xlen_val - 1))\n    if rs1_val[i] == bitone then result = result + 1;\n  X(rd) = to_bits(sizeof(xlen), result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "cpopw",
  "name": "count set bits in word",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b011000000010", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0011011", "size": 7 } ],
  "extensions": [ "Zbb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  var result : nat = 0;\n  foreach (i from 0 to 31)\n    if rs1_val[i] == bitone then result = result + 1;\n  X(rd) = to_bits(sizeof(xlen), result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "csrrc",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "csr", "type": "csreg", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,csr,rs1",
  "format": "TBD",
  "fields": [ { "field": "csr", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_imm)", "size": 1 }, { "field": "encdec_csrop(op)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b1110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val : xlenbits = if is_imm then zero_extend(rs1) else X(rs1);\n  let isWrite : bool = match op {\n    CSRRW  => true,\n    _      => if is_imm then unsigned(rs1_val) != 0 else unsigned(rs1) != 0\n  };\n  if not(check_CSR(csr, cur_privilege, isWrite))\n  then { handle_illegal(); RETIRE_FAIL }\n  else if not(ext_check_CSR(csr, cur_privilege, isWrite))\n  then { ext_check_CSR_fail(); RETIRE_FAIL }\n  else {\n    let csr_val = readCSR(csr); /* could have side-effects, so technically shouldn't perform for CSRW[I] with rd == 0 */\n    if isWrite then {\n      let new_val : xlenbits = match op {\n        CSRRW => rs1_val,\n        CSRRS => csr_val | rs1_val,\n        CSRRC => csr_val & ~(rs1_val)\n      };\n      writeCSR(csr, new_val)\n    };\n    X(rd) = csr_val;\n    RETIRE_SUCCESS\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "csrrci",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "csr", "type": "csreg", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,csr,rs1",
  "format": "TBD",
  "fields": [ { "field": "csr", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_imm)", "size": 1 }, { "field": "encdec_csrop(op)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b1110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val : xlenbits = if is_imm then zero_extend(rs1) else X(rs1);\n  let isWrite : bool = match op {\n    CSRRW  => true,\n    _      => if is_imm then unsigned(rs1_val) != 0 else unsigned(rs1) != 0\n  };\n  if not(check_CSR(csr, cur_privilege, isWrite))\n  then { handle_illegal(); RETIRE_FAIL }\n  else if not(ext_check_CSR(csr, cur_privilege, isWrite))\n  then { ext_check_CSR_fail(); RETIRE_FAIL }\n  else {\n    let csr_val = readCSR(csr); /* could have side-effects, so technically shouldn't perform for CSRW[I] with rd == 0 */\n    if isWrite then {\n      let new_val : xlenbits = match op {\n        CSRRW => rs1_val,\n        CSRRS => csr_val | rs1_val,\n        CSRRC => csr_val & ~(rs1_val)\n      };\n      writeCSR(csr, new_val)\n    };\n    X(rd) = csr_val;\n    RETIRE_SUCCESS\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "csrrs",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "csr", "type": "csreg", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,csr,rs1",
  "format": "TBD",
  "fields": [ { "field": "csr", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_imm)", "size": 1 }, { "field": "encdec_csrop(op)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b1110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val : xlenbits = if is_imm then zero_extend(rs1) else X(rs1);\n  let isWrite : bool = match op {\n    CSRRW  => true,\n    _      => if is_imm then unsigned(rs1_val) != 0 else unsigned(rs1) != 0\n  };\n  if not(check_CSR(csr, cur_privilege, isWrite))\n  then { handle_illegal(); RETIRE_FAIL }\n  else if not(ext_check_CSR(csr, cur_privilege, isWrite))\n  then { ext_check_CSR_fail(); RETIRE_FAIL }\n  else {\n    let csr_val = readCSR(csr); /* could have side-effects, so technically shouldn't perform for CSRW[I] with rd == 0 */\n    if isWrite then {\n      let new_val : xlenbits = match op {\n        CSRRW => rs1_val,\n        CSRRS => csr_val | rs1_val,\n        CSRRC => csr_val & ~(rs1_val)\n      };\n      writeCSR(csr, new_val)\n    };\n    X(rd) = csr_val;\n    RETIRE_SUCCESS\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "csrrsi",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "csr", "type": "csreg", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,csr,rs1",
  "format": "TBD",
  "fields": [ { "field": "csr", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_imm)", "size": 1 }, { "field": "encdec_csrop(op)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b1110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val : xlenbits = if is_imm then zero_extend(rs1) else X(rs1);\n  let isWrite : bool = match op {\n    CSRRW  => true,\n    _      => if is_imm then unsigned(rs1_val) != 0 else unsigned(rs1) != 0\n  };\n  if not(check_CSR(csr, cur_privilege, isWrite))\n  then { handle_illegal(); RETIRE_FAIL }\n  else if not(ext_check_CSR(csr, cur_privilege, isWrite))\n  then { ext_check_CSR_fail(); RETIRE_FAIL }\n  else {\n    let csr_val = readCSR(csr); /* could have side-effects, so technically shouldn't perform for CSRW[I] with rd == 0 */\n    if isWrite then {\n      let new_val : xlenbits = match op {\n        CSRRW => rs1_val,\n        CSRRS => csr_val | rs1_val,\n        CSRRC => csr_val & ~(rs1_val)\n      };\n      writeCSR(csr, new_val)\n    };\n    X(rd) = csr_val;\n    RETIRE_SUCCESS\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "csrrw",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "csr", "type": "csreg", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,csr,rs1",
  "format": "TBD",
  "fields": [ { "field": "csr", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_imm)", "size": 1 }, { "field": "encdec_csrop(op)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b1110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val : xlenbits = if is_imm then zero_extend(rs1) else X(rs1);\n  let isWrite : bool = match op {\n    CSRRW  => true,\n    _      => if is_imm then unsigned(rs1_val) != 0 else unsigned(rs1) != 0\n  };\n  if not(check_CSR(csr, cur_privilege, isWrite))\n  then { handle_illegal(); RETIRE_FAIL }\n  else if not(ext_check_CSR(csr, cur_privilege, isWrite))\n  then { ext_check_CSR_fail(); RETIRE_FAIL }\n  else {\n    let csr_val = readCSR(csr); /* could have side-effects, so technically shouldn't perform for CSRW[I] with rd == 0 */\n    if isWrite then {\n      let new_val : xlenbits = match op {\n        CSRRW => rs1_val,\n        CSRRS => csr_val | rs1_val,\n        CSRRC => csr_val & ~(rs1_val)\n      };\n      writeCSR(csr, new_val)\n    };\n    X(rd) = csr_val;\n    RETIRE_SUCCESS\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "csrrwi",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "csr", "type": "csreg", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,csr,rs1",
  "format": "TBD",
  "fields": [ { "field": "csr", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_imm)", "size": 1 }, { "field": "encdec_csrop(op)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b1110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val : xlenbits = if is_imm then zero_extend(rs1) else X(rs1);\n  let isWrite : bool = match op {\n    CSRRW  => true,\n    _      => if is_imm then unsigned(rs1_val) != 0 else unsigned(rs1) != 0\n  };\n  if not(check_CSR(csr, cur_privilege, isWrite))\n  then { handle_illegal(); RETIRE_FAIL }\n  else if not(ext_check_CSR(csr, cur_privilege, isWrite))\n  then { ext_check_CSR_fail(); RETIRE_FAIL }\n  else {\n    let csr_val = readCSR(csr); /* could have side-effects, so technically shouldn't perform for CSRW[I] with rd == 0 */\n    if isWrite then {\n      let new_val : xlenbits = match op {\n        CSRRW => rs1_val,\n        CSRRS => csr_val | rs1_val,\n        CSRRC => csr_val & ~(rs1_val)\n      };\n      writeCSR(csr, new_val)\n    };\n    X(rd) = csr_val;\n    RETIRE_SUCCESS\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "ctz",
  "name": "count trailing zero bits",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b011000000001", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zbb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  var result : nat = 0;\n  var done : bool = false;\n  foreach (i from 0 to (sizeof(xlen) - 1))\n    if not(done) then if rs1_val[i] == bitzero\n                    then result = result + 1\n                    else done = true;\n  X(rd) = to_bits(sizeof(xlen), result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "ctzw",
  "name": "count trailing zero bits in word",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b011000000001", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0011011", "size": 7 } ],
  "extensions": [ "Zbb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  var result : nat = 0;\n  var done : bool = false;\n  foreach (i from 0 to 31)\n    if not(done) then if rs1_val[i] == bitzero\n                    then result = result + 1\n                    else done = true;\n  X(rd) = to_bits(sizeof(xlen), result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "czero.eqz",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000111", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b111", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zicond" ],
  "function": "{\n  let value = X(rs1);\n  let condition = X(rs2);\n  let result : xlenbits = if (condition != zeros()) then zeros()\n\t\t\t\t\t\t    else value;\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "czero.nez",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000111", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b111", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zicond" ],
  "function": "{\n  let value = X(rs1);\n  let condition = X(rs2);\n  let result : xlenbits = if (condition != zeros()) then zeros()\n\t\t\t\t\t\t    else value;\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "div",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b10", "size": 2 }, { "field": "bool_not_bits(s)", "size": 1 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "M" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val);\n  let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val);\n  let q : int = if rs2_int == 0 then -1 else quot_round_zero(rs1_int, rs2_int);\n  /* check for signed overflow */\n  let q': int = if s & q > xlen_max_signed then xlen_min_signed else q;\n  X(rd) = to_bits(sizeof(xlen), q');\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "divu",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b10", "size": 2 }, { "field": "bool_not_bits(s)", "size": 1 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "M" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val);\n  let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val);\n  let q : int = if rs2_int == 0 then -1 else quot_round_zero(rs1_int, rs2_int);\n  /* check for signed overflow */\n  let q': int = if s & q > xlen_max_signed then xlen_min_signed else q;\n  X(rd) = to_bits(sizeof(xlen), q');\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "divuw",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b10", "size": 2 }, { "field": "bool_not_bits(s)", "size": 1 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [ "M" ],
  "function": "{\n  let rs1_val = X(rs1)[31..0];\n  let rs2_val = X(rs2)[31..0];\n  let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val);\n  let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val);\n  let q : int = if rs2_int == 0 then -1 else quot_round_zero(rs1_int, rs2_int);\n  /* check for signed overflow */\n  let q': int = if s & q > (2 ^ 31 - 1) then  (0 - (2 ^ 31)) else q;\n  X(rd) = sign_extend(to_bits(32, q'));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "divw",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b10", "size": 2 }, { "field": "bool_not_bits(s)", "size": 1 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [ "M" ],
  "function": "{\n  let rs1_val = X(rs1)[31..0];\n  let rs2_val = X(rs2)[31..0];\n  let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val);\n  let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val);\n  let q : int = if rs2_int == 0 then -1 else quot_round_zero(rs1_int, rs2_int);\n  /* check for signed overflow */\n  let q': int = if s & q > (2 ^ 31 - 1) then  (0 - (2 ^ 31)) else q;\n  X(rd) = sign_extend(to_bits(32, q'));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "ebreak",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "0b000000000001", "size": 12 }, { "field": "0b00000", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b1110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  handle_mem_exception(PC, E_Breakpoint());\n  RETIRE_FAIL\n}",
  "description": "TBD"
},
{
  "mnemonic": "ecall",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "0b000000000000", "size": 12 }, { "field": "0b00000", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b1110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let t : sync_exception =\n    struct { trap = match (cur_privilege) {\n                      User       => E_U_EnvCall(),\n                      Supervisor => E_S_EnvCall(),\n                      Machine    => E_M_EnvCall()\n                    },\n             excinfo = (None() : option(xlenbits)),\n             ext     = None() };\n  set_next_pc(exception_handler(cur_privilege, CTL_TRAP(t), PC));\n  RETIRE_FAIL\n}",
  "description": "TBD"
},
{
  "mnemonic": "fadd.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0001101", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_64b = F_or_X_D(rs1);\n  let rs2_val_64b = F_or_X_D(rs2);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op {\n        FADD_D  => riscv_f64Add (rm_3b, rs1_val_64b, rs2_val_64b),\n        FSUB_D  => riscv_f64Sub (rm_3b, rs1_val_64b, rs2_val_64b),\n        FMUL_D  => riscv_f64Mul (rm_3b, rs1_val_64b, rs2_val_64b),\n        FDIV_D  => riscv_f64Div (rm_3b, rs1_val_64b, rs2_val_64b)\n      };\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_64b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fadd.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0001110", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_16b = F_or_X_H(rs1);\n  let rs2_val_16b = F_or_X_H(rs2);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op {\n        FADD_H  => riscv_f16Add (rm_3b, rs1_val_16b, rs2_val_16b),\n        FSUB_H  => riscv_f16Sub (rm_3b, rs1_val_16b, rs2_val_16b),\n        FMUL_H  => riscv_f16Mul (rm_3b, rs1_val_16b, rs2_val_16b),\n        FDIV_H  => riscv_f16Div (rm_3b, rs1_val_16b, rs2_val_16b)\n      };\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_16b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fadd.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0001100", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_32b = F_or_X_S(rs1);\n  let rs2_val_32b = F_or_X_S(rs2);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op {\n        FADD_S  => riscv_f32Add (rm_3b, rs1_val_32b, rs2_val_32b),\n        FSUB_S  => riscv_f32Sub (rm_3b, rs1_val_32b, rs2_val_32b),\n        FMUL_S  => riscv_f32Mul (rm_3b, rs1_val_32b, rs2_val_32b),\n        FDIV_S  => riscv_f32Div (rm_3b, rs1_val_32b, rs2_val_32b)\n      };\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_32b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fclass.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b1111001", "size": 7 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "D" ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_X            = X(rs1);\n  let rd_val_D             = rs1_val_X [63..0];\n  F(rd) = rd_val_D;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fclass.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b1111010", "size": 7 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfh" ],
  "function": "{\n  let rs1_val_X            = X(rs1);\n  let rd_val_H             = rs1_val_X [15..0];\n  F(rd) = nan_box (rd_val_H);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fclass.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b1111000", "size": 7 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "F" ],
  "function": "{\n  let rs1_val_X            = X(rs1);\n  let rd_val_S             = rs1_val_X [31..0];\n  F(rd) = nan_box (rd_val_S);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.d.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101010", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_H;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.d.l",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101001", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_D;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.d.lu",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101001", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_D;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.d.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101001", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_D;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.d.w",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101001", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_D;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.d.wu",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101001", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_D;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.h.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101010", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_H;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.h.l",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101010", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_H;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.h.lu",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101010", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_H;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.h.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101010", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_H;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.h.w",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101010", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_H;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.h.wu",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101010", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_H;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.l.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101001", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_D;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.l.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101010", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_H;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.l.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101000", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_S;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.lu.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101001", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_D;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.lu.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101010", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_H;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.lu.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101000", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_S;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.s.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101001", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_D;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.s.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101010", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_H;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.s.l",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101000", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_S;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.s.lu",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101000", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_S;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.s.w",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101000", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_S;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.s.wu",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101000", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_S;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.w.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101001", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_D;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.w.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101010", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_H;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.w.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101000", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_S;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.wu.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101001", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_D;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.wu.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101010", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_H;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvt.wu.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101000", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_S;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fcvtmod.w.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b1100001", "size": 7 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "D","Zfa" ],
  "function": "{\n  let rs1_val_D = F_D(rs1);\n  let (fflags, rd_val) = fcvtmod_helper(rs1_val_D);\n  accrue_fflags(fflags);\n  X(rd) = sign_extend(rd_val);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fdiv.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0001101", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_64b = F_or_X_D(rs1);\n  let rs2_val_64b = F_or_X_D(rs2);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op {\n        FADD_D  => riscv_f64Add (rm_3b, rs1_val_64b, rs2_val_64b),\n        FSUB_D  => riscv_f64Sub (rm_3b, rs1_val_64b, rs2_val_64b),\n        FMUL_D  => riscv_f64Mul (rm_3b, rs1_val_64b, rs2_val_64b),\n        FDIV_D  => riscv_f64Div (rm_3b, rs1_val_64b, rs2_val_64b)\n      };\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_64b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fdiv.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0001110", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_16b = F_or_X_H(rs1);\n  let rs2_val_16b = F_or_X_H(rs2);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op {\n        FADD_H  => riscv_f16Add (rm_3b, rs1_val_16b, rs2_val_16b),\n        FSUB_H  => riscv_f16Sub (rm_3b, rs1_val_16b, rs2_val_16b),\n        FMUL_H  => riscv_f16Mul (rm_3b, rs1_val_16b, rs2_val_16b),\n        FDIV_H  => riscv_f16Div (rm_3b, rs1_val_16b, rs2_val_16b)\n      };\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_16b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fdiv.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0001100", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_32b = F_or_X_S(rs1);\n  let rs2_val_32b = F_or_X_S(rs2);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op {\n        FADD_S  => riscv_f32Add (rm_3b, rs1_val_32b, rs2_val_32b),\n        FSUB_S  => riscv_f32Sub (rm_3b, rs1_val_32b, rs2_val_32b),\n        FMUL_S  => riscv_f32Mul (rm_3b, rs1_val_32b, rs2_val_32b),\n        FDIV_S  => riscv_f32Div (rm_3b, rs1_val_32b, rs2_val_32b)\n      };\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_32b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fence",
  "name": "fence (memory)",
  "operands": [ { "name": "pred", "type": "bits(4)", "optional": false },{ "name": "succ", "type": "bits(4)", "optional": false } ],
  "syntax": "pred,succ",
  "format": "I",
  "fields": [ { "field": "0b0000", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "0b00000", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  // If the FIOM bit in menvcfg/senvcfg is set then the I/O bits can imply R/W.\n  let fiom = is_fiom_active();\n  let pred = effective_fence_set(pred, fiom);\n  let succ = effective_fence_set(succ, fiom);\n\n  match (pred, succ) {\n    (_ : bits(2) @ 0b11, _ : bits(2) @ 0b11) => sail_barrier(Barrier_RISCV_rw_rw),\n    (_ : bits(2) @ 0b10, _ : bits(2) @ 0b11) => sail_barrier(Barrier_RISCV_r_rw),\n    (_ : bits(2) @ 0b10, _ : bits(2) @ 0b10) => sail_barrier(Barrier_RISCV_r_r),\n    (_ : bits(2) @ 0b11, _ : bits(2) @ 0b01) => sail_barrier(Barrier_RISCV_rw_w),\n    (_ : bits(2) @ 0b01, _ : bits(2) @ 0b01) => sail_barrier(Barrier_RISCV_w_w),\n    (_ : bits(2) @ 0b01, _ : bits(2) @ 0b11) => sail_barrier(Barrier_RISCV_w_rw),\n    (_ : bits(2) @ 0b11, _ : bits(2) @ 0b10) => sail_barrier(Barrier_RISCV_rw_r),\n    (_ : bits(2) @ 0b10, _ : bits(2) @ 0b01) => sail_barrier(Barrier_RISCV_r_w),\n    (_ : bits(2) @ 0b01, _ : bits(2) @ 0b10) => sail_barrier(Barrier_RISCV_w_r),\n\n    (_ : bits(4)       , _ : bits(2) @ 0b00) => (),\n    (_ : bits(2) @ 0b00, _ : bits(4)       ) => (),\n\n    _ => { print(\"FIXME: unsupported fence\");\n           () }\n  };\n  RETIRE_SUCCESS\n}",
  "description": "\nThe FENCE instruction is used to provide memory ordering guarantees.\nIt specifies ordering constraints on memory operations that precede\nand follow it in program order. The FENCE instruction includes two\n4-bit fields, 'pred' and 'succ', which represent the memory ordering\nrequirements before and after the FENCE instruction, respectively.\n\nThe bits in 'pred' and 'succ' represent the following ordering constraints:\n- 'i': instruction stream order\n- 'o': outstanding loads\n- 'r': read operations\n- 'w': write operations\n\nThe FENCE instruction is used to control the visibility of memory\noperations, and its behavior is influenced by the 'pred' and 'succ'\nfields. The precise semantics of the FENCE instruction depend on the\nspecific bits set in these fields.\n "
},
{
  "mnemonic": "fence.i",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "0b000000000000", "size": 12 }, { "field": "0b00000", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "{ /* __barrier(Barrier_RISCV_i); */ RETIRE_SUCCESS }",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a0.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a1.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a2.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a3.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a4.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a5.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a6.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.a7.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.fp.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.gp.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.ra.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s1.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s10.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s11.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s2.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s3.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s4.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s5.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s6.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s7.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s8.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.s9.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.sp.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t0.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t1.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t2.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t3.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t4.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t5.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.t6.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.tp.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.i.reserved.zero.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 0 }, { "field": "rs", "size": 3 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a0.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a1.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a2.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a3.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a4.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a5.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a6.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).a7.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).fp.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).gp.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).ra.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s1.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s10.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s11.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s2.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s3.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s4.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s5.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s6.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s7.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s8.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).s9.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).sp.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t0.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t1.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t2.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t3.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t4.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t5.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).t6.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).tp.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.a0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.a1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.a2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.a3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.a4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.a5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.a6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.a7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.fp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.gp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.ra.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.s1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.s10.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.s11.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.s2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.s3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.s4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.s5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.s6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.s7.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.s8.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.s9.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.sp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.t0.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.t1.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.t2.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.t3.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.t4.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.t5.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.t6.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.tp.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.reserved.bit_maybe_i(i).bit_maybe_i(i).zero.zero.s",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "fm", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "rs", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 3 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "RETIRE_SUCCESS",
  "description": "TBD"
},
{
  "mnemonic": "fence.tso",
  "name": "fence (total store order)",
  "operands": [ { "name": "pred", "type": "bits(4)", "optional": false },{ "name": "succ", "type": "bits(4)", "optional": false } ],
  "syntax": "pred,succ",
  "format": "I",
  "fields": [ { "field": "0b1000", "size": 4 }, { "field": "pred", "size": 4 }, { "field": "succ", "size": 4 }, { "field": "0b00000", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b0001111", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  match (pred, succ) {\n    (_ : bits(2) @ 0b11, _ : bits(2) @ 0b11) => sail_barrier(Barrier_RISCV_tso),\n    (_ : bits(2) @ 0b00, _ : bits(2) @ 0b00) => (),\n\n    _ => { print(\"FIXME: unsupported fence\");\n           () }\n  };\n  RETIRE_SUCCESS\n}",
  "description": "\nThe FENCE_TSO instruction is a memory\nordering instruction that provides a stronger memory consistency model\ncompared to the standard FENCE instruction. It ensures that all memory\noperations preceding and following the FENCE_TSO instruction are globally\nordered. The FENCE_TSO instruction includes two 4-bit fields, 'pred' and\n'succ', which represent the memory ordering requirements before and after\nthe FENCE_TSO instruction, respectively.\n "
},
{
  "mnemonic": "feq.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_D = F_or_X_D(rs1);\n  let rs2_val_D = F_or_X_D(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f64Le (rs1_val_D, rs2_val_D);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "feq.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010010", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_H = F_or_X_H(rs1);\n  let rs2_val_H = F_or_X_H(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f16Le (rs1_val_H, rs2_val_H);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "feq.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_S = F_or_X_S(rs1);\n  let rs2_val_S = F_or_X_S(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f32Le (rs1_val_S, rs2_val_S);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "flb",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "D" ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), size_bytes(width)) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let (aq, rl, res) = (false, false, false);\n          match (width) {\n            BYTE => { handle_illegal(); RETIRE_FAIL },\n            HALF =>\n               process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)),\n            WORD =>\n               process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)),\n            DOUBLE if sizeof(flen) >= 64 =>\n               process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)),\n            _ => report_invalid_width(__FILE__, __LINE__, width, \"floating point load\"),\n          }\n        }\n      }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fld",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "D" ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), size_bytes(width)) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let (aq, rl, res) = (false, false, false);\n          match (width) {\n            BYTE => { handle_illegal(); RETIRE_FAIL },\n            HALF =>\n               process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)),\n            WORD =>\n               process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)),\n            DOUBLE if sizeof(flen) >= 64 =>\n               process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)),\n            _ => report_invalid_width(__FILE__, __LINE__, width, \"floating point load\"),\n          }\n        }\n      }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fle.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_D = F_or_X_D(rs1);\n  let rs2_val_D = F_or_X_D(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f64Le (rs1_val_D, rs2_val_D);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fle.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010010", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_H = F_or_X_H(rs1);\n  let rs2_val_H = F_or_X_H(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f16Le (rs1_val_H, rs2_val_H);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fle.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_S = F_or_X_S(rs1);\n  let rs2_val_S = F_or_X_S(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f32Le (rs1_val_S, rs2_val_S);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fleq.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "D","Zfa" ],
  "function": "{\n  let rs1_val_D = F_D(rs1);\n  let rs2_val_D = F_D(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f64Le_quiet   (rs1_val_D, rs2_val_D);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fleq.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010010", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfh","Zfa" ],
  "function": "{\n  let rs1_val_H = F_H(rs1);\n  let rs2_val_H = F_H(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f16Le_quiet   (rs1_val_H, rs2_val_H);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fleq.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfa" ],
  "function": "{\n  let rs1_val_S = F_S(rs1);\n  let rs2_val_S = F_S(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f32Le_quiet   (rs1_val_S, rs2_val_S);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "flh",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "D" ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), size_bytes(width)) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let (aq, rl, res) = (false, false, false);\n          match (width) {\n            BYTE => { handle_illegal(); RETIRE_FAIL },\n            HALF =>\n               process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)),\n            WORD =>\n               process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)),\n            DOUBLE if sizeof(flen) >= 64 =>\n               process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)),\n            _ => report_invalid_width(__FILE__, __LINE__, width, \"floating point load\"),\n          }\n        }\n      }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fli.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "constantidx", "type": "bits(5)", "optional": false } ],
  "syntax": "rd,constantidx",
  "format": "TBD",
  "fields": [ { "field": "0b1111001", "size": 7 }, { "field": "0b00001", "size": 5 }, { "field": "rs1", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "D","Zfa" ],
  "function": "{\n  let bits : bits(64) = match constantidx {\n    0b00000 => { 0xbff0000000000000 },  /* -1.0 */\n    0b00001 => { 0x0010000000000000 },  /* minimum positive normal */\n    0b00010 => { 0x3Ef0000000000000 },  /* 1.0 * 2^-16 */\n    0b00011 => { 0x3f00000000000000 },  /* 1.0 * 2^-15 */\n    0b00100 => { 0x3f70000000000000 },  /* 1.0 * 2^-8  */\n    0b00101 => { 0x3f80000000000000 },  /* 1.0 * 2^-7  */\n    0b00110 => { 0x3fb0000000000000 },  /* 1.0 * 2^-4  */\n    0b00111 => { 0x3fc0000000000000 },  /* 1.0 * 2^-3  */\n    0b01000 => { 0x3fd0000000000000 },  /* 0.25 */\n    0b01001 => { 0x3fd4000000000000 },  /* 0.3125 */\n    0b01010 => { 0x3fd8000000000000 },  /* 0.375 */\n    0b01011 => { 0x3fdc000000000000 },  /* 0.4375 */\n    0b01100 => { 0x3fe0000000000000 },  /* 0.5 */\n    0b01101 => { 0x3fe4000000000000 },  /* 0.625 */\n    0b01110 => { 0x3fe8000000000000 },  /* 0.75 */\n    0b01111 => { 0x3fec000000000000 },  /* 0.875 */\n    0b10000 => { 0x3ff0000000000000 },  /* 1.0 */\n    0b10001 => { 0x3ff4000000000000 },  /* 1.25 */\n    0b10010 => { 0x3ff8000000000000 },  /* 1.5 */\n    0b10011 => { 0x3ffc000000000000 },  /* 1.75 */\n    0b10100 => { 0x4000000000000000 },  /* 2.0 */\n    0b10101 => { 0x4004000000000000 },  /* 2.5 */\n    0b10110 => { 0x4008000000000000 },  /* 3 */\n    0b10111 => { 0x4010000000000000 },  /* 4 */\n    0b11000 => { 0x4020000000000000 },  /* 8 */\n    0b11001 => { 0x4030000000000000 },  /* 16 */\n    0b11010 => { 0x4060000000000000 },  /* 2^7 */\n    0b11011 => { 0x4070000000000000 },  /* 2^8 */\n    0b11100 => { 0x40e0000000000000 },  /* 2^15 */\n    0b11101 => { 0x40f0000000000000 },  /* 2^16 */\n    0b11110 => { 0x7ff0000000000000 },  /* +inf */\n    0b11111 => { canonical_NaN_D() },\n  };\n  F_D(rd) = bits;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fli.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "constantidx", "type": "bits(5)", "optional": false } ],
  "syntax": "rd,constantidx",
  "format": "TBD",
  "fields": [ { "field": "0b1111010", "size": 7 }, { "field": "0b00001", "size": 5 }, { "field": "rs1", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfh","Zfa" ],
  "function": "{\n  let bits : bits(16) = match constantidx {\n    0b00000 => { 0xbc00 },  /* -1.0 */\n    0b00001 => { 0x0400 },  /* minimum positive normal */\n    0b00010 => { 0x0100 },  /* 1.0 * 2^-16 */\n    0b00011 => { 0x0200 },  /* 1.0 * 2^-15 */\n    0b00100 => { 0x1c00 },  /* 1.0 * 2^-8  */\n    0b00101 => { 0x2000 },  /* 1.0 * 2^-7  */\n    0b00110 => { 0x2c00 },  /* 1.0 * 2^-4  */\n    0b00111 => { 0x3000 },  /* 1.0 * 2^-3  */\n    0b01000 => { 0x3400 },  /* 0.25 */\n    0b01001 => { 0x3500 },  /* 0.3125 */\n    0b01010 => { 0x3600 },  /* 0.375 */\n    0b01011 => { 0x3700 },  /* 0.4375 */\n    0b01100 => { 0x3800 },  /* 0.5 */\n    0b01101 => { 0x3900 },  /* 0.625 */\n    0b01110 => { 0x3a00 },  /* 0.75 */\n    0b01111 => { 0x3b00 },  /* 0.875 */\n    0b10000 => { 0x3c00 },  /* 1.0 */\n    0b10001 => { 0x3d00 },  /* 1.25 */\n    0b10010 => { 0x3e00 },  /* 1.5 */\n    0b10011 => { 0x3f00 },  /* 1.75 */\n    0b10100 => { 0x4000 },  /* 2.0 */\n    0b10101 => { 0x4100 },  /* 2.5 */\n    0b10110 => { 0x4200 },  /* 3 */\n    0b10111 => { 0x4400 },  /* 4 */\n    0b11000 => { 0x4800 },  /* 8 */\n    0b11001 => { 0x4c00 },  /* 16 */\n    0b11010 => { 0x5800 },  /* 2^7 */\n    0b11011 => { 0x5c00 },  /* 2^8 */\n    0b11100 => { 0x7800 },  /* 2^15 */\n    0b11101 => { 0x7c00 },  /* 2^16 */\n    0b11110 => { 0x7c00 },  /* +inf */\n    0b11111 => { canonical_NaN_H() },\n  };\n  F_H(rd) = bits;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fli.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "constantidx", "type": "bits(5)", "optional": false } ],
  "syntax": "rd,constantidx",
  "format": "TBD",
  "fields": [ { "field": "0b1111000", "size": 7 }, { "field": "0b00001", "size": 5 }, { "field": "rs1", "size": 3 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfa" ],
  "function": "{\n  let bits : bits(32) = match constantidx {\n    0b00000 => { 0xbf800000 },  /* -1.0 */\n    0b00001 => { 0x00800000 },  /* minimum positive normal */\n    0b00010 => { 0x37800000 },  /* 1.0 * 2^-16 */\n    0b00011 => { 0x38000000 },  /* 1.0 * 2^-15 */\n    0b00100 => { 0x3b800000 },  /* 1.0 * 2^-8  */\n    0b00101 => { 0x3c000000 },  /* 1.0 * 2^-7  */\n    0b00110 => { 0x3d800000 },  /* 1.0 * 2^-4  */\n    0b00111 => { 0x3e000000 },  /* 1.0 * 2^-3  */\n    0b01000 => { 0x3e800000 },  /* 0.25 */\n    0b01001 => { 0x3ea00000 },  /* 0.3125 */\n    0b01010 => { 0x3ec00000 },  /* 0.375 */\n    0b01011 => { 0x3ee00000 },  /* 0.4375 */\n    0b01100 => { 0x3f000000 },  /* 0.5 */\n    0b01101 => { 0x3f200000 },  /* 0.625 */\n    0b01110 => { 0x3f400000 },  /* 0.75 */\n    0b01111 => { 0x3f600000 },  /* 0.875 */\n    0b10000 => { 0x3f800000 },  /* 1.0 */\n    0b10001 => { 0x3fa00000 },  /* 1.25 */\n    0b10010 => { 0x3fc00000 },  /* 1.5 */\n    0b10011 => { 0x3fe00000 },  /* 1.75 */\n    0b10100 => { 0x40000000 },  /* 2.0 */\n    0b10101 => { 0x40200000 },  /* 2.5 */\n    0b10110 => { 0x40400000 },  /* 3 */\n    0b10111 => { 0x40800000 },  /* 4 */\n    0b11000 => { 0x41000000 },  /* 8 */\n    0b11001 => { 0x41800000 },  /* 16 */\n    0b11010 => { 0x43000000 },  /* 2^7 */\n    0b11011 => { 0x43800000 },  /* 2^8 */\n    0b11100 => { 0x47000000 },  /* 2^15 */\n    0b11101 => { 0x47800000 },  /* 2^16 */\n    0b11110 => { 0x7f800000 },  /* +inf */\n    0b11111 => { canonical_NaN_S() },\n  };\n  F_S(rd) = bits;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "flt.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_D = F_or_X_D(rs1);\n  let rs2_val_D = F_or_X_D(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f64Le (rs1_val_D, rs2_val_D);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "flt.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010010", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_H = F_or_X_H(rs1);\n  let rs2_val_H = F_or_X_H(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f16Le (rs1_val_H, rs2_val_H);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "flt.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_S = F_or_X_S(rs1);\n  let rs2_val_S = F_or_X_S(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f32Le (rs1_val_S, rs2_val_S);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fltq.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "D","Zfa" ],
  "function": "{\n  let rs1_val_D = F_D(rs1);\n  let rs2_val_D = F_D(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f64Lt_quiet   (rs1_val_D, rs2_val_D);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fltq.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010010", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfh","Zfa" ],
  "function": "{\n  let rs1_val_H = F_H(rs1);\n  let rs2_val_H = F_H(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f16Lt_quiet   (rs1_val_H, rs2_val_H);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fltq.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfa" ],
  "function": "{\n  let rs1_val_S = F_S(rs1);\n  let rs2_val_S = F_S(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f32Lt_quiet   (rs1_val_S, rs2_val_S);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "flw",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "D" ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), size_bytes(width)) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let (aq, rl, res) = (false, false, false);\n          match (width) {\n            BYTE => { handle_illegal(); RETIRE_FAIL },\n            HALF =>\n               process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)),\n            WORD =>\n               process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)),\n            DOUBLE if sizeof(flen) >= 64 =>\n               process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)),\n            _ => report_invalid_width(__FILE__, __LINE__, width, \"floating point load\"),\n          }\n        }\n      }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmadd.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs3", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rs3,rm",
  "format": "TBD",
  "fields": [ { "field": "rs3", "size": 5 }, { "field": "0b01", "size": 2 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1001111", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_64b = F_or_X_D(rs1);\n  let rs2_val_64b = F_or_X_D(rs2);\n  let rs3_val_64b = F_or_X_D(rs3);\n\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_64b) : (bits(5), bits(64)) =\n        match op {\n          FMADD_D  => riscv_f64MulAdd (rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b),\n          FMSUB_D  => riscv_f64MulAdd (rm_3b, rs1_val_64b, rs2_val_64b, negate_D (rs3_val_64b)),\n          FNMSUB_D => riscv_f64MulAdd (rm_3b, negate_D (rs1_val_64b), rs2_val_64b, rs3_val_64b),\n          FNMADD_D => riscv_f64MulAdd (rm_3b, negate_D (rs1_val_64b), rs2_val_64b, negate_D (rs3_val_64b))\n        };\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_64b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmadd.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs3", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rs3,rm",
  "format": "TBD",
  "fields": [ { "field": "rs3", "size": 5 }, { "field": "0b10", "size": 2 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1001111", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_16b = F_or_X_H(rs1);\n  let rs2_val_16b = F_or_X_H(rs2);\n  let rs3_val_16b = F_or_X_H(rs3);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_16b) : (bits(5), bits(16)) =\n        match op {\n          FMADD_H  => riscv_f16MulAdd (rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b),\n          FMSUB_H  => riscv_f16MulAdd (rm_3b, rs1_val_16b, rs2_val_16b, negate_H (rs3_val_16b)),\n          FNMSUB_H => riscv_f16MulAdd (rm_3b, negate_H (rs1_val_16b), rs2_val_16b, rs3_val_16b),\n          FNMADD_H => riscv_f16MulAdd (rm_3b, negate_H (rs1_val_16b), rs2_val_16b, negate_H (rs3_val_16b))\n        };\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_16b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmadd.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs3", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rs3,rm",
  "format": "TBD",
  "fields": [ { "field": "rs3", "size": 5 }, { "field": "0b00", "size": 2 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1001111", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_32b = F_or_X_S(rs1);\n  let rs2_val_32b = F_or_X_S(rs2);\n  let rs3_val_32b = F_or_X_S(rs3);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_32b) : (bits(5), bits(32)) =\n        match op {\n          FMADD_S  => riscv_f32MulAdd (rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b),\n          FMSUB_S  => riscv_f32MulAdd (rm_3b, rs1_val_32b, rs2_val_32b, negate_S (rs3_val_32b)),\n          FNMSUB_S => riscv_f32MulAdd (rm_3b, negate_S (rs1_val_32b), rs2_val_32b, rs3_val_32b),\n          FNMADD_S => riscv_f32MulAdd (rm_3b, negate_S (rs1_val_32b), rs2_val_32b, negate_S (rs3_val_32b))\n        };\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_32b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmax.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_D = F_or_X_D(rs1);\n  let rs2_val_D = F_or_X_D(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f64Le (rs1_val_D, rs2_val_D);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmax.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010010", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_H = F_or_X_H(rs1);\n  let rs2_val_H = F_or_X_H(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f16Le (rs1_val_H, rs2_val_H);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmax.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_S = F_or_X_S(rs1);\n  let rs2_val_S = F_or_X_S(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f32Le (rs1_val_S, rs2_val_S);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmaxm.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010101", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "D","Zfa" ],
  "function": "{\n  let rs1_val_D = F_D(rs1);\n  let rs2_val_D = F_D(rs2);\n\n  let is_quiet  = true;\n  let (rs2_lt_rs1, fflags) = fle_D (rs2_val_D, rs1_val_D, is_quiet);\n\n  let rd_val_D  = if      (f_is_NaN_D(rs1_val_D) | f_is_NaN_D(rs2_val_D))           then canonical_NaN_D()\n                  else if (f_is_neg_zero_D(rs1_val_D) & f_is_pos_zero_D(rs2_val_D)) then rs2_val_D\n                  else if (f_is_neg_zero_D(rs2_val_D) & f_is_pos_zero_D(rs1_val_D)) then rs1_val_D\n                  else if rs2_lt_rs1                                                then rs1_val_D\n                  else                                                              rs2_val_D;\n\n  accrue_fflags(fflags);\n  F_D(rd) = rd_val_D;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmaxm.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010110", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfh","Zfa" ],
  "function": "{\n  let rs1_val_H = F_H(rs1);\n  let rs2_val_H = F_H(rs2);\n\n  let is_quiet  = true;\n  let (rs2_lt_rs1, fflags) = fle_H (rs2_val_H, rs1_val_H, is_quiet);\n\n  let rd_val_H =  if      (f_is_NaN_H(rs1_val_H) | f_is_NaN_H(rs2_val_H))           then canonical_NaN_H()\n                  else if (f_is_neg_zero_H(rs1_val_H) & f_is_pos_zero_H(rs2_val_H)) then rs2_val_H\n                  else if (f_is_neg_zero_H(rs2_val_H) & f_is_pos_zero_H(rs1_val_H)) then rs1_val_H\n                  else if rs2_lt_rs1                                                then rs1_val_H\n                  else /* (not rs2_lt_rs1) */                                            rs2_val_H;\n\n  accrue_fflags(fflags);\n  F_H(rd) = rd_val_H;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmaxm.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010100", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfa" ],
  "function": "{\n  let rs1_val_S = F_S(rs1);\n  let rs2_val_S = F_S(rs2);\n\n  let is_quiet  = true;\n  let (rs2_lt_rs1, fflags) = fle_S (rs2_val_S, rs1_val_S, is_quiet);\n\n  let rd_val_S  = if      (f_is_NaN_S(rs1_val_S) | f_is_NaN_S(rs2_val_S))           then canonical_NaN_S()\n                  else if (f_is_neg_zero_S(rs1_val_S) & f_is_pos_zero_S(rs2_val_S)) then rs2_val_S\n                  else if (f_is_neg_zero_S(rs2_val_S) & f_is_pos_zero_S(rs1_val_S)) then rs1_val_S\n                  else if rs2_lt_rs1                                                then rs1_val_S\n                  else /* (not rs2_lt_rs1) */                                            rs2_val_S;\n\n  accrue_fflags(fflags);\n  F_S(rd) = rd_val_S;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmin.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_D = F_or_X_D(rs1);\n  let rs2_val_D = F_or_X_D(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f64Le (rs1_val_D, rs2_val_D);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmin.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010010", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_H = F_or_X_H(rs1);\n  let rs2_val_H = F_or_X_H(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f16Le (rs1_val_H, rs2_val_H);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmin.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_S = F_or_X_S(rs1);\n  let rs2_val_S = F_or_X_S(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f32Le (rs1_val_S, rs2_val_S);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fminm.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010101", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "D","Zfa" ],
  "function": "{\n  let rs1_val_D = F_D(rs1);\n  let rs2_val_D = F_D(rs2);\n\n  let is_quiet  = true;\n  let (rs1_lt_rs2, fflags) = fle_D (rs1_val_D, rs2_val_D, is_quiet);\n\n  let rd_val_D  = if      (f_is_NaN_D(rs1_val_D) | f_is_NaN_D(rs2_val_D))           then canonical_NaN_D()\n                  else if (f_is_neg_zero_D(rs1_val_D) & f_is_pos_zero_D(rs2_val_D)) then rs1_val_D\n                  else if (f_is_neg_zero_D(rs2_val_D) & f_is_pos_zero_D(rs1_val_D)) then rs2_val_D\n                  else if rs1_lt_rs2                                                then rs1_val_D\n                  else                                                              rs2_val_D;\n\n  accrue_fflags(fflags);\n  F_D(rd) = rd_val_D;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fminm.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010110", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfh","Zfa" ],
  "function": "{\n  let rs1_val_H = F_H(rs1);\n  let rs2_val_H = F_H(rs2);\n\n  let is_quiet  = true;\n  let (rs1_lt_rs2, fflags) = fle_H (rs1_val_H, rs2_val_H, is_quiet);\n\n  let rd_val_H  = if      (f_is_NaN_H(rs1_val_H) | f_is_NaN_H(rs2_val_H))           then canonical_NaN_H()\n                  else if (f_is_neg_zero_H(rs1_val_H) & f_is_pos_zero_H(rs2_val_H)) then rs1_val_H\n                  else if (f_is_neg_zero_H(rs2_val_H) & f_is_pos_zero_H(rs1_val_H)) then rs2_val_H\n                  else if rs1_lt_rs2                                                then rs1_val_H\n                  else /* (not rs1_lt_rs2) */                                            rs2_val_H;\n\n  accrue_fflags(fflags);\n  F_H(rd) = rd_val_H;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fminm.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010100", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfa" ],
  "function": "{\n  let rs1_val_S = F_S(rs1);\n  let rs2_val_S = F_S(rs2);\n\n  let is_quiet  = true;\n  let (rs1_lt_rs2, fflags) = fle_S (rs1_val_S, rs2_val_S, is_quiet);\n\n  let rd_val_S  = if      (f_is_NaN_S(rs1_val_S) | f_is_NaN_S(rs2_val_S))           then canonical_NaN_S()\n                  else if (f_is_neg_zero_S(rs1_val_S) & f_is_pos_zero_S(rs2_val_S)) then rs1_val_S\n                  else if (f_is_neg_zero_S(rs2_val_S) & f_is_pos_zero_S(rs1_val_S)) then rs2_val_S\n                  else if rs1_lt_rs2                                                then rs1_val_S\n                  else /* (not rs1_lt_rs2) */                                            rs2_val_S;\n\n  accrue_fflags(fflags);\n  F_S(rd) = rd_val_S;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmsub.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs3", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rs3,rm",
  "format": "TBD",
  "fields": [ { "field": "rs3", "size": 5 }, { "field": "0b01", "size": 2 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1001111", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_64b = F_or_X_D(rs1);\n  let rs2_val_64b = F_or_X_D(rs2);\n  let rs3_val_64b = F_or_X_D(rs3);\n\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_64b) : (bits(5), bits(64)) =\n        match op {\n          FMADD_D  => riscv_f64MulAdd (rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b),\n          FMSUB_D  => riscv_f64MulAdd (rm_3b, rs1_val_64b, rs2_val_64b, negate_D (rs3_val_64b)),\n          FNMSUB_D => riscv_f64MulAdd (rm_3b, negate_D (rs1_val_64b), rs2_val_64b, rs3_val_64b),\n          FNMADD_D => riscv_f64MulAdd (rm_3b, negate_D (rs1_val_64b), rs2_val_64b, negate_D (rs3_val_64b))\n        };\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_64b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmsub.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs3", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rs3,rm",
  "format": "TBD",
  "fields": [ { "field": "rs3", "size": 5 }, { "field": "0b10", "size": 2 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1001111", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_16b = F_or_X_H(rs1);\n  let rs2_val_16b = F_or_X_H(rs2);\n  let rs3_val_16b = F_or_X_H(rs3);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_16b) : (bits(5), bits(16)) =\n        match op {\n          FMADD_H  => riscv_f16MulAdd (rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b),\n          FMSUB_H  => riscv_f16MulAdd (rm_3b, rs1_val_16b, rs2_val_16b, negate_H (rs3_val_16b)),\n          FNMSUB_H => riscv_f16MulAdd (rm_3b, negate_H (rs1_val_16b), rs2_val_16b, rs3_val_16b),\n          FNMADD_H => riscv_f16MulAdd (rm_3b, negate_H (rs1_val_16b), rs2_val_16b, negate_H (rs3_val_16b))\n        };\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_16b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmsub.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs3", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rs3,rm",
  "format": "TBD",
  "fields": [ { "field": "rs3", "size": 5 }, { "field": "0b00", "size": 2 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1001111", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_32b = F_or_X_S(rs1);\n  let rs2_val_32b = F_or_X_S(rs2);\n  let rs3_val_32b = F_or_X_S(rs3);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_32b) : (bits(5), bits(32)) =\n        match op {\n          FMADD_S  => riscv_f32MulAdd (rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b),\n          FMSUB_S  => riscv_f32MulAdd (rm_3b, rs1_val_32b, rs2_val_32b, negate_S (rs3_val_32b)),\n          FNMSUB_S => riscv_f32MulAdd (rm_3b, negate_S (rs1_val_32b), rs2_val_32b, rs3_val_32b),\n          FNMADD_S => riscv_f32MulAdd (rm_3b, negate_S (rs1_val_32b), rs2_val_32b, negate_S (rs3_val_32b))\n        };\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_32b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmul.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0001101", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_64b = F_or_X_D(rs1);\n  let rs2_val_64b = F_or_X_D(rs2);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op {\n        FADD_D  => riscv_f64Add (rm_3b, rs1_val_64b, rs2_val_64b),\n        FSUB_D  => riscv_f64Sub (rm_3b, rs1_val_64b, rs2_val_64b),\n        FMUL_D  => riscv_f64Mul (rm_3b, rs1_val_64b, rs2_val_64b),\n        FDIV_D  => riscv_f64Div (rm_3b, rs1_val_64b, rs2_val_64b)\n      };\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_64b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmul.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0001110", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_16b = F_or_X_H(rs1);\n  let rs2_val_16b = F_or_X_H(rs2);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op {\n        FADD_H  => riscv_f16Add (rm_3b, rs1_val_16b, rs2_val_16b),\n        FSUB_H  => riscv_f16Sub (rm_3b, rs1_val_16b, rs2_val_16b),\n        FMUL_H  => riscv_f16Mul (rm_3b, rs1_val_16b, rs2_val_16b),\n        FDIV_H  => riscv_f16Div (rm_3b, rs1_val_16b, rs2_val_16b)\n      };\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_16b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmul.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0001100", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_32b = F_or_X_S(rs1);\n  let rs2_val_32b = F_or_X_S(rs2);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op {\n        FADD_S  => riscv_f32Add (rm_3b, rs1_val_32b, rs2_val_32b),\n        FSUB_S  => riscv_f32Sub (rm_3b, rs1_val_32b, rs2_val_32b),\n        FMUL_S  => riscv_f32Mul (rm_3b, rs1_val_32b, rs2_val_32b),\n        FDIV_S  => riscv_f32Div (rm_3b, rs1_val_32b, rs2_val_32b)\n      };\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_32b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmv.d.x",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b1111001", "size": 7 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "D" ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_X            = X(rs1);\n  let rd_val_D             = rs1_val_X [63..0];\n  F(rd) = rd_val_D;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmv.h.x",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b1111010", "size": 7 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfh" ],
  "function": "{\n  let rs1_val_X            = X(rs1);\n  let rd_val_H             = rs1_val_X [15..0];\n  F(rd) = nan_box (rd_val_H);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmv.w.x",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b1111000", "size": 7 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "F" ],
  "function": "{\n  let rs1_val_X            = X(rs1);\n  let rd_val_S             = rs1_val_X [31..0];\n  F(rd) = nan_box (rd_val_S);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmv.x.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b1111001", "size": 7 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "D" ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_X            = X(rs1);\n  let rd_val_D             = rs1_val_X [63..0];\n  F(rd) = rd_val_D;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmv.x.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b1111010", "size": 7 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfh" ],
  "function": "{\n  let rs1_val_X            = X(rs1);\n  let rd_val_H             = rs1_val_X [15..0];\n  F(rd) = nan_box (rd_val_H);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmv.x.w",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b1111000", "size": 7 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "F" ],
  "function": "{\n  let rs1_val_X            = X(rs1);\n  let rd_val_S             = rs1_val_X [31..0];\n  F(rd) = nan_box (rd_val_S);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmvh.x.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b1110001", "size": 7 }, { "field": "0b00001", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "D","Zfa" ],
  "function": "{\n  let rs1_val_D           = F_D(rs1)[63..32];\n  let rd_val_X : xlenbits = sign_extend(rs1_val_D);\n  X(rd)                   = rd_val_X;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fmvp.d.x",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1011001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "D","Zfa" ],
  "function": "{\n  let rs1_val_X     = X(rs1)[31..0];\n  let rs2_val_X     = X(rs2)[31..0];\n\n  /* Concatenate the two values using '@' operator */\n  /* e.g. */\n  /*   rs1 = 0x01234567 */\n  /*   rs2 = 0x89abcdef */\n  /*   rd  = rs1 @ rs2 => 0x89abcdef01234567 */\n  let rd_val_D      = rs2_val_X @ rs1_val_X;\n\n  F_D(rd)           = rd_val_D;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fnmadd.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs3", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rs3,rm",
  "format": "TBD",
  "fields": [ { "field": "rs3", "size": 5 }, { "field": "0b01", "size": 2 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1001111", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_64b = F_or_X_D(rs1);\n  let rs2_val_64b = F_or_X_D(rs2);\n  let rs3_val_64b = F_or_X_D(rs3);\n\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_64b) : (bits(5), bits(64)) =\n        match op {\n          FMADD_D  => riscv_f64MulAdd (rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b),\n          FMSUB_D  => riscv_f64MulAdd (rm_3b, rs1_val_64b, rs2_val_64b, negate_D (rs3_val_64b)),\n          FNMSUB_D => riscv_f64MulAdd (rm_3b, negate_D (rs1_val_64b), rs2_val_64b, rs3_val_64b),\n          FNMADD_D => riscv_f64MulAdd (rm_3b, negate_D (rs1_val_64b), rs2_val_64b, negate_D (rs3_val_64b))\n        };\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_64b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fnmadd.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs3", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rs3,rm",
  "format": "TBD",
  "fields": [ { "field": "rs3", "size": 5 }, { "field": "0b10", "size": 2 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1001111", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_16b = F_or_X_H(rs1);\n  let rs2_val_16b = F_or_X_H(rs2);\n  let rs3_val_16b = F_or_X_H(rs3);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_16b) : (bits(5), bits(16)) =\n        match op {\n          FMADD_H  => riscv_f16MulAdd (rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b),\n          FMSUB_H  => riscv_f16MulAdd (rm_3b, rs1_val_16b, rs2_val_16b, negate_H (rs3_val_16b)),\n          FNMSUB_H => riscv_f16MulAdd (rm_3b, negate_H (rs1_val_16b), rs2_val_16b, rs3_val_16b),\n          FNMADD_H => riscv_f16MulAdd (rm_3b, negate_H (rs1_val_16b), rs2_val_16b, negate_H (rs3_val_16b))\n        };\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_16b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fnmadd.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs3", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rs3,rm",
  "format": "TBD",
  "fields": [ { "field": "rs3", "size": 5 }, { "field": "0b00", "size": 2 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1001111", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_32b = F_or_X_S(rs1);\n  let rs2_val_32b = F_or_X_S(rs2);\n  let rs3_val_32b = F_or_X_S(rs3);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_32b) : (bits(5), bits(32)) =\n        match op {\n          FMADD_S  => riscv_f32MulAdd (rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b),\n          FMSUB_S  => riscv_f32MulAdd (rm_3b, rs1_val_32b, rs2_val_32b, negate_S (rs3_val_32b)),\n          FNMSUB_S => riscv_f32MulAdd (rm_3b, negate_S (rs1_val_32b), rs2_val_32b, rs3_val_32b),\n          FNMADD_S => riscv_f32MulAdd (rm_3b, negate_S (rs1_val_32b), rs2_val_32b, negate_S (rs3_val_32b))\n        };\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_32b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fnmsub.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs3", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rs3,rm",
  "format": "TBD",
  "fields": [ { "field": "rs3", "size": 5 }, { "field": "0b01", "size": 2 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1001111", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_64b = F_or_X_D(rs1);\n  let rs2_val_64b = F_or_X_D(rs2);\n  let rs3_val_64b = F_or_X_D(rs3);\n\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_64b) : (bits(5), bits(64)) =\n        match op {\n          FMADD_D  => riscv_f64MulAdd (rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b),\n          FMSUB_D  => riscv_f64MulAdd (rm_3b, rs1_val_64b, rs2_val_64b, negate_D (rs3_val_64b)),\n          FNMSUB_D => riscv_f64MulAdd (rm_3b, negate_D (rs1_val_64b), rs2_val_64b, rs3_val_64b),\n          FNMADD_D => riscv_f64MulAdd (rm_3b, negate_D (rs1_val_64b), rs2_val_64b, negate_D (rs3_val_64b))\n        };\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_64b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fnmsub.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs3", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rs3,rm",
  "format": "TBD",
  "fields": [ { "field": "rs3", "size": 5 }, { "field": "0b10", "size": 2 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1001111", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_16b = F_or_X_H(rs1);\n  let rs2_val_16b = F_or_X_H(rs2);\n  let rs3_val_16b = F_or_X_H(rs3);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_16b) : (bits(5), bits(16)) =\n        match op {\n          FMADD_H  => riscv_f16MulAdd (rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b),\n          FMSUB_H  => riscv_f16MulAdd (rm_3b, rs1_val_16b, rs2_val_16b, negate_H (rs3_val_16b)),\n          FNMSUB_H => riscv_f16MulAdd (rm_3b, negate_H (rs1_val_16b), rs2_val_16b, rs3_val_16b),\n          FNMADD_H => riscv_f16MulAdd (rm_3b, negate_H (rs1_val_16b), rs2_val_16b, negate_H (rs3_val_16b))\n        };\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_16b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fnmsub.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs3", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rs3,rm",
  "format": "TBD",
  "fields": [ { "field": "rs3", "size": 5 }, { "field": "0b00", "size": 2 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1001111", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_32b = F_or_X_S(rs1);\n  let rs2_val_32b = F_or_X_S(rs2);\n  let rs3_val_32b = F_or_X_S(rs3);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_32b) : (bits(5), bits(32)) =\n        match op {\n          FMADD_S  => riscv_f32MulAdd (rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b),\n          FMSUB_S  => riscv_f32MulAdd (rm_3b, rs1_val_32b, rs2_val_32b, negate_S (rs3_val_32b)),\n          FNMSUB_S => riscv_f32MulAdd (rm_3b, negate_S (rs1_val_32b), rs2_val_32b, rs3_val_32b),\n          FNMADD_S => riscv_f32MulAdd (rm_3b, negate_S (rs1_val_32b), rs2_val_32b, negate_S (rs3_val_32b))\n        };\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_32b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fround.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0100001", "size": 7 }, { "field": "0b00100", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "D","Zfa" ],
  "function": "{\n  let rs1_val_D = F_D(rs1);\n\n  match (select_instr_or_fcsr_rm(rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b =  encdec_rounding_mode(rm');\n      let (fflags, rd_val_D) = riscv_f64roundToInt(rm_3b, rs1_val_D, false);\n\n      accrue_fflags(fflags);\n      F_D(rd) = rd_val_D;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fround.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0100010", "size": 7 }, { "field": "0b00100", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfh","Zfa" ],
  "function": "{\n  let rs1_val_H = F_H(rs1);\n\n  match (select_instr_or_fcsr_rm(rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b =  encdec_rounding_mode(rm');\n      let (fflags, rd_val_H) = riscv_f16roundToInt(rm_3b, rs1_val_H, false);\n\n      accrue_fflags(fflags);\n      F_H(rd) = rd_val_H;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fround.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "0b00100", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfa" ],
  "function": "{\n  let rs1_val_S = F_S(rs1);\n\n  match (select_instr_or_fcsr_rm(rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b =  encdec_rounding_mode(rm');\n      let (fflags, rd_val_S) = riscv_f32roundToInt(rm_3b, rs1_val_S, false);\n\n      accrue_fflags(fflags);\n      F_S(rd) = rd_val_S;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "froundnx.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0100001", "size": 7 }, { "field": "0b00101", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "D","Zfa" ],
  "function": "{\n  let rs1_val_D = F_D(rs1);\n\n  match (select_instr_or_fcsr_rm(rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b =  encdec_rounding_mode(rm');\n      let (fflags, rd_val_D) = riscv_f64roundToInt(rm_3b, rs1_val_D, true);\n\n      accrue_fflags(fflags);\n      F_D(rd) = rd_val_D;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "froundnx.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0100010", "size": 7 }, { "field": "0b00101", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfh","Zfa" ],
  "function": "{\n  let rs1_val_H = F_H(rs1);\n\n  match (select_instr_or_fcsr_rm(rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b =  encdec_rounding_mode(rm');\n      let (fflags, rd_val_H) = riscv_f16roundToInt(rm_3b, rs1_val_H, true);\n\n      accrue_fflags(fflags);\n      F_H(rd) = rd_val_H;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "froundnx.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "0b00101", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [ "Zfa" ],
  "function": "{\n  let rs1_val_S = F_S(rs1);\n\n  match (select_instr_or_fcsr_rm(rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b =  encdec_rounding_mode(rm');\n      let (fflags, rd_val_S) = riscv_f32roundToInt(rm_3b, rs1_val_S, true);\n\n      accrue_fflags(fflags);\n      F_S(rd) = rd_val_S;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsb",
  "name": "TBD",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "imm5", "size": 1 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "D" ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let (aq, rl, con) = (false, false, false);\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), size_bytes(width)) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares : MemoryOpResult(unit) = match width {\n            BYTE   => MemValue () /* bogus placeholder for illegal size */,\n            HALF   => mem_write_ea(addr, 2, aq, rl, false),\n            WORD   => mem_write_ea(addr, 4, aq, rl, false),\n            DOUBLE => mem_write_ea(addr, 8, aq, rl, false)\n          };\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = F(rs2);\n              match (width) {\n                BYTE => { handle_illegal(); RETIRE_FAIL },\n                HALF => process_fstore (vaddr, mem_write_value(addr, 2, rs2_val[15..0], aq, rl, con)),\n                WORD => process_fstore (vaddr, mem_write_value(addr, 4, rs2_val[31..0], aq, rl, con)),\n                DOUBLE if sizeof(flen) >= 64 =>\n                  process_fstore (vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)),\n                _ => report_invalid_width(__FILE__, __LINE__, width, \"floating point store\"),\n              };\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsd",
  "name": "TBD",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "imm5", "size": 1 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "D" ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let (aq, rl, con) = (false, false, false);\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), size_bytes(width)) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares : MemoryOpResult(unit) = match width {\n            BYTE   => MemValue () /* bogus placeholder for illegal size */,\n            HALF   => mem_write_ea(addr, 2, aq, rl, false),\n            WORD   => mem_write_ea(addr, 4, aq, rl, false),\n            DOUBLE => mem_write_ea(addr, 8, aq, rl, false)\n          };\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = F(rs2);\n              match (width) {\n                BYTE => { handle_illegal(); RETIRE_FAIL },\n                HALF => process_fstore (vaddr, mem_write_value(addr, 2, rs2_val[15..0], aq, rl, con)),\n                WORD => process_fstore (vaddr, mem_write_value(addr, 4, rs2_val[31..0], aq, rl, con)),\n                DOUBLE if sizeof(flen) >= 64 =>\n                  process_fstore (vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)),\n                _ => report_invalid_width(__FILE__, __LINE__, width, \"floating point store\"),\n              };\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsgnj.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_D = F_or_X_D(rs1);\n  let rs2_val_D = F_or_X_D(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f64Le (rs1_val_D, rs2_val_D);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsgnj.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010010", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_H = F_or_X_H(rs1);\n  let rs2_val_H = F_or_X_H(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f16Le (rs1_val_H, rs2_val_H);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsgnj.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_S = F_or_X_S(rs1);\n  let rs2_val_S = F_or_X_S(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f32Le (rs1_val_S, rs2_val_S);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsgnjn.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_D = F_or_X_D(rs1);\n  let rs2_val_D = F_or_X_D(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f64Le (rs1_val_D, rs2_val_D);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsgnjn.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010010", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_H = F_or_X_H(rs1);\n  let rs2_val_H = F_or_X_H(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f16Le (rs1_val_H, rs2_val_H);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsgnjn.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_S = F_or_X_S(rs1);\n  let rs2_val_S = F_or_X_S(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f32Le (rs1_val_S, rs2_val_S);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsgnjx.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_D = F_or_X_D(rs1);\n  let rs2_val_D = F_or_X_D(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f64Le (rs1_val_D, rs2_val_D);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsgnjx.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010010", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_H = F_or_X_H(rs1);\n  let rs2_val_H = F_or_X_H(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f16Le (rs1_val_H, rs2_val_H);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsgnjx.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_S = F_or_X_S(rs1);\n  let rs2_val_S = F_or_X_S(rs2);\n\n  let (fflags, rd_val) : (bits_fflags, bool) =\n      riscv_f32Le (rs1_val_S, rs2_val_S);\n\n  accrue_fflags(fflags);\n  X(rd) = zero_extend(bool_to_bits(rd_val));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsh",
  "name": "TBD",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "imm5", "size": 1 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "D" ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let (aq, rl, con) = (false, false, false);\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), size_bytes(width)) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares : MemoryOpResult(unit) = match width {\n            BYTE   => MemValue () /* bogus placeholder for illegal size */,\n            HALF   => mem_write_ea(addr, 2, aq, rl, false),\n            WORD   => mem_write_ea(addr, 4, aq, rl, false),\n            DOUBLE => mem_write_ea(addr, 8, aq, rl, false)\n          };\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = F(rs2);\n              match (width) {\n                BYTE => { handle_illegal(); RETIRE_FAIL },\n                HALF => process_fstore (vaddr, mem_write_value(addr, 2, rs2_val[15..0], aq, rl, con)),\n                WORD => process_fstore (vaddr, mem_write_value(addr, 4, rs2_val[31..0], aq, rl, con)),\n                DOUBLE if sizeof(flen) >= 64 =>\n                  process_fstore (vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)),\n                _ => report_invalid_width(__FILE__, __LINE__, width, \"floating point store\"),\n              };\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsqrt.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101001", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_D;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsqrt.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101010", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_H;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsqrt.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rm",
  "format": "TBD",
  "fields": [ { "field": "0b1101000", "size": 7 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  assert(sizeof(xlen) >= 64);\n  let rs1_val_LU = X(rs1)[63..0];\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\n\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_S;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsub.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0001101", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_64b = F_or_X_D(rs1);\n  let rs2_val_64b = F_or_X_D(rs2);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op {\n        FADD_D  => riscv_f64Add (rm_3b, rs1_val_64b, rs2_val_64b),\n        FSUB_D  => riscv_f64Sub (rm_3b, rs1_val_64b, rs2_val_64b),\n        FMUL_D  => riscv_f64Mul (rm_3b, rs1_val_64b, rs2_val_64b),\n        FDIV_D  => riscv_f64Div (rm_3b, rs1_val_64b, rs2_val_64b)\n      };\n      accrue_fflags(fflags);\n      F_or_X_D(rd) = rd_val_64b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsub.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0001110", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_16b = F_or_X_H(rs1);\n  let rs2_val_16b = F_or_X_H(rs2);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op {\n        FADD_H  => riscv_f16Add (rm_3b, rs1_val_16b, rs2_val_16b),\n        FSUB_H  => riscv_f16Sub (rm_3b, rs1_val_16b, rs2_val_16b),\n        FMUL_H  => riscv_f16Mul (rm_3b, rs1_val_16b, rs2_val_16b),\n        FDIV_H  => riscv_f16Div (rm_3b, rs1_val_16b, rs2_val_16b)\n      };\n      accrue_fflags(fflags);\n      F_or_X_H(rd) = rd_val_16b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsub.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rm", "type": "rounding_mode", "optional": false } ],
  "syntax": "rd,rs1,rs2,rm",
  "format": "TBD",
  "fields": [ { "field": "0b0001100", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_rounding_mode(rm)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val_32b = F_or_X_S(rs1);\n  let rs2_val_32b = F_or_X_S(rs2);\n  match (select_instr_or_fcsr_rm (rm)) {\n    None() => { handle_illegal(); RETIRE_FAIL },\n    Some(rm') => {\n      let rm_3b = encdec_rounding_mode(rm');\n      let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op {\n        FADD_S  => riscv_f32Add (rm_3b, rs1_val_32b, rs2_val_32b),\n        FSUB_S  => riscv_f32Sub (rm_3b, rs1_val_32b, rs2_val_32b),\n        FMUL_S  => riscv_f32Mul (rm_3b, rs1_val_32b, rs2_val_32b),\n        FDIV_S  => riscv_f32Div (rm_3b, rs1_val_32b, rs2_val_32b)\n      };\n      accrue_fflags(fflags);\n      F_or_X_S(rd) = rd_val_32b;\n      RETIRE_SUCCESS\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "fsw",
  "name": "TBD",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "imm5", "size": 1 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "D" ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let (aq, rl, con) = (false, false, false);\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), size_bytes(width)) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) => {\n          let eares : MemoryOpResult(unit) = match width {\n            BYTE   => MemValue () /* bogus placeholder for illegal size */,\n            HALF   => mem_write_ea(addr, 2, aq, rl, false),\n            WORD   => mem_write_ea(addr, 4, aq, rl, false),\n            DOUBLE => mem_write_ea(addr, 8, aq, rl, false)\n          };\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = F(rs2);\n              match (width) {\n                BYTE => { handle_illegal(); RETIRE_FAIL },\n                HALF => process_fstore (vaddr, mem_write_value(addr, 2, rs2_val[15..0], aq, rl, con)),\n                WORD => process_fstore (vaddr, mem_write_value(addr, 4, rs2_val[31..0], aq, rl, con)),\n                DOUBLE if sizeof(flen) >= 64 =>\n                  process_fstore (vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)),\n                _ => report_invalid_width(__FILE__, __LINE__, width, \"floating point store\"),\n              };\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "illegal",
  "name": "TBD",
  "operands": [ { "name": "s", "type": "word", "optional": false } ],
  "syntax": "s",
  "format": "TBD",
  "fields": [ { "field": "s", "size": 32 } ],
  "extensions": [  ],
  "function": "{ handle_illegal(); RETIRE_FAIL }",
  "description": "TBD"
},
{
  "mnemonic": "jal",
  "name": "jump and link",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(21)", "optional": false } ],
  "syntax": "rd,imm",
  "format": "TBD",
  "fields": [ { "field": "imm_19", "size": 1 }, { "field": "imm_18_13", "size": 6 }, { "field": "imm_12_9", "size": 4 }, { "field": "imm_8", "size": 1 }, { "field": "imm_7_0", "size": 8 }, { "field": "rd", "size": 5 }, { "field": "0b1101111", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let t : xlenbits = PC + sign_extend(imm);\n  /* Extensions get the first checks on the prospective target address. */\n  match ext_control_check_pc(t) {\n    Ext_ControlAddr_Error(e) => {\n      ext_handle_control_check_error(e);\n      RETIRE_FAIL\n    },\n    Ext_ControlAddr_OK(target) => {\n      /* Perform standard alignment check */\n      if bit_to_bool(target[1]) & not(extensionEnabled(Ext_Zca))\n      then {\n        handle_mem_exception(target, E_Fetch_Addr_Align());\n        RETIRE_FAIL\n      } else {\n        X(rd) = get_next_pc();\n        set_next_pc(target);\n        RETIRE_SUCCESS\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "jalr",
  "name": "jump and link register",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "I",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1100111", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n/* For the sequential model, the memory-model definition doesn't work directly\n * if rs1 = rd.  We would effectively have to keep a regfile for reads and another for\n * writes, and swap on instruction completion.  This could perhaps be optimized in\n * some manner, but for now, we just keep a reordered definition to improve simulator\n * performance.\n */\n  let t : xlenbits = X(rs1) + sign_extend(imm);\n  /* Extensions get the first checks on the prospective target address. */\n  match ext_control_check_addr(t) {\n    Ext_ControlAddr_Error(e) => {\n      ext_handle_control_check_error(e);\n      RETIRE_FAIL\n    },\n    Ext_ControlAddr_OK(addr) => {\n      let target = [addr with 0 = bitzero];  /* clear addr[0] */\n      if bit_to_bool(target[1]) & not(extensionEnabled(Ext_Zca)) then {\n        handle_mem_exception(target, E_Fetch_Addr_Align());\n        RETIRE_FAIL\n      } else {\n        X(rd) = get_next_pc();\n        set_next_pc(target);\n        RETIRE_SUCCESS\n      }\n    }\n  }\n}",
  "description": "\nThe target address is obtained by adding the sign-extended 12-bit\nI-immediate to the register rs1, then setting the\nleast-significant bit of the result to zero. The address of the\ninstruction following the jump (pc+4) is written to register rd.\nRegister x0 can be used as the destination if the result is not\nrequired.\n "
},
{
  "mnemonic": "lb",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lb.aq",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lb.aq.rl",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lb.rl",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lbu",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lbu.aq",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lbu.aq.rl",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lbu.rl",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "ld",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "ld.aq",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "ld.aq.rl",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "ld.rl",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "ldu",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "ldu.aq",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "ldu.aq.rl",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "ldu.rl",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lh",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lh.aq",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lh.aq.rl",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lh.rl",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lhu",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lhu.aq",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lhu.aq.rl",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lhu.rl",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lr.b",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00010", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Extensions might perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      /* \"LR faults like a normal load, even though it's in the AMO major opcode space.\"\n        * - Andrew Waterman, isa-dev, 10 Jul 2018.\n        */\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) =>\n          match mem_read(Read(Data), addr, width_bytes, aq, aq & rl, true) {\n            MemValue(result) => { load_reservation(addr); X(rd) = sign_extend(result); RETIRE_SUCCESS },\n            MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n          },\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "lr.b.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00010", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Extensions might perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      /* \"LR faults like a normal load, even though it's in the AMO major opcode space.\"\n        * - Andrew Waterman, isa-dev, 10 Jul 2018.\n        */\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) =>\n          match mem_read(Read(Data), addr, width_bytes, aq, aq & rl, true) {\n            MemValue(result) => { load_reservation(addr); X(rd) = sign_extend(result); RETIRE_SUCCESS },\n            MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n          },\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "lr.b.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00010", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Extensions might perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      /* \"LR faults like a normal load, even though it's in the AMO major opcode space.\"\n        * - Andrew Waterman, isa-dev, 10 Jul 2018.\n        */\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) =>\n          match mem_read(Read(Data), addr, width_bytes, aq, aq & rl, true) {\n            MemValue(result) => { load_reservation(addr); X(rd) = sign_extend(result); RETIRE_SUCCESS },\n            MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n          },\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "lr.b.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00010", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Extensions might perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      /* \"LR faults like a normal load, even though it's in the AMO major opcode space.\"\n        * - Andrew Waterman, isa-dev, 10 Jul 2018.\n        */\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) =>\n          match mem_read(Read(Data), addr, width_bytes, aq, aq & rl, true) {\n            MemValue(result) => { load_reservation(addr); X(rd) = sign_extend(result); RETIRE_SUCCESS },\n            MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n          },\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "lr.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00010", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Extensions might perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      /* \"LR faults like a normal load, even though it's in the AMO major opcode space.\"\n        * - Andrew Waterman, isa-dev, 10 Jul 2018.\n        */\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) =>\n          match mem_read(Read(Data), addr, width_bytes, aq, aq & rl, true) {\n            MemValue(result) => { load_reservation(addr); X(rd) = sign_extend(result); RETIRE_SUCCESS },\n            MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n          },\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "lr.d.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00010", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Extensions might perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      /* \"LR faults like a normal load, even though it's in the AMO major opcode space.\"\n        * - Andrew Waterman, isa-dev, 10 Jul 2018.\n        */\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) =>\n          match mem_read(Read(Data), addr, width_bytes, aq, aq & rl, true) {\n            MemValue(result) => { load_reservation(addr); X(rd) = sign_extend(result); RETIRE_SUCCESS },\n            MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n          },\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "lr.d.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00010", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Extensions might perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      /* \"LR faults like a normal load, even though it's in the AMO major opcode space.\"\n        * - Andrew Waterman, isa-dev, 10 Jul 2018.\n        */\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) =>\n          match mem_read(Read(Data), addr, width_bytes, aq, aq & rl, true) {\n            MemValue(result) => { load_reservation(addr); X(rd) = sign_extend(result); RETIRE_SUCCESS },\n            MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n          },\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "lr.d.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00010", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Extensions might perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      /* \"LR faults like a normal load, even though it's in the AMO major opcode space.\"\n        * - Andrew Waterman, isa-dev, 10 Jul 2018.\n        */\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) =>\n          match mem_read(Read(Data), addr, width_bytes, aq, aq & rl, true) {\n            MemValue(result) => { load_reservation(addr); X(rd) = sign_extend(result); RETIRE_SUCCESS },\n            MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n          },\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "lr.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00010", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Extensions might perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      /* \"LR faults like a normal load, even though it's in the AMO major opcode space.\"\n        * - Andrew Waterman, isa-dev, 10 Jul 2018.\n        */\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) =>\n          match mem_read(Read(Data), addr, width_bytes, aq, aq & rl, true) {\n            MemValue(result) => { load_reservation(addr); X(rd) = sign_extend(result); RETIRE_SUCCESS },\n            MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n          },\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "lr.h.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00010", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Extensions might perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      /* \"LR faults like a normal load, even though it's in the AMO major opcode space.\"\n        * - Andrew Waterman, isa-dev, 10 Jul 2018.\n        */\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) =>\n          match mem_read(Read(Data), addr, width_bytes, aq, aq & rl, true) {\n            MemValue(result) => { load_reservation(addr); X(rd) = sign_extend(result); RETIRE_SUCCESS },\n            MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n          },\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "lr.h.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00010", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Extensions might perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      /* \"LR faults like a normal load, even though it's in the AMO major opcode space.\"\n        * - Andrew Waterman, isa-dev, 10 Jul 2018.\n        */\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) =>\n          match mem_read(Read(Data), addr, width_bytes, aq, aq & rl, true) {\n            MemValue(result) => { load_reservation(addr); X(rd) = sign_extend(result); RETIRE_SUCCESS },\n            MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n          },\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "lr.h.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00010", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Extensions might perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      /* \"LR faults like a normal load, even though it's in the AMO major opcode space.\"\n        * - Andrew Waterman, isa-dev, 10 Jul 2018.\n        */\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) =>\n          match mem_read(Read(Data), addr, width_bytes, aq, aq & rl, true) {\n            MemValue(result) => { load_reservation(addr); X(rd) = sign_extend(result); RETIRE_SUCCESS },\n            MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n          },\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "lr.w",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00010", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Extensions might perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      /* \"LR faults like a normal load, even though it's in the AMO major opcode space.\"\n        * - Andrew Waterman, isa-dev, 10 Jul 2018.\n        */\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) =>\n          match mem_read(Read(Data), addr, width_bytes, aq, aq & rl, true) {\n            MemValue(result) => { load_reservation(addr); X(rd) = sign_extend(result); RETIRE_SUCCESS },\n            MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n          },\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "lr.w.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00010", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Extensions might perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      /* \"LR faults like a normal load, even though it's in the AMO major opcode space.\"\n        * - Andrew Waterman, isa-dev, 10 Jul 2018.\n        */\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) =>\n          match mem_read(Read(Data), addr, width_bytes, aq, aq & rl, true) {\n            MemValue(result) => { load_reservation(addr); X(rd) = sign_extend(result); RETIRE_SUCCESS },\n            MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n          },\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "lr.w.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00010", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Extensions might perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      /* \"LR faults like a normal load, even though it's in the AMO major opcode space.\"\n        * - Andrew Waterman, isa-dev, 10 Jul 2018.\n        */\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) =>\n          match mem_read(Read(Data), addr, width_bytes, aq, aq & rl, true) {\n            MemValue(result) => { load_reservation(addr); X(rd) = sign_extend(result); RETIRE_SUCCESS },\n            MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n          },\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "lr.w.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00010", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) (no offset).\n    * Extensions might perform additional checks on address validity.\n    */\n  match ext_data_get_addr(rs1, zeros(), Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      /* \"LR faults like a normal load, even though it's in the AMO major opcode space.\"\n        * - Andrew Waterman, isa-dev, 10 Jul 2018.\n        */\n      if not(is_aligned(vaddr, width))\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(addr, _) =>\n          match mem_read(Read(Data), addr, width_bytes, aq, aq & rl, true) {\n            MemValue(result) => { load_reservation(addr); X(rd) = sign_extend(result); RETIRE_SUCCESS },\n            MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n          },\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "lui",
  "name": "load upper immediate",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(20)", "optional": false } ],
  "syntax": "rd,imm",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 20 }, { "field": "rd", "size": 5 }, { "field": "encdec_uop(op)", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let off : xlenbits = sign_extend(imm @ 0x000);\n  let ret : xlenbits = match op {\n    RISCV_LUI   => off,\n    RISCV_AUIPC => get_arch_pc() + off\n  };\n  X(rd) = ret;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "lw",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lw.aq",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lw.aq.rl",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lw.rl",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lwu",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lwu.aq",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lwu.aq.rl",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "lwu.rl",
  "name": "load",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "bool_bits(is_unsigned)", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0000011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Read(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Read(Data)) {\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) =>\n\n          match mem_read(Read(Data), paddr, width_bytes, aq, rl, false) {\n            MemValue(result) => { X(rd) = extend_value(is_unsigned, result); RETIRE_SUCCESS },\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n          },\n      }\n    },\n  }\n}",
  "description": "\nThe LOAD instruction format is used for loading data from memory into a\nregister. The specific operation is determined by the word width (size),\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\nsemantics (acquire, release). The result is written to the destination\nregister (rd), and the memory address is computed by adding the immediate\noffset (imm) to the value in register rs1.\n "
},
{
  "mnemonic": "max",
  "name": "maximum",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0110000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbb","Zbkb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ANDN => rs1_val & ~(rs2_val),\n    RISCV_ORN  => rs1_val | ~(rs2_val),\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_ROL  => if sizeof(xlen) == 32\n                  then rs1_val <<< rs2_val[4..0]\n                  else rs1_val <<< rs2_val[5..0],\n    RISCV_ROR  => if sizeof(xlen) == 32\n                  then rs1_val >>> rs2_val[4..0]\n                  else rs1_val >>> rs2_val[5..0]\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "maxu",
  "name": "unsigned maximum",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0110000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbb","Zbkb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ANDN => rs1_val & ~(rs2_val),\n    RISCV_ORN  => rs1_val | ~(rs2_val),\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_ROL  => if sizeof(xlen) == 32\n                  then rs1_val <<< rs2_val[4..0]\n                  else rs1_val <<< rs2_val[5..0],\n    RISCV_ROR  => if sizeof(xlen) == 32\n                  then rs1_val >>> rs2_val[4..0]\n                  else rs1_val >>> rs2_val[5..0]\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "min",
  "name": "minimum",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0110000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbb","Zbkb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ANDN => rs1_val & ~(rs2_val),\n    RISCV_ORN  => rs1_val | ~(rs2_val),\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_ROL  => if sizeof(xlen) == 32\n                  then rs1_val <<< rs2_val[4..0]\n                  else rs1_val <<< rs2_val[5..0],\n    RISCV_ROR  => if sizeof(xlen) == 32\n                  then rs1_val >>> rs2_val[4..0]\n                  else rs1_val >>> rs2_val[5..0]\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "minu",
  "name": "unsigned minimum",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0110000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbb","Zbkb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ANDN => rs1_val & ~(rs2_val),\n    RISCV_ORN  => rs1_val | ~(rs2_val),\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_ROL  => if sizeof(xlen) == 32\n                  then rs1_val <<< rs2_val[4..0]\n                  else rs1_val <<< rs2_val[5..0],\n    RISCV_ROR  => if sizeof(xlen) == 32\n                  then rs1_val >>> rs2_val[4..0]\n                  else rs1_val >>> rs2_val[5..0]\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "mret",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "0b0011000", "size": 7 }, { "field": "0b00010", "size": 5 }, { "field": "0b00000", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b1110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  if   cur_privilege != Machine\n  then { handle_illegal(); RETIRE_FAIL }\n  else if not(ext_check_xret_priv (Machine))\n  then { ext_fail_xret_priv(); RETIRE_FAIL }\n  else {\n    set_next_pc(exception_handler(cur_privilege, CTL_MRET(), PC));\n    RETIRE_SUCCESS\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "mul",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_mul_op(mul_op)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "M","Zmmul" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let rs1_int : int = if mul_op.signed_rs1 then signed(rs1_val) else unsigned(rs1_val);\n  let rs2_int : int = if mul_op.signed_rs2 then signed(rs2_val) else unsigned(rs2_val);\n  let result_wide = to_bits(2 * sizeof(xlen), rs1_int * rs2_int);\n  let result = if   mul_op.high\n               then result_wide[(2 * sizeof(xlen) - 1) .. sizeof(xlen)]\n               else result_wide[(sizeof(xlen) - 1) .. 0];\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "mulh",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_mul_op(mul_op)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "M","Zmmul" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let rs1_int : int = if mul_op.signed_rs1 then signed(rs1_val) else unsigned(rs1_val);\n  let rs2_int : int = if mul_op.signed_rs2 then signed(rs2_val) else unsigned(rs2_val);\n  let result_wide = to_bits(2 * sizeof(xlen), rs1_int * rs2_int);\n  let result = if   mul_op.high\n               then result_wide[(2 * sizeof(xlen) - 1) .. sizeof(xlen)]\n               else result_wide[(sizeof(xlen) - 1) .. 0];\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "mulhsu",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_mul_op(mul_op)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "M","Zmmul" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let rs1_int : int = if mul_op.signed_rs1 then signed(rs1_val) else unsigned(rs1_val);\n  let rs2_int : int = if mul_op.signed_rs2 then signed(rs2_val) else unsigned(rs2_val);\n  let result_wide = to_bits(2 * sizeof(xlen), rs1_int * rs2_int);\n  let result = if   mul_op.high\n               then result_wide[(2 * sizeof(xlen) - 1) .. sizeof(xlen)]\n               else result_wide[(sizeof(xlen) - 1) .. 0];\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "mulhu",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_mul_op(mul_op)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "M","Zmmul" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let rs1_int : int = if mul_op.signed_rs1 then signed(rs1_val) else unsigned(rs1_val);\n  let rs2_int : int = if mul_op.signed_rs2 then signed(rs2_val) else unsigned(rs2_val);\n  let result_wide = to_bits(2 * sizeof(xlen), rs1_int * rs2_int);\n  let result = if   mul_op.high\n               then result_wide[(2 * sizeof(xlen) - 1) .. sizeof(xlen)]\n               else result_wide[(sizeof(xlen) - 1) .. 0];\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "mulw",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [ "M","Zmmul" ],
  "function": "{\n  let rs1_val = X(rs1)[31..0];\n  let rs2_val = X(rs2)[31..0];\n  let rs1_int : int = signed(rs1_val);\n  let rs2_int : int = signed(rs2_val);\n  /* to_bits requires expansion to 64 bits followed by truncation */\n  let result32 = to_bits(64, rs1_int * rs2_int)[31..0];\n  let result : xlenbits = sign_extend(result32);\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "or",
  "name": "OR",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ADD  => rs1_val + rs2_val,\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\n    RISCV_AND  => rs1_val & rs2_val,\n    RISCV_OR   => rs1_val | rs2_val,\n    RISCV_XOR  => rs1_val ^ rs2_val,\n    RISCV_SLL  => if   sizeof(xlen) == 32\n                  then rs1_val << (rs2_val[4..0])\n                  else rs1_val << (rs2_val[5..0]),\n    RISCV_SRL  => if   sizeof(xlen) == 32\n                  then rs1_val >> (rs2_val[4..0])\n                  else rs1_val >> (rs2_val[5..0]),\n    RISCV_SUB  => rs1_val - rs2_val,\n    RISCV_SRA  => if   sizeof(xlen) == 32\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe R-type (Register-type) instruction format is used for operations\nthat involve three registers. The specific operation is determined\nby the opcode and funct7 fields. The result is written to the\ndestination register (rd), and the source operands are specified\nby the source registers (rs1 and rs2). The format is common for\narithmetic, logical, and shift operations.\n "
},
{
  "mnemonic": "orc.b",
  "name": "bitwise OR-combine, byte granule",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b001010000111", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zbb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  var result : xlenbits = zeros();\n  foreach (i from 0 to (sizeof(xlen) - 8) by 8)\n    result[(i + 7) .. i] = if rs1_val[(i + 7) .. i] == zeros()\n                           then 0x00\n                           else 0xFF;\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "ori",
  "name": "OR immediate",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false } ],
  "syntax": "rd,rs1,imm",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "encdec_iop(op)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let immext : xlenbits = sign_extend(imm);\n  let result : xlenbits = match op {\n    RISCV_ADDI  => rs1_val + immext,\n    RISCV_SLTI  => zero_extend(bool_to_bits(rs1_val <_s immext)),\n    RISCV_SLTIU => zero_extend(bool_to_bits(rs1_val <_u immext)),\n    RISCV_ANDI  => rs1_val & immext,\n    RISCV_ORI   => rs1_val | immext,\n    RISCV_XORI  => rs1_val ^ immext\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe ITYPE instruction operates on an immediate value, adding, comparing, or\nperforming bitwise operations with the contents of register rs1.\nThe immediate value, rs1, and the operation code (iop) determine the operation.\nThe result is stored in register rd.\nThe supported immediate operations (iop) include:\n  - \"addi\"  : Add immediate\n  - \"slti\"  : Set less than immediate (signed)\n  - \"sltiu\" : Set less than immediate (unsigned)\n  - \"andi\"  : AND immediate\n  - \"ori\"   : OR immediate\n  - \"xori\"  : XOR immediate\n\nNote: The immediate value is sign-extended before performing the operation.\n "
},
{
  "mnemonic": "orn",
  "name": "OR with inverted operand",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0110000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbb","Zbkb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ANDN => rs1_val & ~(rs2_val),\n    RISCV_ORN  => rs1_val | ~(rs2_val),\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_ROL  => if sizeof(xlen) == 32\n                  then rs1_val <<< rs2_val[4..0]\n                  else rs1_val <<< rs2_val[5..0],\n    RISCV_ROR  => if sizeof(xlen) == 32\n                  then rs1_val >>> rs2_val[4..0]\n                  else rs1_val >>> rs2_val[5..0]\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "pack",
  "name": "pack low halves of registers",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000100", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b111", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbkb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_PACK  => rs2_val[(sizeof(xlen_bytes)*4 - 1)..0] @ rs1_val[(sizeof(xlen_bytes)*4 - 1)..0],\n    RISCV_PACKH => zero_extend(rs2_val[7..0] @ rs1_val[7..0])\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "packh",
  "name": "pack low bytes of registers",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000100", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b111", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbkb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_PACK  => rs2_val[(sizeof(xlen_bytes)*4 - 1)..0] @ rs1_val[(sizeof(xlen_bytes)*4 - 1)..0],\n    RISCV_PACKH => zero_extend(rs2_val[7..0] @ rs1_val[7..0])\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "packw",
  "name": "pack low 16-bits of registers (RV64)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000100", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [ "Zbkb" ],
  "function": "{\n  assert(sizeof(xlen) == 64);\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : bits(32) = rs2_val[15..0] @ rs1_val[15..0];\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "rem",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b11", "size": 2 }, { "field": "bool_not_bits(s)", "size": 1 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "M" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val);\n  let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val);\n  let r : int = if rs2_int == 0 then rs1_int else rem_round_zero(rs1_int, rs2_int);\n  /* signed overflow case returns zero naturally as required due to -1 divisor */\n  X(rd) = to_bits(sizeof(xlen), r);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "remu",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b11", "size": 2 }, { "field": "bool_not_bits(s)", "size": 1 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "M" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val);\n  let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val);\n  let r : int = if rs2_int == 0 then rs1_int else rem_round_zero(rs1_int, rs2_int);\n  /* signed overflow case returns zero naturally as required due to -1 divisor */\n  X(rd) = to_bits(sizeof(xlen), r);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "remuw",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b11", "size": 2 }, { "field": "bool_not_bits(s)", "size": 1 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [ "M" ],
  "function": "{\n  let rs1_val = X(rs1)[31..0];\n  let rs2_val = X(rs2)[31..0];\n  let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val);\n  let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val);\n  let r : int = if rs2_int == 0 then rs1_int else rem_round_zero(rs1_int, rs2_int);\n  /* signed overflow case returns zero naturally as required due to -1 divisor */\n  X(rd) = sign_extend(to_bits(32, r));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "remw",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0000001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b11", "size": 2 }, { "field": "bool_not_bits(s)", "size": 1 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [ "M" ],
  "function": "{\n  let rs1_val = X(rs1)[31..0];\n  let rs2_val = X(rs2)[31..0];\n  let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val);\n  let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val);\n  let r : int = if rs2_int == 0 then rs1_int else rem_round_zero(rs1_int, rs2_int);\n  /* signed overflow case returns zero naturally as required due to -1 divisor */\n  X(rd) = sign_extend(to_bits(32, r));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "rev8",
  "name": "byte-reverse register",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b011010111000", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zbb","Zbkb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  var result : xlenbits = zeros();\n  foreach (i from 0 to (sizeof(xlen) - 8) by 8)\n    result[(i + 7) .. i] = rs1_val[(sizeof(xlen) - i - 1) .. (sizeof(xlen) - i - 8)];\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "rol",
  "name": "rotate left (register)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0110000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbb","Zbkb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ANDN => rs1_val & ~(rs2_val),\n    RISCV_ORN  => rs1_val | ~(rs2_val),\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_ROL  => if sizeof(xlen) == 32\n                  then rs1_val <<< rs2_val[4..0]\n                  else rs1_val <<< rs2_val[5..0],\n    RISCV_ROR  => if sizeof(xlen) == 32\n                  then rs1_val >>> rs2_val[4..0]\n                  else rs1_val >>> rs2_val[5..0]\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "rolw",
  "name": "rotate left word (register)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0110000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [ "Zbb","Zbkb" ],
  "function": "{\n  let rs1_val = (X(rs1))[31..0];\n  let shamt = (X(rs2))[4..0];\n  let result : bits(32) = match op {\n    RISCV_ROLW => rs1_val <<< shamt,\n    RISCV_RORW => rs1_val >>> shamt\n  };\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "ror",
  "name": "rotate right (register)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0110000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbb","Zbkb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ANDN => rs1_val & ~(rs2_val),\n    RISCV_ORN  => rs1_val | ~(rs2_val),\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_ROL  => if sizeof(xlen) == 32\n                  then rs1_val <<< rs2_val[4..0]\n                  else rs1_val <<< rs2_val[5..0],\n    RISCV_ROR  => if sizeof(xlen) == 32\n                  then rs1_val >>> rs2_val[4..0]\n                  else rs1_val >>> rs2_val[5..0]\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "rori",
  "name": "rotate right (immediate)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "shamt", "type": "bits(6)", "optional": false } ],
  "syntax": "rd,rs1,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b011000", "size": 6 }, { "field": "shamt", "size": 6 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zbb","Zbkb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let result : xlenbits = if sizeof(xlen) == 32\n                          then rs1_val >>> shamt[4..0]\n                          else rs1_val >>> shamt;\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "roriw",
  "name": "rotate right word (immediate)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "shamt", "type": "bits(5)", "optional": false } ],
  "syntax": "rd,rs1,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b0110000", "size": 7 }, { "field": "shamt", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0011011", "size": 7 } ],
  "extensions": [ "Zbb","Zbkb" ],
  "function": "{\n  let rs1_val = (X(rs1))[31..0];\n  let result : xlenbits = sign_extend(rs1_val >>> shamt);\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "rorw",
  "name": "rotate right word (register)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0110000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [ "Zbb","Zbkb" ],
  "function": "{\n  let rs1_val = (X(rs1))[31..0];\n  let shamt = (X(rs2))[4..0];\n  let result : bits(32) = match op {\n    RISCV_ROLW => rs1_val <<< shamt,\n    RISCV_RORW => rs1_val >>> shamt\n  };\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sb",
  "name": "store",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "imm5", "size": 1 }, { "field": "0b0100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) => {\n          let eares = mem_write_ea(paddr, width_bytes, aq, rl, false);\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = X(rs2);\n              match mem_write_value(paddr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq, rl, false) {\n                MemValue(true)  => RETIRE_SUCCESS,\n                MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n              }\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "\nThe STORE instruction format is used for storing data from a register into\nmemory. The specific operation is determined by the word width (size) and\nmemory ordering semantics (acquire, release). The memory address is computed\nby adding the immediate offset (imm) to the value in register rs1, and the\ndata is taken from register rs2.\n "
},
{
  "mnemonic": "sb.aq",
  "name": "store",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "imm5", "size": 1 }, { "field": "0b0100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) => {\n          let eares = mem_write_ea(paddr, width_bytes, aq, rl, false);\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = X(rs2);\n              match mem_write_value(paddr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq, rl, false) {\n                MemValue(true)  => RETIRE_SUCCESS,\n                MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n              }\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "\nThe STORE instruction format is used for storing data from a register into\nmemory. The specific operation is determined by the word width (size) and\nmemory ordering semantics (acquire, release). The memory address is computed\nby adding the immediate offset (imm) to the value in register rs1, and the\ndata is taken from register rs2.\n "
},
{
  "mnemonic": "sb.aq.rl",
  "name": "store",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "imm5", "size": 1 }, { "field": "0b0100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) => {\n          let eares = mem_write_ea(paddr, width_bytes, aq, rl, false);\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = X(rs2);\n              match mem_write_value(paddr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq, rl, false) {\n                MemValue(true)  => RETIRE_SUCCESS,\n                MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n              }\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "\nThe STORE instruction format is used for storing data from a register into\nmemory. The specific operation is determined by the word width (size) and\nmemory ordering semantics (acquire, release). The memory address is computed\nby adding the immediate offset (imm) to the value in register rs1, and the\ndata is taken from register rs2.\n "
},
{
  "mnemonic": "sb.rl",
  "name": "store",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "imm5", "size": 1 }, { "field": "0b0100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) => {\n          let eares = mem_write_ea(paddr, width_bytes, aq, rl, false);\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = X(rs2);\n              match mem_write_value(paddr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq, rl, false) {\n                MemValue(true)  => RETIRE_SUCCESS,\n                MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n              }\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "\nThe STORE instruction format is used for storing data from a register into\nmemory. The specific operation is determined by the word width (size) and\nmemory ordering semantics (acquire, release). The memory address is computed\nby adding the immediate offset (imm) to the value in register rs1, and the\ndata is taken from register rs2.\n "
},
{
  "mnemonic": "sc.b",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00011", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  if speculate_conditional () == false then {\n    /* should only happen in rmem\n     * rmem: allow SC to fail very early\n     */\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\n  } else {\n    /* normal non-rmem case\n      * rmem: SC is allowed to succeed (but might fail later)\n      */\n    /* Get the address, X(rs1) (no offset).\n      * Extensions might perform additional checks on address validity.\n      */\n    match ext_data_get_addr(rs1, zeros(), Write(Data), width_bytes) {\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        if not(is_aligned(vaddr, width))\n        then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n        else {\n          match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\n                                                      * both result in a SAMO exception */\n            TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            TR_Address(addr, _) => {\n              // Check reservation with physical address.\n              if not(match_reservation(addr)) then {\n                /* cannot happen in rmem */\n                X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\n              } else {\n                let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n                match eares {\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                  MemValue(_) => {\n                    let rs2_val = X(rs2);\n                    match mem_write_value(addr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq & rl, rl, true) {\n                      MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\n                      MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "sc.b.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00011", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  if speculate_conditional () == false then {\n    /* should only happen in rmem\n     * rmem: allow SC to fail very early\n     */\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\n  } else {\n    /* normal non-rmem case\n      * rmem: SC is allowed to succeed (but might fail later)\n      */\n    /* Get the address, X(rs1) (no offset).\n      * Extensions might perform additional checks on address validity.\n      */\n    match ext_data_get_addr(rs1, zeros(), Write(Data), width_bytes) {\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        if not(is_aligned(vaddr, width))\n        then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n        else {\n          match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\n                                                      * both result in a SAMO exception */\n            TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            TR_Address(addr, _) => {\n              // Check reservation with physical address.\n              if not(match_reservation(addr)) then {\n                /* cannot happen in rmem */\n                X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\n              } else {\n                let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n                match eares {\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                  MemValue(_) => {\n                    let rs2_val = X(rs2);\n                    match mem_write_value(addr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq & rl, rl, true) {\n                      MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\n                      MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "sc.b.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00011", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  if speculate_conditional () == false then {\n    /* should only happen in rmem\n     * rmem: allow SC to fail very early\n     */\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\n  } else {\n    /* normal non-rmem case\n      * rmem: SC is allowed to succeed (but might fail later)\n      */\n    /* Get the address, X(rs1) (no offset).\n      * Extensions might perform additional checks on address validity.\n      */\n    match ext_data_get_addr(rs1, zeros(), Write(Data), width_bytes) {\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        if not(is_aligned(vaddr, width))\n        then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n        else {\n          match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\n                                                      * both result in a SAMO exception */\n            TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            TR_Address(addr, _) => {\n              // Check reservation with physical address.\n              if not(match_reservation(addr)) then {\n                /* cannot happen in rmem */\n                X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\n              } else {\n                let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n                match eares {\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                  MemValue(_) => {\n                    let rs2_val = X(rs2);\n                    match mem_write_value(addr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq & rl, rl, true) {\n                      MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\n                      MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "sc.b.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00011", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  if speculate_conditional () == false then {\n    /* should only happen in rmem\n     * rmem: allow SC to fail very early\n     */\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\n  } else {\n    /* normal non-rmem case\n      * rmem: SC is allowed to succeed (but might fail later)\n      */\n    /* Get the address, X(rs1) (no offset).\n      * Extensions might perform additional checks on address validity.\n      */\n    match ext_data_get_addr(rs1, zeros(), Write(Data), width_bytes) {\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        if not(is_aligned(vaddr, width))\n        then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n        else {\n          match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\n                                                      * both result in a SAMO exception */\n            TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            TR_Address(addr, _) => {\n              // Check reservation with physical address.\n              if not(match_reservation(addr)) then {\n                /* cannot happen in rmem */\n                X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\n              } else {\n                let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n                match eares {\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                  MemValue(_) => {\n                    let rs2_val = X(rs2);\n                    match mem_write_value(addr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq & rl, rl, true) {\n                      MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\n                      MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "sc.d",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00011", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  if speculate_conditional () == false then {\n    /* should only happen in rmem\n     * rmem: allow SC to fail very early\n     */\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\n  } else {\n    /* normal non-rmem case\n      * rmem: SC is allowed to succeed (but might fail later)\n      */\n    /* Get the address, X(rs1) (no offset).\n      * Extensions might perform additional checks on address validity.\n      */\n    match ext_data_get_addr(rs1, zeros(), Write(Data), width_bytes) {\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        if not(is_aligned(vaddr, width))\n        then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n        else {\n          match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\n                                                      * both result in a SAMO exception */\n            TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            TR_Address(addr, _) => {\n              // Check reservation with physical address.\n              if not(match_reservation(addr)) then {\n                /* cannot happen in rmem */\n                X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\n              } else {\n                let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n                match eares {\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                  MemValue(_) => {\n                    let rs2_val = X(rs2);\n                    match mem_write_value(addr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq & rl, rl, true) {\n                      MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\n                      MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "sc.d.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00011", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  if speculate_conditional () == false then {\n    /* should only happen in rmem\n     * rmem: allow SC to fail very early\n     */\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\n  } else {\n    /* normal non-rmem case\n      * rmem: SC is allowed to succeed (but might fail later)\n      */\n    /* Get the address, X(rs1) (no offset).\n      * Extensions might perform additional checks on address validity.\n      */\n    match ext_data_get_addr(rs1, zeros(), Write(Data), width_bytes) {\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        if not(is_aligned(vaddr, width))\n        then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n        else {\n          match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\n                                                      * both result in a SAMO exception */\n            TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            TR_Address(addr, _) => {\n              // Check reservation with physical address.\n              if not(match_reservation(addr)) then {\n                /* cannot happen in rmem */\n                X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\n              } else {\n                let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n                match eares {\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                  MemValue(_) => {\n                    let rs2_val = X(rs2);\n                    match mem_write_value(addr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq & rl, rl, true) {\n                      MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\n                      MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "sc.d.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00011", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  if speculate_conditional () == false then {\n    /* should only happen in rmem\n     * rmem: allow SC to fail very early\n     */\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\n  } else {\n    /* normal non-rmem case\n      * rmem: SC is allowed to succeed (but might fail later)\n      */\n    /* Get the address, X(rs1) (no offset).\n      * Extensions might perform additional checks on address validity.\n      */\n    match ext_data_get_addr(rs1, zeros(), Write(Data), width_bytes) {\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        if not(is_aligned(vaddr, width))\n        then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n        else {\n          match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\n                                                      * both result in a SAMO exception */\n            TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            TR_Address(addr, _) => {\n              // Check reservation with physical address.\n              if not(match_reservation(addr)) then {\n                /* cannot happen in rmem */\n                X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\n              } else {\n                let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n                match eares {\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                  MemValue(_) => {\n                    let rs2_val = X(rs2);\n                    match mem_write_value(addr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq & rl, rl, true) {\n                      MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\n                      MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "sc.d.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00011", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  if speculate_conditional () == false then {\n    /* should only happen in rmem\n     * rmem: allow SC to fail very early\n     */\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\n  } else {\n    /* normal non-rmem case\n      * rmem: SC is allowed to succeed (but might fail later)\n      */\n    /* Get the address, X(rs1) (no offset).\n      * Extensions might perform additional checks on address validity.\n      */\n    match ext_data_get_addr(rs1, zeros(), Write(Data), width_bytes) {\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        if not(is_aligned(vaddr, width))\n        then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n        else {\n          match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\n                                                      * both result in a SAMO exception */\n            TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            TR_Address(addr, _) => {\n              // Check reservation with physical address.\n              if not(match_reservation(addr)) then {\n                /* cannot happen in rmem */\n                X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\n              } else {\n                let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n                match eares {\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                  MemValue(_) => {\n                    let rs2_val = X(rs2);\n                    match mem_write_value(addr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq & rl, rl, true) {\n                      MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\n                      MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "sc.h",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00011", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  if speculate_conditional () == false then {\n    /* should only happen in rmem\n     * rmem: allow SC to fail very early\n     */\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\n  } else {\n    /* normal non-rmem case\n      * rmem: SC is allowed to succeed (but might fail later)\n      */\n    /* Get the address, X(rs1) (no offset).\n      * Extensions might perform additional checks on address validity.\n      */\n    match ext_data_get_addr(rs1, zeros(), Write(Data), width_bytes) {\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        if not(is_aligned(vaddr, width))\n        then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n        else {\n          match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\n                                                      * both result in a SAMO exception */\n            TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            TR_Address(addr, _) => {\n              // Check reservation with physical address.\n              if not(match_reservation(addr)) then {\n                /* cannot happen in rmem */\n                X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\n              } else {\n                let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n                match eares {\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                  MemValue(_) => {\n                    let rs2_val = X(rs2);\n                    match mem_write_value(addr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq & rl, rl, true) {\n                      MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\n                      MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "sc.h.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00011", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  if speculate_conditional () == false then {\n    /* should only happen in rmem\n     * rmem: allow SC to fail very early\n     */\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\n  } else {\n    /* normal non-rmem case\n      * rmem: SC is allowed to succeed (but might fail later)\n      */\n    /* Get the address, X(rs1) (no offset).\n      * Extensions might perform additional checks on address validity.\n      */\n    match ext_data_get_addr(rs1, zeros(), Write(Data), width_bytes) {\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        if not(is_aligned(vaddr, width))\n        then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n        else {\n          match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\n                                                      * both result in a SAMO exception */\n            TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            TR_Address(addr, _) => {\n              // Check reservation with physical address.\n              if not(match_reservation(addr)) then {\n                /* cannot happen in rmem */\n                X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\n              } else {\n                let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n                match eares {\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                  MemValue(_) => {\n                    let rs2_val = X(rs2);\n                    match mem_write_value(addr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq & rl, rl, true) {\n                      MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\n                      MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "sc.h.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00011", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  if speculate_conditional () == false then {\n    /* should only happen in rmem\n     * rmem: allow SC to fail very early\n     */\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\n  } else {\n    /* normal non-rmem case\n      * rmem: SC is allowed to succeed (but might fail later)\n      */\n    /* Get the address, X(rs1) (no offset).\n      * Extensions might perform additional checks on address validity.\n      */\n    match ext_data_get_addr(rs1, zeros(), Write(Data), width_bytes) {\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        if not(is_aligned(vaddr, width))\n        then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n        else {\n          match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\n                                                      * both result in a SAMO exception */\n            TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            TR_Address(addr, _) => {\n              // Check reservation with physical address.\n              if not(match_reservation(addr)) then {\n                /* cannot happen in rmem */\n                X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\n              } else {\n                let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n                match eares {\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                  MemValue(_) => {\n                    let rs2_val = X(rs2);\n                    match mem_write_value(addr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq & rl, rl, true) {\n                      MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\n                      MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "sc.h.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00011", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  if speculate_conditional () == false then {\n    /* should only happen in rmem\n     * rmem: allow SC to fail very early\n     */\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\n  } else {\n    /* normal non-rmem case\n      * rmem: SC is allowed to succeed (but might fail later)\n      */\n    /* Get the address, X(rs1) (no offset).\n      * Extensions might perform additional checks on address validity.\n      */\n    match ext_data_get_addr(rs1, zeros(), Write(Data), width_bytes) {\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        if not(is_aligned(vaddr, width))\n        then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n        else {\n          match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\n                                                      * both result in a SAMO exception */\n            TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            TR_Address(addr, _) => {\n              // Check reservation with physical address.\n              if not(match_reservation(addr)) then {\n                /* cannot happen in rmem */\n                X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\n              } else {\n                let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n                match eares {\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                  MemValue(_) => {\n                    let rs2_val = X(rs2);\n                    match mem_write_value(addr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq & rl, rl, true) {\n                      MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\n                      MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "sc.w",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00011", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  if speculate_conditional () == false then {\n    /* should only happen in rmem\n     * rmem: allow SC to fail very early\n     */\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\n  } else {\n    /* normal non-rmem case\n      * rmem: SC is allowed to succeed (but might fail later)\n      */\n    /* Get the address, X(rs1) (no offset).\n      * Extensions might perform additional checks on address validity.\n      */\n    match ext_data_get_addr(rs1, zeros(), Write(Data), width_bytes) {\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        if not(is_aligned(vaddr, width))\n        then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n        else {\n          match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\n                                                      * both result in a SAMO exception */\n            TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            TR_Address(addr, _) => {\n              // Check reservation with physical address.\n              if not(match_reservation(addr)) then {\n                /* cannot happen in rmem */\n                X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\n              } else {\n                let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n                match eares {\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                  MemValue(_) => {\n                    let rs2_val = X(rs2);\n                    match mem_write_value(addr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq & rl, rl, true) {\n                      MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\n                      MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "sc.w.aq",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00011", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  if speculate_conditional () == false then {\n    /* should only happen in rmem\n     * rmem: allow SC to fail very early\n     */\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\n  } else {\n    /* normal non-rmem case\n      * rmem: SC is allowed to succeed (but might fail later)\n      */\n    /* Get the address, X(rs1) (no offset).\n      * Extensions might perform additional checks on address validity.\n      */\n    match ext_data_get_addr(rs1, zeros(), Write(Data), width_bytes) {\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        if not(is_aligned(vaddr, width))\n        then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n        else {\n          match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\n                                                      * both result in a SAMO exception */\n            TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            TR_Address(addr, _) => {\n              // Check reservation with physical address.\n              if not(match_reservation(addr)) then {\n                /* cannot happen in rmem */\n                X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\n              } else {\n                let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n                match eares {\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                  MemValue(_) => {\n                    let rs2_val = X(rs2);\n                    match mem_write_value(addr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq & rl, rl, true) {\n                      MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\n                      MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "sc.w.aq.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00011", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  if speculate_conditional () == false then {\n    /* should only happen in rmem\n     * rmem: allow SC to fail very early\n     */\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\n  } else {\n    /* normal non-rmem case\n      * rmem: SC is allowed to succeed (but might fail later)\n      */\n    /* Get the address, X(rs1) (no offset).\n      * Extensions might perform additional checks on address validity.\n      */\n    match ext_data_get_addr(rs1, zeros(), Write(Data), width_bytes) {\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        if not(is_aligned(vaddr, width))\n        then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n        else {\n          match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\n                                                      * both result in a SAMO exception */\n            TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            TR_Address(addr, _) => {\n              // Check reservation with physical address.\n              if not(match_reservation(addr)) then {\n                /* cannot happen in rmem */\n                X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\n              } else {\n                let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n                match eares {\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                  MemValue(_) => {\n                    let rs2_val = X(rs2);\n                    match mem_write_value(addr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq & rl, rl, true) {\n                      MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\n                      MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "sc.w.rl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs2,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b00011", "size": 5 }, { "field": "bool_bits(aq)", "size": 1 }, { "field": "bool_bits(rl)", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "rd", "size": 5 }, { "field": "0b0101111", "size": 7 } ],
  "extensions": [ "Zalrsc" ],
  "function": "{\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  if speculate_conditional () == false then {\n    /* should only happen in rmem\n     * rmem: allow SC to fail very early\n     */\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\n  } else {\n    /* normal non-rmem case\n      * rmem: SC is allowed to succeed (but might fail later)\n      */\n    /* Get the address, X(rs1) (no offset).\n      * Extensions might perform additional checks on address validity.\n      */\n    match ext_data_get_addr(rs1, zeros(), Write(Data), width_bytes) {\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n      Ext_DataAddr_OK(vaddr) => {\n        if not(is_aligned(vaddr, width))\n        then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n        else {\n          match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\n                                                      * both result in a SAMO exception */\n            TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            TR_Address(addr, _) => {\n              // Check reservation with physical address.\n              if not(match_reservation(addr)) then {\n                /* cannot happen in rmem */\n                X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\n              } else {\n                let eares = mem_write_ea(addr, width_bytes, aq & rl, rl, true);\n                match eares {\n                  MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n                  MemValue(_) => {\n                    let rs2_val = X(rs2);\n                    match mem_write_value(addr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq & rl, rl, true) {\n                      MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\n                      MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "sd",
  "name": "store",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "imm5", "size": 1 }, { "field": "0b0100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) => {\n          let eares = mem_write_ea(paddr, width_bytes, aq, rl, false);\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = X(rs2);\n              match mem_write_value(paddr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq, rl, false) {\n                MemValue(true)  => RETIRE_SUCCESS,\n                MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n              }\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "\nThe STORE instruction format is used for storing data from a register into\nmemory. The specific operation is determined by the word width (size) and\nmemory ordering semantics (acquire, release). The memory address is computed\nby adding the immediate offset (imm) to the value in register rs1, and the\ndata is taken from register rs2.\n "
},
{
  "mnemonic": "sd.aq",
  "name": "store",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "imm5", "size": 1 }, { "field": "0b0100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) => {\n          let eares = mem_write_ea(paddr, width_bytes, aq, rl, false);\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = X(rs2);\n              match mem_write_value(paddr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq, rl, false) {\n                MemValue(true)  => RETIRE_SUCCESS,\n                MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n              }\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "\nThe STORE instruction format is used for storing data from a register into\nmemory. The specific operation is determined by the word width (size) and\nmemory ordering semantics (acquire, release). The memory address is computed\nby adding the immediate offset (imm) to the value in register rs1, and the\ndata is taken from register rs2.\n "
},
{
  "mnemonic": "sd.aq.rl",
  "name": "store",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "imm5", "size": 1 }, { "field": "0b0100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) => {\n          let eares = mem_write_ea(paddr, width_bytes, aq, rl, false);\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = X(rs2);\n              match mem_write_value(paddr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq, rl, false) {\n                MemValue(true)  => RETIRE_SUCCESS,\n                MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n              }\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "\nThe STORE instruction format is used for storing data from a register into\nmemory. The specific operation is determined by the word width (size) and\nmemory ordering semantics (acquire, release). The memory address is computed\nby adding the immediate offset (imm) to the value in register rs1, and the\ndata is taken from register rs2.\n "
},
{
  "mnemonic": "sd.rl",
  "name": "store",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "imm5", "size": 1 }, { "field": "0b0100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) => {\n          let eares = mem_write_ea(paddr, width_bytes, aq, rl, false);\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = X(rs2);\n              match mem_write_value(paddr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq, rl, false) {\n                MemValue(true)  => RETIRE_SUCCESS,\n                MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n              }\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "\nThe STORE instruction format is used for storing data from a register into\nmemory. The specific operation is determined by the word width (size) and\nmemory ordering semantics (acquire, release). The memory address is computed\nby adding the immediate offset (imm) to the value in register rs1, and the\ndata is taken from register rs2.\n "
},
{
  "mnemonic": "sext.b",
  "name": "sign-extend byte",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b0000100", "size": 7 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [ "Zbb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let result : xlenbits = match op {\n    RISCV_SEXTB => sign_extend(rs1_val[7..0]),\n    RISCV_SEXTH => sign_extend(rs1_val[15..0]),\n    RISCV_ZEXTH => zero_extend(rs1_val[15..0])\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sext.h",
  "name": "sign-extend halfword",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b0000100", "size": 7 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [ "Zbb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let result : xlenbits = match op {\n    RISCV_SEXTB => sign_extend(rs1_val[7..0]),\n    RISCV_SEXTH => sign_extend(rs1_val[15..0]),\n    RISCV_ZEXTH => zero_extend(rs1_val[15..0])\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sfence.inval.ir",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "0b0001100", "size": 7 }, { "field": "0b00001", "size": 5 }, { "field": "0b00000", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b1110011", "size": 7 } ],
  "extensions": [ "Svinval" ],
  "function": "{\n  if cur_privilege == User\n  then { handle_illegal(); RETIRE_FAIL }\n  else { RETIRE_SUCCESS } // Implemented as no-op as all memory operations are visible immediately in current Sail model\n}",
  "description": "TBD"
},
{
  "mnemonic": "sfence.vma",
  "name": "store fence (virtual memory address)",
  "operands": [ { "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rs1,rs2",
  "format": "R",
  "fields": [ { "field": "0b0001001", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b1110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let addr : option(xlenbits) = if rs1 == 0b00000 then None() else Some(X(rs1));\n  let asid : option(xlenbits) = if rs2 == 0b00000 then None() else Some(X(rs2));\n  match cur_privilege {\n    User       => { handle_illegal(); RETIRE_FAIL },\n    Supervisor => match (architecture(get_mstatus_SXL(mstatus)), mstatus[TVM]) {\n                    (Some(_), 0b1)  => { handle_illegal(); RETIRE_FAIL },\n                    (Some(_), 0b0) => { flush_TLB(asid, addr); RETIRE_SUCCESS },\n                    (_, _)           => internal_error(__FILE__, __LINE__, \"unimplemented sfence architecture\")\n                  },\n    Machine    => { flush_TLB(asid, addr); RETIRE_SUCCESS }\n  }\n}",
  "description": "\nThe SFENCE.VMA instruction is used to synchronize the store queue and flush\nTLB entries based on virtual memory address and optional ASID values.\nIts behavior depends on the current privilege level:\n- In User mode, it handles the illegal instruction and returns with RETIRE_FAIL.\n- In Supervisor mode, it checks for illegal instructions and performs TLB\n  flushing based on the provided virtual memory address and ASID values.\n- In Machine mode, it performs TLB flushing based on the provided virtual\n  memory address and ASID values.\n "
},
{
  "mnemonic": "sfence.w.inval",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "0b0001100", "size": 7 }, { "field": "0b00000", "size": 5 }, { "field": "0b00000", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b1110011", "size": 7 } ],
  "extensions": [ "Svinval" ],
  "function": "{\n  if cur_privilege == User\n  then { handle_illegal(); RETIRE_FAIL }\n  else { RETIRE_SUCCESS } // Implemented as no-op as all memory operations are visible immediately the current Sail model\n}",
  "description": "TBD"
},
{
  "mnemonic": "sh",
  "name": "store",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "imm5", "size": 1 }, { "field": "0b0100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) => {\n          let eares = mem_write_ea(paddr, width_bytes, aq, rl, false);\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = X(rs2);\n              match mem_write_value(paddr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq, rl, false) {\n                MemValue(true)  => RETIRE_SUCCESS,\n                MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n              }\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "\nThe STORE instruction format is used for storing data from a register into\nmemory. The specific operation is determined by the word width (size) and\nmemory ordering semantics (acquire, release). The memory address is computed\nby adding the immediate offset (imm) to the value in register rs1, and the\ndata is taken from register rs2.\n "
},
{
  "mnemonic": "sh.aq",
  "name": "store",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "imm5", "size": 1 }, { "field": "0b0100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) => {\n          let eares = mem_write_ea(paddr, width_bytes, aq, rl, false);\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = X(rs2);\n              match mem_write_value(paddr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq, rl, false) {\n                MemValue(true)  => RETIRE_SUCCESS,\n                MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n              }\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "\nThe STORE instruction format is used for storing data from a register into\nmemory. The specific operation is determined by the word width (size) and\nmemory ordering semantics (acquire, release). The memory address is computed\nby adding the immediate offset (imm) to the value in register rs1, and the\ndata is taken from register rs2.\n "
},
{
  "mnemonic": "sh.aq.rl",
  "name": "store",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "imm5", "size": 1 }, { "field": "0b0100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) => {\n          let eares = mem_write_ea(paddr, width_bytes, aq, rl, false);\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = X(rs2);\n              match mem_write_value(paddr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq, rl, false) {\n                MemValue(true)  => RETIRE_SUCCESS,\n                MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n              }\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "\nThe STORE instruction format is used for storing data from a register into\nmemory. The specific operation is determined by the word width (size) and\nmemory ordering semantics (acquire, release). The memory address is computed\nby adding the immediate offset (imm) to the value in register rs1, and the\ndata is taken from register rs2.\n "
},
{
  "mnemonic": "sh.rl",
  "name": "store",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "imm5", "size": 1 }, { "field": "0b0100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) => {\n          let eares = mem_write_ea(paddr, width_bytes, aq, rl, false);\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = X(rs2);\n              match mem_write_value(paddr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq, rl, false) {\n                MemValue(true)  => RETIRE_SUCCESS,\n                MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n              }\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "\nThe STORE instruction format is used for storing data from a register into\nmemory. The specific operation is determined by the word width (size) and\nmemory ordering semantics (acquire, release). The memory address is computed\nby adding the immediate offset (imm) to the value in register rs1, and the\ndata is taken from register rs2.\n "
},
{
  "mnemonic": "sh1add",
  "name": "shift left by 1 and add",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zba" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let shamt : bits(2) = match op {\n    RISCV_SH1ADD => 0b01,\n    RISCV_SH2ADD => 0b10,\n    RISCV_SH3ADD => 0b11\n  };\n  let result : xlenbits = (rs1_val << shamt) + rs2_val;\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sh1add.uw",
  "name": "shift unsigned word left by 1 and add",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [ "Zba" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let shamt : bits(2) = match op {\n    RISCV_ADDUW    => 0b00,\n    RISCV_SH1ADDUW => 0b01,\n    RISCV_SH2ADDUW => 0b10,\n    RISCV_SH3ADDUW => 0b11\n  };\n  let result : xlenbits = (zero_extend(rs1_val[31..0]) << shamt) + rs2_val;\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sh2add",
  "name": "shift left by 2 and add",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zba" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let shamt : bits(2) = match op {\n    RISCV_SH1ADD => 0b01,\n    RISCV_SH2ADD => 0b10,\n    RISCV_SH3ADD => 0b11\n  };\n  let result : xlenbits = (rs1_val << shamt) + rs2_val;\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sh2add.uw",
  "name": "shift unsigned word left by 2 and add",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [ "Zba" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let shamt : bits(2) = match op {\n    RISCV_ADDUW    => 0b00,\n    RISCV_SH1ADDUW => 0b01,\n    RISCV_SH2ADDUW => 0b10,\n    RISCV_SH3ADDUW => 0b11\n  };\n  let result : xlenbits = (zero_extend(rs1_val[31..0]) << shamt) + rs2_val;\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sh3add",
  "name": "shift left by 3 and add",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zba" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let shamt : bits(2) = match op {\n    RISCV_SH1ADD => 0b01,\n    RISCV_SH2ADD => 0b10,\n    RISCV_SH3ADD => 0b11\n  };\n  let result : xlenbits = (rs1_val << shamt) + rs2_val;\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sh3add.uw",
  "name": "shift unsigned word left by 3 and add",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [ "Zba" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let shamt : bits(2) = match op {\n    RISCV_ADDUW    => 0b00,\n    RISCV_SH1ADDUW => 0b01,\n    RISCV_SH2ADDUW => 0b10,\n    RISCV_SH3ADDUW => 0b11\n  };\n  let result : xlenbits = (zero_extend(rs1_val[31..0]) << shamt) + rs2_val;\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sha256sig0",
  "name": "SHA2-256 Sigma0",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b00", "size": 2 }, { "field": "0b01000", "size": 5 }, { "field": "0b00010", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zknh" ],
  "function": "{\n  let inb    : bits(32) = X(rs1)[31..0];\n  let result : bits(32) = (inb >>> 7) ^ (inb >>> 18) ^ (inb >>  3);\n  X(rd)      = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sha256sig1",
  "name": "SHA2-256 Sigma1",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b00", "size": 2 }, { "field": "0b01000", "size": 5 }, { "field": "0b00011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zknh" ],
  "function": "{\n  let inb    : bits(32) = X(rs1)[31..0];\n  let result : bits(32) = (inb >>> 17) ^ (inb >>> 19) ^ (inb >> 10);\n  X(rd)      = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sha256sum0",
  "name": "SHA2-256 Sum0",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b00", "size": 2 }, { "field": "0b01000", "size": 5 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zknh" ],
  "function": "{\n  let inb    : bits(32) = X(rs1)[31..0];\n  let result : bits(32) = (inb >>> 2) ^ (inb >>> 13) ^ (inb >>> 22);\n  X(rd)      = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sha256sum1",
  "name": "SHA2-256 Sum1",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b00", "size": 2 }, { "field": "0b01000", "size": 5 }, { "field": "0b00001", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zknh" ],
  "function": "{\n  let inb    : bits(32) = X(rs1)[31..0];\n  let result : bits(32) = (inb >>> 6) ^ (inb >>> 11) ^ (inb >>> 25);\n  X(rd)      = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sha512sig0",
  "name": "SHA2-512 Sigma0",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b00", "size": 2 }, { "field": "0b01000", "size": 5 }, { "field": "0b00110", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zknh" ],
  "function": "{\n  assert(sizeof(xlen) == 64);\n  let input  : bits(64) = X(rs1);\n  let result : bits(64) = (input >>>  1) ^ (input >>>  8) ^ (input >> 7);\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sha512sig0h",
  "name": "SHA2-512 Sigma0 high",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b01", "size": 2 }, { "field": "0b01110", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zknh" ],
  "function": "{\n  X(rd) = sign_extend((X(rs1) >>  1) ^ (X(rs1) >>  7) ^ (X(rs1) >>  8) ^\n               (X(rs2) << 31)                  ^ (X(rs2) << 24));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sha512sig0l",
  "name": "SHA2-512 Sigma0 low",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b01", "size": 2 }, { "field": "0b01010", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zknh" ],
  "function": "{\n  X(rd) = sign_extend((X(rs1) >>  1) ^ (X(rs1) >>  7) ^ (X(rs1) >>  8) ^\n               (X(rs2) << 31) ^ (X(rs2) << 25) ^ (X(rs2) << 24));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sha512sig1",
  "name": "SHA2-512 Sigma1",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b00", "size": 2 }, { "field": "0b01000", "size": 5 }, { "field": "0b00111", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zknh" ],
  "function": "{\n  assert(sizeof(xlen) == 64);\n  let input  : bits(64) = X(rs1);\n  let result : bits(64) = (input >>> 19) ^ (input >>> 61) ^ (input >> 6);\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sha512sig1h",
  "name": "SHA2-512 Sigma1 high",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b01", "size": 2 }, { "field": "0b01111", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zknh" ],
  "function": "{\n  X(rd) = sign_extend((X(rs1) <<  3) ^ (X(rs1) >>  6) ^ (X(rs1) >> 19) ^\n               (X(rs2) >> 29)                  ^ (X(rs2) << 13));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sha512sig1l",
  "name": "SHA2-512 Sigma1 low",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b01", "size": 2 }, { "field": "0b01011", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zknh" ],
  "function": "{\n  X(rd) = sign_extend((X(rs1) <<  3) ^ (X(rs1) >>  6) ^ (X(rs1) >> 19) ^\n               (X(rs2) >> 29) ^ (X(rs2) << 26) ^ (X(rs2) << 13));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sha512sum0",
  "name": "SHA2-512 Sum0 (RV64)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b00", "size": 2 }, { "field": "0b01000", "size": 5 }, { "field": "0b00100", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zknh" ],
  "function": "{\n  assert(sizeof(xlen) == 64);\n  let input  : bits(64) = X(rs1);\n  let result : bits(64) = (input >>> 28) ^ (input >>> 34) ^ (input >>> 39);\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sha512sum0r",
  "name": "SHA2-512 Sum0 (RV32)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b01", "size": 2 }, { "field": "0b01000", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zknh" ],
  "function": "{\n  X(rd) = sign_extend((X(rs1) << 25) ^ (X(rs1) << 30) ^ (X(rs1) >> 28) ^\n               (X(rs2) >>  7) ^ (X(rs2) >>  2) ^ (X(rs2) <<  4));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sha512sum1",
  "name": "SHA2-512 Sum1 (RV64)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b00", "size": 2 }, { "field": "0b01000", "size": 5 }, { "field": "0b00101", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zknh" ],
  "function": "{\n  assert(sizeof(xlen) == 64);\n  let input  : bits(64) = X(rs1);\n  let result : bits(64) = (input >>> 14) ^ (input >>> 18) ^ (input >>> 41);\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sha512sum1r",
  "name": "SHA2-512 Sum1 (RV32)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b01", "size": 2 }, { "field": "0b01001", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zknh" ],
  "function": "{\n  X(rd) = sign_extend((X(rs1) << 23) ^ (X(rs1) >> 14) ^ (X(rs1) >> 18) ^\n               (X(rs2) >>  9) ^ (X(rs2) << 18) ^ (X(rs2) << 14));\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sinval.vma",
  "name": "TBD",
  "operands": [ { "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0001011", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b1110011", "size": 7 } ],
  "extensions": [ "Svinval" ],
  "function": "{\n  execute(SFENCE_VMA(rs1, rs2))\n}",
  "description": "TBD"
},
{
  "mnemonic": "sll",
  "name": "shift left (logical)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ADD  => rs1_val + rs2_val,\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\n    RISCV_AND  => rs1_val & rs2_val,\n    RISCV_OR   => rs1_val | rs2_val,\n    RISCV_XOR  => rs1_val ^ rs2_val,\n    RISCV_SLL  => if   sizeof(xlen) == 32\n                  then rs1_val << (rs2_val[4..0])\n                  else rs1_val << (rs2_val[5..0]),\n    RISCV_SRL  => if   sizeof(xlen) == 32\n                  then rs1_val >> (rs2_val[4..0])\n                  else rs1_val >> (rs2_val[5..0]),\n    RISCV_SUB  => rs1_val - rs2_val,\n    RISCV_SRA  => if   sizeof(xlen) == 32\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe R-type (Register-type) instruction format is used for operations\nthat involve three registers. The specific operation is determined\nby the opcode and funct7 fields. The result is written to the\ndestination register (rd), and the source operands are specified\nby the source registers (rs1 and rs2). The format is common for\narithmetic, logical, and shift operations.\n "
},
{
  "mnemonic": "slli",
  "name": "shift immediate",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "shamt", "type": "bits(6)", "optional": false } ],
  "syntax": "rd,rs1,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b010000", "size": 6 }, { "field": "shamt", "size": 6 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  /* the decoder guard should ensure that shamt[5] = 0 for RV32 */\n  let result : xlenbits = match op {\n    RISCV_SLLI => if   sizeof(xlen) == 32\n                  then rs1_val << shamt[4..0]\n                  else rs1_val << shamt,\n    RISCV_SRLI => if   sizeof(xlen) == 32\n                  then rs1_val >> shamt[4..0]\n                  else rs1_val >> shamt,\n    RISCV_SRAI => if   sizeof(xlen) == 32\n                  then shift_right_arith32(rs1_val, shamt[4..0])\n                  else shift_right_arith64(rs1_val, shamt)\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe SHIFTIOP (Shift Immediate Operation) instruction format is used for\noperations that involve shifting the bits of a register by an immediate\nvalue. The specific operation is determined by the opcode field, and the\nshift amount is specified by the immediate value (shamt). The result is\nwritten to the destination register (rd), and the source operand is the\nregister specified by rs1. The format is common for shift-left logical\nimmediate (SLLI), shift-right logical immediate (SRLI), and shift-right\narithmetic immediate (SRAI) operations.\n\nNote: For RV32, the decoder ensures that shamt[5] = 0.\n "
},
{
  "mnemonic": "slli.uw",
  "name": "shift-left unsigned word (immediate)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "shamt", "type": "bits(6)", "optional": false } ],
  "syntax": "rd,rs1,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b000010", "size": 6 }, { "field": "shamt", "size": 6 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0011011", "size": 7 } ],
  "extensions": [ "Zba" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let result : xlenbits = zero_extend(rs1_val[31..0]) << shamt;\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "slliw",
  "name": "shift immediate word",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "shamt", "type": "bits(5)", "optional": false } ],
  "syntax": "rd,rs1,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "shamt", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0011011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = (X(rs1))[31..0];\n  let result : bits(32) = match op {\n    RISCV_SLLIW => rs1_val << shamt,\n    RISCV_SRLIW => rs1_val >> shamt,\n    RISCV_SRAIW => shift_right_arith32(rs1_val, shamt)\n  };\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "\nThe SHIFTIWOP instruction set deals with\nimmediate shift operations on 32-bit values, with the result sign-extended\nto 64 bits. The available operations include SLLIW (left shift logical\nimmediate word), SRLIW (right shift logical immediate word), and SRAIW\n(right shift arithmetic immediate word). These operations are applicable\nwhen the target architecture has a width of 64 bits.\n "
},
{
  "mnemonic": "sllw",
  "name": "shift left (logical) word (RV64)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = (X(rs1))[31..0];\n  let rs2_val = (X(rs2))[31..0];\n  let result : bits(32) = match op {\n    RISCV_ADDW => rs1_val + rs2_val,\n    RISCV_SUBW => rs1_val - rs2_val,\n    RISCV_SLLW => rs1_val << (rs2_val[4..0]),\n    RISCV_SRLW => rs1_val >> (rs2_val[4..0]),\n    RISCV_SRAW => shift_right_arith32(rs1_val, rs2_val[4..0])\n  };\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "\nThe RTYPEW instruction set operates on 32-bit values,\nand the result is sign-extended to 64 bits. The available operations are\nADDW (addition), SUBW (subtraction), SLLW (logical left shift),\nSRLW (logical right shift), and SRAW (arithmetic right shift).\nThese operations are only applicable when the width of the target\narchitecture is 64 bits.\n "
},
{
  "mnemonic": "slt",
  "name": "set less than",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ADD  => rs1_val + rs2_val,\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\n    RISCV_AND  => rs1_val & rs2_val,\n    RISCV_OR   => rs1_val | rs2_val,\n    RISCV_XOR  => rs1_val ^ rs2_val,\n    RISCV_SLL  => if   sizeof(xlen) == 32\n                  then rs1_val << (rs2_val[4..0])\n                  else rs1_val << (rs2_val[5..0]),\n    RISCV_SRL  => if   sizeof(xlen) == 32\n                  then rs1_val >> (rs2_val[4..0])\n                  else rs1_val >> (rs2_val[5..0]),\n    RISCV_SUB  => rs1_val - rs2_val,\n    RISCV_SRA  => if   sizeof(xlen) == 32\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe R-type (Register-type) instruction format is used for operations\nthat involve three registers. The specific operation is determined\nby the opcode and funct7 fields. The result is written to the\ndestination register (rd), and the source operands are specified\nby the source registers (rs1 and rs2). The format is common for\narithmetic, logical, and shift operations.\n "
},
{
  "mnemonic": "slti",
  "name": "set less than immediate",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false } ],
  "syntax": "rd,rs1,imm",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "encdec_iop(op)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let immext : xlenbits = sign_extend(imm);\n  let result : xlenbits = match op {\n    RISCV_ADDI  => rs1_val + immext,\n    RISCV_SLTI  => zero_extend(bool_to_bits(rs1_val <_s immext)),\n    RISCV_SLTIU => zero_extend(bool_to_bits(rs1_val <_u immext)),\n    RISCV_ANDI  => rs1_val & immext,\n    RISCV_ORI   => rs1_val | immext,\n    RISCV_XORI  => rs1_val ^ immext\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe ITYPE instruction operates on an immediate value, adding, comparing, or\nperforming bitwise operations with the contents of register rs1.\nThe immediate value, rs1, and the operation code (iop) determine the operation.\nThe result is stored in register rd.\nThe supported immediate operations (iop) include:\n  - \"addi\"  : Add immediate\n  - \"slti\"  : Set less than immediate (signed)\n  - \"sltiu\" : Set less than immediate (unsigned)\n  - \"andi\"  : AND immediate\n  - \"ori\"   : OR immediate\n  - \"xori\"  : XOR immediate\n\nNote: The immediate value is sign-extended before performing the operation.\n "
},
{
  "mnemonic": "sltiu",
  "name": "set less than immediate unsigned",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false } ],
  "syntax": "rd,rs1,imm",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "encdec_iop(op)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let immext : xlenbits = sign_extend(imm);\n  let result : xlenbits = match op {\n    RISCV_ADDI  => rs1_val + immext,\n    RISCV_SLTI  => zero_extend(bool_to_bits(rs1_val <_s immext)),\n    RISCV_SLTIU => zero_extend(bool_to_bits(rs1_val <_u immext)),\n    RISCV_ANDI  => rs1_val & immext,\n    RISCV_ORI   => rs1_val | immext,\n    RISCV_XORI  => rs1_val ^ immext\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe ITYPE instruction operates on an immediate value, adding, comparing, or\nperforming bitwise operations with the contents of register rs1.\nThe immediate value, rs1, and the operation code (iop) determine the operation.\nThe result is stored in register rd.\nThe supported immediate operations (iop) include:\n  - \"addi\"  : Add immediate\n  - \"slti\"  : Set less than immediate (signed)\n  - \"sltiu\" : Set less than immediate (unsigned)\n  - \"andi\"  : AND immediate\n  - \"ori\"   : OR immediate\n  - \"xori\"  : XOR immediate\n\nNote: The immediate value is sign-extended before performing the operation.\n "
},
{
  "mnemonic": "sltu",
  "name": "set less than (unsigned)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ADD  => rs1_val + rs2_val,\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\n    RISCV_AND  => rs1_val & rs2_val,\n    RISCV_OR   => rs1_val | rs2_val,\n    RISCV_XOR  => rs1_val ^ rs2_val,\n    RISCV_SLL  => if   sizeof(xlen) == 32\n                  then rs1_val << (rs2_val[4..0])\n                  else rs1_val << (rs2_val[5..0]),\n    RISCV_SRL  => if   sizeof(xlen) == 32\n                  then rs1_val >> (rs2_val[4..0])\n                  else rs1_val >> (rs2_val[5..0]),\n    RISCV_SUB  => rs1_val - rs2_val,\n    RISCV_SRA  => if   sizeof(xlen) == 32\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe R-type (Register-type) instruction format is used for operations\nthat involve three registers. The specific operation is determined\nby the opcode and funct7 fields. The result is written to the\ndestination register (rd), and the source operands are specified\nby the source registers (rs1 and rs2). The format is common for\narithmetic, logical, and shift operations.\n "
},
{
  "mnemonic": "sm3p0",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b00", "size": 2 }, { "field": "0b01000", "size": 5 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zksh" ],
  "function": "{\n  let r1     : bits(32) = X(rs1)[31..0];\n  let result : bits(32) =  r1 ^ (r1 <<< 9) ^ (r1 <<< 17);\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sm3p1",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b00", "size": 2 }, { "field": "0b01000", "size": 5 }, { "field": "0b01001", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zksh" ],
  "function": "{\n  let r1     : bits(32) = X(rs1)[31..0];\n  let result : bits(32) =  r1 ^ (r1 <<< 15) ^ (r1 <<< 23);\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sm4ed",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "bs", "type": "bits(2)", "optional": false } ],
  "syntax": "rd,rs1,rs2,bs",
  "format": "TBD",
  "fields": [ { "field": "bs", "size": 2 }, { "field": "0b11000", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zksed" ],
  "function": "{\n  let shamt : bits(5)  = bs @ 0b000; /* shamt = bs*8 */\n  let sb_in : bits(8)  = (X(rs2)[31..0] >> shamt)[7..0];\n  let x     : bits(32) = 0x000000 @ sm4_sbox(sb_in);\n  let y     : bits(32) = x ^ (x               <<  8) ^ ( x               <<  2) ^\n                             (x               << 18) ^ ((x & 0x0000003F) << 26) ^\n                             ((x & 0x000000C0) << 10);\n  let z     : bits(32) = (y <<< shamt);\n  let result : bits(32) = z ^ X(rs1)[31..0];\n  X(rd)                = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sm4ks",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "bs", "type": "bits(2)", "optional": false } ],
  "syntax": "rd,rs1,rs2,bs",
  "format": "TBD",
  "fields": [ { "field": "bs", "size": 2 }, { "field": "0b11010", "size": 5 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zksed" ],
  "function": "{\n  let shamt : bits(5)  = (bs @ 0b000); /* shamt = bs*8 */\n  let sb_in : bits(8)  = (X(rs2)[31..0] >> shamt)[7..0];\n  let x     : bits(32) = 0x000000 @ sm4_sbox(sb_in);\n  let y     : bits(32) = x ^ ((x & 0x00000007) << 29) ^ ((x & 0x000000FE) <<  7) ^\n                             ((x & 0x00000001) << 23) ^ ((x & 0x000000F8) << 13) ;\n  let z     : bits(32) = (y <<< shamt);\n  let result : bits(32) = z ^ X(rs1)[31..0];\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "sra",
  "name": "shift right (arithmetic)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ADD  => rs1_val + rs2_val,\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\n    RISCV_AND  => rs1_val & rs2_val,\n    RISCV_OR   => rs1_val | rs2_val,\n    RISCV_XOR  => rs1_val ^ rs2_val,\n    RISCV_SLL  => if   sizeof(xlen) == 32\n                  then rs1_val << (rs2_val[4..0])\n                  else rs1_val << (rs2_val[5..0]),\n    RISCV_SRL  => if   sizeof(xlen) == 32\n                  then rs1_val >> (rs2_val[4..0])\n                  else rs1_val >> (rs2_val[5..0]),\n    RISCV_SUB  => rs1_val - rs2_val,\n    RISCV_SRA  => if   sizeof(xlen) == 32\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe R-type (Register-type) instruction format is used for operations\nthat involve three registers. The specific operation is determined\nby the opcode and funct7 fields. The result is written to the\ndestination register (rd), and the source operands are specified\nby the source registers (rs1 and rs2). The format is common for\narithmetic, logical, and shift operations.\n "
},
{
  "mnemonic": "srai",
  "name": "shift immediate",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "shamt", "type": "bits(6)", "optional": false } ],
  "syntax": "rd,rs1,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b010000", "size": 6 }, { "field": "shamt", "size": 6 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  /* the decoder guard should ensure that shamt[5] = 0 for RV32 */\n  let result : xlenbits = match op {\n    RISCV_SLLI => if   sizeof(xlen) == 32\n                  then rs1_val << shamt[4..0]\n                  else rs1_val << shamt,\n    RISCV_SRLI => if   sizeof(xlen) == 32\n                  then rs1_val >> shamt[4..0]\n                  else rs1_val >> shamt,\n    RISCV_SRAI => if   sizeof(xlen) == 32\n                  then shift_right_arith32(rs1_val, shamt[4..0])\n                  else shift_right_arith64(rs1_val, shamt)\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe SHIFTIOP (Shift Immediate Operation) instruction format is used for\noperations that involve shifting the bits of a register by an immediate\nvalue. The specific operation is determined by the opcode field, and the\nshift amount is specified by the immediate value (shamt). The result is\nwritten to the destination register (rd), and the source operand is the\nregister specified by rs1. The format is common for shift-left logical\nimmediate (SLLI), shift-right logical immediate (SRLI), and shift-right\narithmetic immediate (SRAI) operations.\n\nNote: For RV32, the decoder ensures that shamt[5] = 0.\n "
},
{
  "mnemonic": "sraiw",
  "name": "shift immediate word",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "shamt", "type": "bits(5)", "optional": false } ],
  "syntax": "rd,rs1,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "shamt", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0011011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = (X(rs1))[31..0];\n  let result : bits(32) = match op {\n    RISCV_SLLIW => rs1_val << shamt,\n    RISCV_SRLIW => rs1_val >> shamt,\n    RISCV_SRAIW => shift_right_arith32(rs1_val, shamt)\n  };\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "\nThe SHIFTIWOP instruction set deals with\nimmediate shift operations on 32-bit values, with the result sign-extended\nto 64 bits. The available operations include SLLIW (left shift logical\nimmediate word), SRLIW (right shift logical immediate word), and SRAIW\n(right shift arithmetic immediate word). These operations are applicable\nwhen the target architecture has a width of 64 bits.\n "
},
{
  "mnemonic": "sraw",
  "name": "shift right (arithmetic) word (RV64)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = (X(rs1))[31..0];\n  let rs2_val = (X(rs2))[31..0];\n  let result : bits(32) = match op {\n    RISCV_ADDW => rs1_val + rs2_val,\n    RISCV_SUBW => rs1_val - rs2_val,\n    RISCV_SLLW => rs1_val << (rs2_val[4..0]),\n    RISCV_SRLW => rs1_val >> (rs2_val[4..0]),\n    RISCV_SRAW => shift_right_arith32(rs1_val, rs2_val[4..0])\n  };\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "\nThe RTYPEW instruction set operates on 32-bit values,\nand the result is sign-extended to 64 bits. The available operations are\nADDW (addition), SUBW (subtraction), SLLW (logical left shift),\nSRLW (logical right shift), and SRAW (arithmetic right shift).\nThese operations are only applicable when the width of the target\narchitecture is 64 bits.\n "
},
{
  "mnemonic": "sret",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "0b0001000", "size": 7 }, { "field": "0b00010", "size": 5 }, { "field": "0b00000", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b1110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let sret_illegal : bool = match cur_privilege {\n    User       => true,\n    Supervisor => not(extensionEnabled(Ext_S)) | mstatus[TSR] == 0b1,\n    Machine    => not(extensionEnabled(Ext_S))\n  };\n  if   sret_illegal\n  then { handle_illegal(); RETIRE_FAIL }\n  else if not(ext_check_xret_priv (Supervisor))\n  then { ext_fail_xret_priv(); RETIRE_FAIL }\n  else {\n    set_next_pc(exception_handler(cur_privilege, CTL_SRET(), PC));\n    RETIRE_SUCCESS\n  }\n}",
  "description": "TBD"
},
{
  "mnemonic": "srl",
  "name": "shift right (logical)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ADD  => rs1_val + rs2_val,\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\n    RISCV_AND  => rs1_val & rs2_val,\n    RISCV_OR   => rs1_val | rs2_val,\n    RISCV_XOR  => rs1_val ^ rs2_val,\n    RISCV_SLL  => if   sizeof(xlen) == 32\n                  then rs1_val << (rs2_val[4..0])\n                  else rs1_val << (rs2_val[5..0]),\n    RISCV_SRL  => if   sizeof(xlen) == 32\n                  then rs1_val >> (rs2_val[4..0])\n                  else rs1_val >> (rs2_val[5..0]),\n    RISCV_SUB  => rs1_val - rs2_val,\n    RISCV_SRA  => if   sizeof(xlen) == 32\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe R-type (Register-type) instruction format is used for operations\nthat involve three registers. The specific operation is determined\nby the opcode and funct7 fields. The result is written to the\ndestination register (rd), and the source operands are specified\nby the source registers (rs1 and rs2). The format is common for\narithmetic, logical, and shift operations.\n "
},
{
  "mnemonic": "srli",
  "name": "shift immediate",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "shamt", "type": "bits(6)", "optional": false } ],
  "syntax": "rd,rs1,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b010000", "size": 6 }, { "field": "shamt", "size": 6 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  /* the decoder guard should ensure that shamt[5] = 0 for RV32 */\n  let result : xlenbits = match op {\n    RISCV_SLLI => if   sizeof(xlen) == 32\n                  then rs1_val << shamt[4..0]\n                  else rs1_val << shamt,\n    RISCV_SRLI => if   sizeof(xlen) == 32\n                  then rs1_val >> shamt[4..0]\n                  else rs1_val >> shamt,\n    RISCV_SRAI => if   sizeof(xlen) == 32\n                  then shift_right_arith32(rs1_val, shamt[4..0])\n                  else shift_right_arith64(rs1_val, shamt)\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe SHIFTIOP (Shift Immediate Operation) instruction format is used for\noperations that involve shifting the bits of a register by an immediate\nvalue. The specific operation is determined by the opcode field, and the\nshift amount is specified by the immediate value (shamt). The result is\nwritten to the destination register (rd), and the source operand is the\nregister specified by rs1. The format is common for shift-left logical\nimmediate (SLLI), shift-right logical immediate (SRLI), and shift-right\narithmetic immediate (SRAI) operations.\n\nNote: For RV32, the decoder ensures that shamt[5] = 0.\n "
},
{
  "mnemonic": "srliw",
  "name": "shift immediate word",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "shamt", "type": "bits(5)", "optional": false } ],
  "syntax": "rd,rs1,shamt",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "shamt", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0011011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = (X(rs1))[31..0];\n  let result : bits(32) = match op {\n    RISCV_SLLIW => rs1_val << shamt,\n    RISCV_SRLIW => rs1_val >> shamt,\n    RISCV_SRAIW => shift_right_arith32(rs1_val, shamt)\n  };\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "\nThe SHIFTIWOP instruction set deals with\nimmediate shift operations on 32-bit values, with the result sign-extended\nto 64 bits. The available operations include SLLIW (left shift logical\nimmediate word), SRLIW (right shift logical immediate word), and SRAIW\n(right shift arithmetic immediate word). These operations are applicable\nwhen the target architecture has a width of 64 bits.\n "
},
{
  "mnemonic": "srlw",
  "name": "shift right (logical) word (RV64)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = (X(rs1))[31..0];\n  let rs2_val = (X(rs2))[31..0];\n  let result : bits(32) = match op {\n    RISCV_ADDW => rs1_val + rs2_val,\n    RISCV_SUBW => rs1_val - rs2_val,\n    RISCV_SLLW => rs1_val << (rs2_val[4..0]),\n    RISCV_SRLW => rs1_val >> (rs2_val[4..0]),\n    RISCV_SRAW => shift_right_arith32(rs1_val, rs2_val[4..0])\n  };\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "\nThe RTYPEW instruction set operates on 32-bit values,\nand the result is sign-extended to 64 bits. The available operations are\nADDW (addition), SUBW (subtraction), SLLW (logical left shift),\nSRLW (logical right shift), and SRAW (arithmetic right shift).\nThese operations are only applicable when the width of the target\narchitecture is 64 bits.\n "
},
{
  "mnemonic": "sub",
  "name": "subtract",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ADD  => rs1_val + rs2_val,\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\n    RISCV_AND  => rs1_val & rs2_val,\n    RISCV_OR   => rs1_val | rs2_val,\n    RISCV_XOR  => rs1_val ^ rs2_val,\n    RISCV_SLL  => if   sizeof(xlen) == 32\n                  then rs1_val << (rs2_val[4..0])\n                  else rs1_val << (rs2_val[5..0]),\n    RISCV_SRL  => if   sizeof(xlen) == 32\n                  then rs1_val >> (rs2_val[4..0])\n                  else rs1_val >> (rs2_val[5..0]),\n    RISCV_SUB  => rs1_val - rs2_val,\n    RISCV_SRA  => if   sizeof(xlen) == 32\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe R-type (Register-type) instruction format is used for operations\nthat involve three registers. The specific operation is determined\nby the opcode and funct7 fields. The result is written to the\ndestination register (rd), and the source operands are specified\nby the source registers (rs1 and rs2). The format is common for\narithmetic, logical, and shift operations.\n "
},
{
  "mnemonic": "subw",
  "name": "subtract word (RV64)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = (X(rs1))[31..0];\n  let rs2_val = (X(rs2))[31..0];\n  let result : bits(32) = match op {\n    RISCV_ADDW => rs1_val + rs2_val,\n    RISCV_SUBW => rs1_val - rs2_val,\n    RISCV_SLLW => rs1_val << (rs2_val[4..0]),\n    RISCV_SRLW => rs1_val >> (rs2_val[4..0]),\n    RISCV_SRAW => shift_right_arith32(rs1_val, rs2_val[4..0])\n  };\n  X(rd) = sign_extend(result);\n  RETIRE_SUCCESS\n}",
  "description": "\nThe RTYPEW instruction set operates on 32-bit values,\nand the result is sign-extended to 64 bits. The available operations are\nADDW (addition), SUBW (subtraction), SLLW (logical left shift),\nSRLW (logical right shift), and SRAW (arithmetic right shift).\nThese operations are only applicable when the width of the target\narchitecture is 64 bits.\n "
},
{
  "mnemonic": "sw",
  "name": "store",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "imm5", "size": 1 }, { "field": "0b0100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) => {\n          let eares = mem_write_ea(paddr, width_bytes, aq, rl, false);\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = X(rs2);\n              match mem_write_value(paddr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq, rl, false) {\n                MemValue(true)  => RETIRE_SUCCESS,\n                MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n              }\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "\nThe STORE instruction format is used for storing data from a register into\nmemory. The specific operation is determined by the word width (size) and\nmemory ordering semantics (acquire, release). The memory address is computed\nby adding the immediate offset (imm) to the value in register rs1, and the\ndata is taken from register rs2.\n "
},
{
  "mnemonic": "sw.aq",
  "name": "store",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "imm5", "size": 1 }, { "field": "0b0100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) => {\n          let eares = mem_write_ea(paddr, width_bytes, aq, rl, false);\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = X(rs2);\n              match mem_write_value(paddr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq, rl, false) {\n                MemValue(true)  => RETIRE_SUCCESS,\n                MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n              }\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "\nThe STORE instruction format is used for storing data from a register into\nmemory. The specific operation is determined by the word width (size) and\nmemory ordering semantics (acquire, release). The memory address is computed\nby adding the immediate offset (imm) to the value in register rs1, and the\ndata is taken from register rs2.\n "
},
{
  "mnemonic": "sw.aq.rl",
  "name": "store",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "imm5", "size": 1 }, { "field": "0b0100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) => {\n          let eares = mem_write_ea(paddr, width_bytes, aq, rl, false);\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = X(rs2);\n              match mem_write_value(paddr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq, rl, false) {\n                MemValue(true)  => RETIRE_SUCCESS,\n                MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n              }\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "\nThe STORE instruction format is used for storing data from a register into\nmemory. The specific operation is determined by the word width (size) and\nmemory ordering semantics (acquire, release). The memory address is computed\nby adding the immediate offset (imm) to the value in register rs1, and the\ndata is taken from register rs2.\n "
},
{
  "mnemonic": "sw.rl",
  "name": "store",
  "operands": [ { "name": "rs2", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rs2,imm(rs1)",
  "format": "TBD",
  "fields": [ { "field": "imm7", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b0", "size": 1 }, { "field": "size_enc(size)", "size": 2 }, { "field": "imm5", "size": 1 }, { "field": "0b0100011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let offset : xlenbits = sign_extend(imm);\n  let width_bytes = size_bytes(width);\n\n  // This is checked during decoding.\n  assert(width_bytes <= sizeof(xlen_bytes));\n\n  /* Get the address, X(rs1) + offset.\n     Some extensions perform additional checks on address validity. */\n  match ext_data_get_addr(rs1, offset, Write(Data), width_bytes) {\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) =>\n      if   check_misaligned(vaddr, width)\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\n      else match translateAddr(vaddr, Write(Data)) {\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n        TR_Address(paddr, _) => {\n          let eares = mem_write_ea(paddr, width_bytes, aq, rl, false);\n          match (eares) {\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\n            MemValue(_) => {\n              let rs2_val = X(rs2);\n              match mem_write_value(paddr, width_bytes, rs2_val[width_bytes * 8 - 1 .. 0], aq, rl, false) {\n                MemValue(true)  => RETIRE_SUCCESS,\n                MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n              }\n            }\n          }\n        }\n      }\n  }\n}",
  "description": "\nThe STORE instruction format is used for storing data from a register into\nmemory. The specific operation is determined by the word width (size) and\nmemory ordering semantics (acquire, release). The memory address is computed\nby adding the immediate offset (imm) to the value in register rs1, and the\ndata is taken from register rs2.\n "
},
{
  "mnemonic": "unzip",
  "name": "bit deinterleave",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b000010001111", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zbkb" ],
  "function": "{\n  assert(sizeof(xlen) == 32);\n  let rs1_val = X(rs1);\n  var result : xlenbits = zeros();\n  foreach (i from 0 to (sizeof(xlen_bytes)*4 - 1)) {\n    result[i] = rs1_val[i*2];\n    result[i + sizeof(xlen_bytes)*4] = rs1_val[i*2 + 1];\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "uret",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "0b0000000", "size": 7 }, { "field": "0b00010", "size": 5 }, { "field": "0b00000", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b1110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  if   not(extensionEnabled(Ext_U)) | not(sys_enable_next())\n  then handle_illegal()\n  else if not(ext_check_xret_priv(User))\n  then ext_fail_xret_priv()\n  else set_next_pc(exception_handler(cur_privilege, CTL_URET(), PC));\n  RETIRE_FAIL\n}",
  "description": "TBD"
},
{
  "mnemonic": "vaadd.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVV_VAADDU   => {\n                          let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VAADD    => {\n                          let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUBU   => {\n                          let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUB    => {\n                          let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VDIVU    => {\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          to_bits(SEW, q)\n                        },\n        MVV_VDIV     => {\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* check for signed overflow */\n                          let q' : int = if q > elem_max then elem_min else q;\n                          to_bits(SEW, q')\n                        },\n        MVV_VREMU    => {\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        },\n        MVV_VREM     => {\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vaadd.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VAADDU       => {\n                              let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VAADD        => {\n                              let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUBU       => {\n                              let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUB        => {\n                              let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VSLIDE1UP    => {\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        MVX_VSLIDE1DOWN  => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            },\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VDIVU        => {\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\n                              to_bits(SEW, q)\n                            },\n        MVX_VDIV         => {\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* check for signed overflow */\n                              let q' : int = if q > elem_max then elem_min else q;\n                              to_bits(SEW, q')\n                            },\n        MVX_VREMU        => {\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            },\n        MVX_VREM         => {\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vaaddu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVV_VAADDU   => {\n                          let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VAADD    => {\n                          let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUBU   => {\n                          let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUB    => {\n                          let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VDIVU    => {\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          to_bits(SEW, q)\n                        },\n        MVV_VDIV     => {\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* check for signed overflow */\n                          let q' : int = if q > elem_max then elem_min else q;\n                          to_bits(SEW, q')\n                        },\n        MVV_VREMU    => {\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        },\n        MVV_VREM     => {\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vaaddu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VAADDU       => {\n                              let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VAADD        => {\n                              let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUBU       => {\n                              let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUB        => {\n                              let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VSLIDE1UP    => {\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        MVX_VSLIDE1DOWN  => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            },\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VDIVU        => {\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\n                              to_bits(SEW, q)\n                            },\n        MVX_VDIV         => {\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* check for signed overflow */\n                              let q' : int = if q > elem_max then elem_min else q;\n                              to_bits(SEW, q')\n                            },\n        MVX_VREMU        => {\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            },\n        MVX_VREM         => {\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vadc.vim",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,simm,v0",
  "format": "TBD",
  "fields": [ { "field": "encdec_vimsfunct6(funct6)", "size": 6 }, { "field": "0b0", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  /* for bypassing normal masking in init_masked_result */\n  var vec_trues : vector('n, dec, bool) = undefined;\n  foreach (i from 0 to (num_elem - 1)) {\n    vec_trues[i] = true\n  };\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VIMS_VADC     => to_bits(SEW, unsigned(vs2_val[i]) + unsigned(imm_val) + unsigned(bool_to_bits(vm_val[i])))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vadc.vvm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,vs1,v0",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvmsfunct6(funct6)", "size": 6 }, { "field": "0b0", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  /* for bypassing normal masking in init_masked_result */\n  var vec_trues : vector('n, dec, bool) = undefined;\n  foreach (i from 0 to (num_elem - 1)) {\n    vec_trues[i] = true\n  };\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VVMS_VADC     => to_bits(SEW, unsigned(vs2_val[i]) + unsigned(vs1_val[i]) + unsigned(bool_to_bits(vm_val[i]))),\n        VVMS_VSBC     => to_bits(SEW, unsigned(vs2_val[i]) - unsigned(vs1_val[i]) - unsigned(bool_to_bits(vm_val[i])))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vadc.vxm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,rs1,v0",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxmsfunct6(funct6)", "size": 6 }, { "field": "0b0", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  /* for bypassing normal masking in init_masked_result */\n  var vec_trues : vector('n, dec, bool) = undefined;\n  foreach (i from 0 to (num_elem - 1)) {\n    vec_trues[i] = true\n  };\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VXMS_VADC     => to_bits(SEW, unsigned(vs2_val[i]) + unsigned(rs1_val) + unsigned(bool_to_bits(vm_val[i]))),\n        VXMS_VSBC     => to_bits(SEW, unsigned(vs2_val[i]) - unsigned(rs1_val) - unsigned(bool_to_bits(vm_val[i])))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vadd.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vifunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VI_VADD    => vs2_val[i] + imm_val,\n        VI_VRSUB   => imm_val - vs2_val[i],\n        VI_VAND    => vs2_val[i] & imm_val,\n        VI_VOR     => vs2_val[i] | imm_val,\n        VI_VXOR    => vs2_val[i] ^ imm_val,\n        VI_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, imm_val) ),\n        VI_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, imm_val) ),\n        VI_VSLL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VI_VSRL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VI_VSRA    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VI_VSSRL   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VI_VSSRA   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vadd.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vadd.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vand.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vifunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VI_VADD    => vs2_val[i] + imm_val,\n        VI_VRSUB   => imm_val - vs2_val[i],\n        VI_VAND    => vs2_val[i] & imm_val,\n        VI_VOR     => vs2_val[i] | imm_val,\n        VI_VXOR    => vs2_val[i] ^ imm_val,\n        VI_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, imm_val) ),\n        VI_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, imm_val) ),\n        VI_VSLL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VI_VSRL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VI_VSRA    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VI_VSSRL   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VI_VSSRA   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vand.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vand.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vasub.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVV_VAADDU   => {\n                          let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VAADD    => {\n                          let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUBU   => {\n                          let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUB    => {\n                          let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VDIVU    => {\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          to_bits(SEW, q)\n                        },\n        MVV_VDIV     => {\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* check for signed overflow */\n                          let q' : int = if q > elem_max then elem_min else q;\n                          to_bits(SEW, q')\n                        },\n        MVV_VREMU    => {\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        },\n        MVV_VREM     => {\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vasub.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VAADDU       => {\n                              let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VAADD        => {\n                              let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUBU       => {\n                              let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUB        => {\n                              let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VSLIDE1UP    => {\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        MVX_VSLIDE1DOWN  => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            },\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VDIVU        => {\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\n                              to_bits(SEW, q)\n                            },\n        MVX_VDIV         => {\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* check for signed overflow */\n                              let q' : int = if q > elem_max then elem_min else q;\n                              to_bits(SEW, q')\n                            },\n        MVX_VREMU        => {\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            },\n        MVX_VREM         => {\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vasubu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVV_VAADDU   => {\n                          let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VAADD    => {\n                          let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUBU   => {\n                          let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUB    => {\n                          let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VDIVU    => {\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          to_bits(SEW, q)\n                        },\n        MVV_VDIV     => {\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* check for signed overflow */\n                          let q' : int = if q > elem_max then elem_min else q;\n                          to_bits(SEW, q')\n                        },\n        MVV_VREMU    => {\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        },\n        MVV_VREM     => {\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vasubu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VAADDU       => {\n                              let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VAADD        => {\n                              let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUBU       => {\n                              let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUB        => {\n                              let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VSLIDE1UP    => {\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        MVX_VSLIDE1DOWN  => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            },\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VDIVU        => {\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\n                              to_bits(SEW, q)\n                            },\n        MVX_VDIV         => {\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* check for signed overflow */\n                              let q' : int = if q > elem_max then elem_min else q;\n                              to_bits(SEW, q')\n                            },\n        MVX_VREMU        => {\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            },\n        MVX_VREM         => {\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vcompress.vm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,vs1",
  "format": "TBD",
  "fields": [ { "field": "0b010111", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let start_element = get_start_element();\n  let end_element = get_end_element();\n  let SEW = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  /* vcompress should always be executed with a vstart of 0 */\n  if start_element != 0 | vs1 == vd | vs2 == vd | illegal_vd_unmasked()\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vs1_val : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n\n  /* body elements */\n  var vd_idx : nat = 0;\n  foreach (i from 0 to (num_elem - 1)) {\n    if i <= end_element then {\n      if vs1_val[i] then {\n        let 'p = vd_idx;\n        assert('p < 'n);\n        result['p] = vs2_val[i];\n        vd_idx = vd_idx + 1;\n      }\n    }\n  };\n  /* tail elements */\n  if vd_idx < num_elem then {\n    let tail_ag : agtype = get_vtype_vta();\n    let 'p = vd_idx;\n    foreach (i from 'p to (num_elem - 1)) {\n      result[i] = match tail_ag {\n        UNDISTURBED => vd_val[i],\n        AGNOSTIC    => vd_val[i] /* TODO: configuration support */\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vdiv.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVV_VAADDU   => {\n                          let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VAADD    => {\n                          let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUBU   => {\n                          let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUB    => {\n                          let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VDIVU    => {\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          to_bits(SEW, q)\n                        },\n        MVV_VDIV     => {\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* check for signed overflow */\n                          let q' : int = if q > elem_max then elem_min else q;\n                          to_bits(SEW, q')\n                        },\n        MVV_VREMU    => {\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        },\n        MVV_VREM     => {\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vdiv.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VAADDU       => {\n                              let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VAADD        => {\n                              let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUBU       => {\n                              let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUB        => {\n                              let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VSLIDE1UP    => {\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        MVX_VSLIDE1DOWN  => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            },\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VDIVU        => {\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\n                              to_bits(SEW, q)\n                            },\n        MVX_VDIV         => {\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* check for signed overflow */\n                              let q' : int = if q > elem_max then elem_min else q;\n                              to_bits(SEW, q')\n                            },\n        MVX_VREMU        => {\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            },\n        MVX_VREM         => {\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vdivu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVV_VAADDU   => {\n                          let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VAADD    => {\n                          let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUBU   => {\n                          let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUB    => {\n                          let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VDIVU    => {\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          to_bits(SEW, q)\n                        },\n        MVV_VDIV     => {\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* check for signed overflow */\n                          let q' : int = if q > elem_max then elem_min else q;\n                          to_bits(SEW, q')\n                        },\n        MVV_VREMU    => {\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        },\n        MVV_VREM     => {\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vdivu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VAADDU       => {\n                              let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VAADD        => {\n                              let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUBU       => {\n                              let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUB        => {\n                              let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VSLIDE1UP    => {\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        MVX_VSLIDE1DOWN  => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            },\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VDIVU        => {\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\n                              to_bits(SEW, q)\n                            },\n        MVX_VDIV         => {\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* check for signed overflow */\n                              let q' : int = if q > elem_max then elem_min else q;\n                              to_bits(SEW, q')\n                            },\n        MVX_VREMU        => {\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            },\n        MVX_VREM         => {\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfadd.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\n        VF_VSGNJ         => [rs1_val['m - 1]] @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJN        => (0b1 ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJX        => ([vs2_val[i]['m - 1]] ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSLIDE1UP     => {\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        VF_VSLIDE1DOWN   => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfadd.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSGNJ    => [vs1_val[i]['m - 1]] @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJX   => ([vs2_val[i]['m - 1]] ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0]\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfclass.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010011", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfunary1_vs1(vfunary1)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfunary1 {\n        FVV_VSQRT      => {\n                            let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                              16  => riscv_f16Sqrt(rm_3b, vs2_val[i]),\n                              32  => riscv_f32Sqrt(rm_3b, vs2_val[i]),\n                              64  => riscv_f64Sqrt(rm_3b, vs2_val[i])\n                            };\n                            accrue_fflags(fflags);\n                            elem\n                          },\n        FVV_VRSQRT7    => {\n                            let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                              16  => riscv_f16Rsqrte7(rm_3b, vs2_val[i]),\n                              32  => riscv_f32Rsqrte7(rm_3b, vs2_val[i]),\n                              64  => riscv_f64Rsqrte7(rm_3b, vs2_val[i])\n                            };\n                            accrue_fflags(fflags);\n                            elem\n                          },\n        FVV_VREC7      => {\n                            let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                              16  => riscv_f16Recip7(rm_3b, vs2_val[i]),\n                              32  => riscv_f32Recip7(rm_3b, vs2_val[i]),\n                              64  => riscv_f64Recip7(rm_3b, vs2_val[i])\n                            };\n                            accrue_fflags(fflags);\n                            elem\n                          },\n        FVV_VCLASS     => fp_class(vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfcvt.f.x.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfunary0_vs1(vfunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfunary0 {\n        FV_CVT_XU_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToUi16(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToUi32(rm_3b, vs2_val[i]),\n                                64 => riscv_f64ToUi64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_X_F       => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToI16(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToI32(rm_3b, vs2_val[i]),\n                                64 => riscv_f64ToI64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_F_XU      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\n                                32 => riscv_ui32ToF32(rm_3b, vs2_val[i]),\n                                64 => riscv_ui64ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_F_X       => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\n                                32 => riscv_i32ToF32(rm_3b, vs2_val[i]),\n                                64 => riscv_i64ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_RTZ_XU_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToUi16(0b001, vs2_val[i]),\n                                32 => riscv_f32ToUi32(0b001, vs2_val[i]),\n                                64 => riscv_f64ToUi64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_RTZ_X_F   => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToI16(0b001, vs2_val[i]),\n                                32 => riscv_f32ToI32(0b001, vs2_val[i]),\n                                64 => riscv_f64ToI64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfcvt.f.xu.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfunary0_vs1(vfunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfunary0 {\n        FV_CVT_XU_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToUi16(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToUi32(rm_3b, vs2_val[i]),\n                                64 => riscv_f64ToUi64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_X_F       => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToI16(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToI32(rm_3b, vs2_val[i]),\n                                64 => riscv_f64ToI64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_F_XU      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\n                                32 => riscv_ui32ToF32(rm_3b, vs2_val[i]),\n                                64 => riscv_ui64ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_F_X       => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\n                                32 => riscv_i32ToF32(rm_3b, vs2_val[i]),\n                                64 => riscv_i64ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_RTZ_XU_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToUi16(0b001, vs2_val[i]),\n                                32 => riscv_f32ToUi32(0b001, vs2_val[i]),\n                                64 => riscv_f64ToUi64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_RTZ_X_F   => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToI16(0b001, vs2_val[i]),\n                                32 => riscv_f32ToI32(0b001, vs2_val[i]),\n                                64 => riscv_f64ToI64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfcvt.rtz.x.f.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfunary0_vs1(vfunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfunary0 {\n        FV_CVT_XU_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToUi16(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToUi32(rm_3b, vs2_val[i]),\n                                64 => riscv_f64ToUi64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_X_F       => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToI16(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToI32(rm_3b, vs2_val[i]),\n                                64 => riscv_f64ToI64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_F_XU      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\n                                32 => riscv_ui32ToF32(rm_3b, vs2_val[i]),\n                                64 => riscv_ui64ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_F_X       => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\n                                32 => riscv_i32ToF32(rm_3b, vs2_val[i]),\n                                64 => riscv_i64ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_RTZ_XU_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToUi16(0b001, vs2_val[i]),\n                                32 => riscv_f32ToUi32(0b001, vs2_val[i]),\n                                64 => riscv_f64ToUi64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_RTZ_X_F   => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToI16(0b001, vs2_val[i]),\n                                32 => riscv_f32ToI32(0b001, vs2_val[i]),\n                                64 => riscv_f64ToI64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfcvt.rtz.xu.f.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfunary0_vs1(vfunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfunary0 {\n        FV_CVT_XU_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToUi16(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToUi32(rm_3b, vs2_val[i]),\n                                64 => riscv_f64ToUi64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_X_F       => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToI16(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToI32(rm_3b, vs2_val[i]),\n                                64 => riscv_f64ToI64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_F_XU      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\n                                32 => riscv_ui32ToF32(rm_3b, vs2_val[i]),\n                                64 => riscv_ui64ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_F_X       => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\n                                32 => riscv_i32ToF32(rm_3b, vs2_val[i]),\n                                64 => riscv_i64ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_RTZ_XU_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToUi16(0b001, vs2_val[i]),\n                                32 => riscv_f32ToUi32(0b001, vs2_val[i]),\n                                64 => riscv_f64ToUi64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_RTZ_X_F   => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToI16(0b001, vs2_val[i]),\n                                32 => riscv_f32ToI32(0b001, vs2_val[i]),\n                                64 => riscv_f64ToI64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfcvt.x.f.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfunary0_vs1(vfunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfunary0 {\n        FV_CVT_XU_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToUi16(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToUi32(rm_3b, vs2_val[i]),\n                                64 => riscv_f64ToUi64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_X_F       => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToI16(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToI32(rm_3b, vs2_val[i]),\n                                64 => riscv_f64ToI64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_F_XU      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\n                                32 => riscv_ui32ToF32(rm_3b, vs2_val[i]),\n                                64 => riscv_ui64ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_F_X       => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\n                                32 => riscv_i32ToF32(rm_3b, vs2_val[i]),\n                                64 => riscv_i64ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_RTZ_XU_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToUi16(0b001, vs2_val[i]),\n                                32 => riscv_f32ToUi32(0b001, vs2_val[i]),\n                                64 => riscv_f64ToUi64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_RTZ_X_F   => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToI16(0b001, vs2_val[i]),\n                                32 => riscv_f32ToI32(0b001, vs2_val[i]),\n                                64 => riscv_f64ToI64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfcvt.xu.f.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfunary0_vs1(vfunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfunary0 {\n        FV_CVT_XU_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToUi16(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToUi32(rm_3b, vs2_val[i]),\n                                64 => riscv_f64ToUi64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_X_F       => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToI16(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToI32(rm_3b, vs2_val[i]),\n                                64 => riscv_f64ToI64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_F_XU      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\n                                32 => riscv_ui32ToF32(rm_3b, vs2_val[i]),\n                                64 => riscv_ui64ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_F_X       => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\n                                32 => riscv_i32ToF32(rm_3b, vs2_val[i]),\n                                64 => riscv_i64ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_RTZ_XU_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToUi16(0b001, vs2_val[i]),\n                                32 => riscv_f32ToUi32(0b001, vs2_val[i]),\n                                64 => riscv_f64ToUi64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FV_CVT_RTZ_X_F   => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                16 => riscv_f16ToI16(0b001, vs2_val[i]),\n                                32 => riscv_f32ToI32(0b001, vs2_val[i]),\n                                64 => riscv_f64ToI64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfdiv.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\n        VF_VSGNJ         => [rs1_val['m - 1]] @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJN        => (0b1 ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJX        => ([vs2_val[i]['m - 1]] ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSLIDE1UP     => {\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        VF_VSLIDE1DOWN   => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfdiv.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSGNJ    => [vs1_val[i]['m - 1]] @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJX   => ([vs2_val[i]['m - 1]] ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0]\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfirst.m",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "rd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010000", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "0b10001", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = unsigned(vlenb) * 8;\n\n  if illegal_vd_unmasked() | not(assert_vstart(0)) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\n  var result  : vector('n, dec, bool) = undefined;\n  var mask    : vector('n, dec, bool) = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vs2_val, vm_val);\n\n  var index : int = -1;\n  foreach (i from 0 to (num_elem - 1)) {\n    if index == -1 then {\n      if mask[i] & vs2_val[i] then index = i;\n    };\n  };\n\n  X(rd) = to_bits(sizeof(xlen), index);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmacc.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvfmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VMACC    => fp_muladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VNMACC   => fp_nmulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VMSAC    => fp_mulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VNMSAC   => fp_nmuladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VMADD    => fp_muladd(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VNMADD   => fp_nmulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VMSUB    => fp_mulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VNMSUB   => fp_nmuladd(rm_3b, rs1_val, vd_val[i], vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmacc.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VMACC    => fp_muladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VNMACC   => fp_nmulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VMSAC    => fp_mulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VNMSAC   => fp_nmuladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VMADD    => fp_muladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VNMADD   => fp_nmulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VMSUB    => fp_mulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VNMSUB   => fp_nmuladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmadd.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvfmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VMACC    => fp_muladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VNMACC   => fp_nmulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VMSAC    => fp_mulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VNMSAC   => fp_nmuladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VMADD    => fp_muladd(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VNMADD   => fp_nmulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VMSUB    => fp_mulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VNMSUB   => fp_nmuladd(rm_3b, rs1_val, vd_val[i], vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmadd.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VMACC    => fp_muladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VNMACC   => fp_nmulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VMSAC    => fp_mulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VNMSAC   => fp_nmuladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VMADD    => fp_muladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VNMADD   => fp_nmulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VMSUB    => fp_mulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VNMSUB   => fp_nmuladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmax.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\n        VF_VSGNJ         => [rs1_val['m - 1]] @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJN        => (0b1 ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJX        => ([vs2_val[i]['m - 1]] ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSLIDE1UP     => {\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        VF_VSLIDE1DOWN   => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmax.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSGNJ    => [vs1_val[i]['m - 1]] @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJX   => ([vs2_val[i]['m - 1]] ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0]\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmerge.vfm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,rs1,v0",
  "format": "TBD",
  "fields": [ { "field": "0b010111", "size": 6 }, { "field": "0b0", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b         = fcsr[FRM];\n  let start_element = get_start_element();\n  let end_element   = get_end_element();\n  let SEW           = get_sew();\n  let LMUL_pow      = get_lmul_pow();\n  let num_elem      = get_num_elem(LMUL_pow, SEW); /* max(VLMAX,VLEN/SEW)) */\n  let real_num_elem = if LMUL_pow >= 0 then num_elem else num_elem / (0 - LMUL_pow); /* VLMAX */\n\n  if illegal_fp_vd_masked(vd, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n\n  let tail_ag : agtype = get_vtype_vta();\n  foreach (i from 0 to (num_elem - 1)) {\n    if i < start_element then {\n      result[i] = vd_val[i]\n    } else if i > end_element | i >= real_num_elem then {\n      result[i] = match tail_ag {\n        UNDISTURBED => vd_val[i],\n        AGNOSTIC    => vd_val[i] /* TODO: configuration support */\n      }\n    } else {\n      /* the merge operates on all body elements */\n      result[i] = if vm_val[i] then rs1_val else vs2_val[i]\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmin.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\n        VF_VSGNJ         => [rs1_val['m - 1]] @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJN        => (0b1 ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJX        => ([vs2_val[i]['m - 1]] ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSLIDE1UP     => {\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        VF_VSLIDE1DOWN   => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmin.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSGNJ    => [vs1_val[i]['m - 1]] @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJX   => ([vs2_val[i]['m - 1]] ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0]\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmsac.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvfmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VMACC    => fp_muladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VNMACC   => fp_nmulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VMSAC    => fp_mulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VNMSAC   => fp_nmuladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VMADD    => fp_muladd(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VNMADD   => fp_nmulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VMSUB    => fp_mulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VNMSUB   => fp_nmuladd(rm_3b, rs1_val, vd_val[i], vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmsac.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VMACC    => fp_muladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VNMACC   => fp_nmulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VMSAC    => fp_mulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VNMSAC   => fp_nmuladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VMADD    => fp_muladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VNMADD   => fp_nmulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VMSUB    => fp_mulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VNMSUB   => fp_nmuladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmsub.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvfmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VMACC    => fp_muladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VNMACC   => fp_nmulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VMSAC    => fp_mulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VNMSAC   => fp_nmuladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VMADD    => fp_muladd(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VNMADD   => fp_nmulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VMSUB    => fp_mulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VNMSUB   => fp_nmuladd(rm_3b, rs1_val, vd_val[i], vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmsub.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VMACC    => fp_muladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VNMACC   => fp_nmulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VMSAC    => fp_mulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VNMSAC   => fp_nmuladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VMADD    => fp_muladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VNMADD   => fp_nmulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VMSUB    => fp_mulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VNMSUB   => fp_nmuladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmul.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\n        VF_VSGNJ         => [rs1_val['m - 1]] @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJN        => (0b1 ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJX        => ([vs2_val[i]['m - 1]] ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSLIDE1UP     => {\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        VF_VSLIDE1DOWN   => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmul.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSGNJ    => [vs1_val[i]['m - 1]] @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJX   => ([vs2_val[i]['m - 1]] ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0]\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmv.f.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,vs2",
  "format": "TBD",
  "fields": [ { "field": "0b010000", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "0b00000", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let num_elem = get_num_elem(0, SEW);\n\n  if illegal_fp_vd_unmasked(SEW, rm_3b) | SEW > sizeof(flen)\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(num_elem > 0 & SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, 0, vs2);\n  match 'm {\n    16 => F_H(rd) = vs2_val[0],\n    32 => F_S(rd) = vs2_val[0],\n    64 => F_D(rd) = vs2_val[0]\n  };\n  vstart = zeros();\n\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmv.s.f",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b010000", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let num_elem = get_num_elem(0, SEW);\n\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(num_elem > 0 & SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, 0, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, 0, vd_val, vm_val);\n\n  /* one body element */\n  if mask[0] then result[0] = rs1_val;\n\n  /* others treated as tail elements */\n  let tail_ag : agtype = get_vtype_vta();\n  foreach (i from 1 to (num_elem - 1)) {\n    result[i] = match tail_ag {\n      UNDISTURBED => vd_val[i],\n      AGNOSTIC    => vd_val[i] /* TODO: configuration support */\n    }\n  };\n\n  write_vreg(num_elem, SEW, 0, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfmv.v.f",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b010111", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then result[i] = rs1_val\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfncvt.f.f.w",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfnunary0_vs1(vfnunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfnunary0 {\n        FNV_CVT_XU_F     => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToUi8(rm_3b, vs2_val[i]),\n                                16 => riscv_f32ToUi16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToUi32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_X_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToI8(rm_3b, vs2_val[i]),\n                                16 => riscv_f32ToI16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToI32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_XU     => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_ui32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_ui64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_X      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_i32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_i64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_ROD_F_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f32ToF16(0b110, vs2_val[i]),\n                                32 => riscv_f64ToF32(0b110, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_RTZ_XU_F => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToUi8(0b001, vs2_val[i]),\n                                16 => riscv_f32ToUi16(0b001, vs2_val[i]),\n                                32 => riscv_f64ToUi32(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_RTZ_X_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToI8(0b001, vs2_val[i]),\n                                16 => riscv_f32ToI16(0b001, vs2_val[i]),\n                                32 => riscv_f64ToI32(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfncvt.f.x.w",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfnunary0_vs1(vfnunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfnunary0 {\n        FNV_CVT_XU_F     => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToUi8(rm_3b, vs2_val[i]),\n                                16 => riscv_f32ToUi16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToUi32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_X_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToI8(rm_3b, vs2_val[i]),\n                                16 => riscv_f32ToI16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToI32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_XU     => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_ui32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_ui64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_X      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_i32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_i64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_ROD_F_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f32ToF16(0b110, vs2_val[i]),\n                                32 => riscv_f64ToF32(0b110, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_RTZ_XU_F => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToUi8(0b001, vs2_val[i]),\n                                16 => riscv_f32ToUi16(0b001, vs2_val[i]),\n                                32 => riscv_f64ToUi32(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_RTZ_X_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToI8(0b001, vs2_val[i]),\n                                16 => riscv_f32ToI16(0b001, vs2_val[i]),\n                                32 => riscv_f64ToI32(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfncvt.f.xu.w",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfnunary0_vs1(vfnunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfnunary0 {\n        FNV_CVT_XU_F     => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToUi8(rm_3b, vs2_val[i]),\n                                16 => riscv_f32ToUi16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToUi32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_X_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToI8(rm_3b, vs2_val[i]),\n                                16 => riscv_f32ToI16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToI32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_XU     => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_ui32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_ui64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_X      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_i32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_i64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_ROD_F_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f32ToF16(0b110, vs2_val[i]),\n                                32 => riscv_f64ToF32(0b110, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_RTZ_XU_F => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToUi8(0b001, vs2_val[i]),\n                                16 => riscv_f32ToUi16(0b001, vs2_val[i]),\n                                32 => riscv_f64ToUi32(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_RTZ_X_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToI8(0b001, vs2_val[i]),\n                                16 => riscv_f32ToI16(0b001, vs2_val[i]),\n                                32 => riscv_f64ToI32(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfncvt.rod.f.f.w",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfnunary0_vs1(vfnunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfnunary0 {\n        FNV_CVT_XU_F     => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToUi8(rm_3b, vs2_val[i]),\n                                16 => riscv_f32ToUi16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToUi32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_X_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToI8(rm_3b, vs2_val[i]),\n                                16 => riscv_f32ToI16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToI32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_XU     => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_ui32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_ui64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_X      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_i32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_i64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_ROD_F_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f32ToF16(0b110, vs2_val[i]),\n                                32 => riscv_f64ToF32(0b110, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_RTZ_XU_F => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToUi8(0b001, vs2_val[i]),\n                                16 => riscv_f32ToUi16(0b001, vs2_val[i]),\n                                32 => riscv_f64ToUi32(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_RTZ_X_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToI8(0b001, vs2_val[i]),\n                                16 => riscv_f32ToI16(0b001, vs2_val[i]),\n                                32 => riscv_f64ToI32(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfncvt.rtz.x.f.w",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfnunary0_vs1(vfnunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfnunary0 {\n        FNV_CVT_XU_F     => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToUi8(rm_3b, vs2_val[i]),\n                                16 => riscv_f32ToUi16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToUi32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_X_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToI8(rm_3b, vs2_val[i]),\n                                16 => riscv_f32ToI16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToI32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_XU     => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_ui32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_ui64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_X      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_i32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_i64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_ROD_F_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f32ToF16(0b110, vs2_val[i]),\n                                32 => riscv_f64ToF32(0b110, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_RTZ_XU_F => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToUi8(0b001, vs2_val[i]),\n                                16 => riscv_f32ToUi16(0b001, vs2_val[i]),\n                                32 => riscv_f64ToUi32(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_RTZ_X_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToI8(0b001, vs2_val[i]),\n                                16 => riscv_f32ToI16(0b001, vs2_val[i]),\n                                32 => riscv_f64ToI32(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfncvt.rtz.xu.f.w",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfnunary0_vs1(vfnunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfnunary0 {\n        FNV_CVT_XU_F     => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToUi8(rm_3b, vs2_val[i]),\n                                16 => riscv_f32ToUi16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToUi32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_X_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToI8(rm_3b, vs2_val[i]),\n                                16 => riscv_f32ToI16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToI32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_XU     => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_ui32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_ui64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_X      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_i32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_i64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_ROD_F_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f32ToF16(0b110, vs2_val[i]),\n                                32 => riscv_f64ToF32(0b110, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_RTZ_XU_F => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToUi8(0b001, vs2_val[i]),\n                                16 => riscv_f32ToUi16(0b001, vs2_val[i]),\n                                32 => riscv_f64ToUi32(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_RTZ_X_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToI8(0b001, vs2_val[i]),\n                                16 => riscv_f32ToI16(0b001, vs2_val[i]),\n                                32 => riscv_f64ToI32(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfncvt.x.f.w",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfnunary0_vs1(vfnunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfnunary0 {\n        FNV_CVT_XU_F     => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToUi8(rm_3b, vs2_val[i]),\n                                16 => riscv_f32ToUi16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToUi32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_X_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToI8(rm_3b, vs2_val[i]),\n                                16 => riscv_f32ToI16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToI32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_XU     => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_ui32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_ui64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_X      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_i32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_i64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_ROD_F_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f32ToF16(0b110, vs2_val[i]),\n                                32 => riscv_f64ToF32(0b110, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_RTZ_XU_F => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToUi8(0b001, vs2_val[i]),\n                                16 => riscv_f32ToUi16(0b001, vs2_val[i]),\n                                32 => riscv_f64ToUi32(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_RTZ_X_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToI8(0b001, vs2_val[i]),\n                                16 => riscv_f32ToI16(0b001, vs2_val[i]),\n                                32 => riscv_f64ToI32(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfncvt.xu.f.w",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfnunary0_vs1(vfnunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfnunary0 {\n        FNV_CVT_XU_F     => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToUi8(rm_3b, vs2_val[i]),\n                                16 => riscv_f32ToUi16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToUi32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_X_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToI8(rm_3b, vs2_val[i]),\n                                16 => riscv_f32ToI16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToI32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_XU     => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_ui32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_ui64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_X      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_i32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_i64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_F_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f32ToF16(rm_3b, vs2_val[i]),\n                                32 => riscv_f64ToF32(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_ROD_F_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f32ToF16(0b110, vs2_val[i]),\n                                32 => riscv_f64ToF32(0b110, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_RTZ_XU_F => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToUi8(0b001, vs2_val[i]),\n                                16 => riscv_f32ToUi16(0b001, vs2_val[i]),\n                                32 => riscv_f64ToUi32(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FNV_CVT_RTZ_X_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                                8  => riscv_f16ToI8(0b001, vs2_val[i]),\n                                16 => riscv_f32ToI16(0b001, vs2_val[i]),\n                                32 => riscv_f64ToI32(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfnmacc.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvfmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VMACC    => fp_muladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VNMACC   => fp_nmulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VMSAC    => fp_mulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VNMSAC   => fp_nmuladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VMADD    => fp_muladd(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VNMADD   => fp_nmulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VMSUB    => fp_mulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VNMSUB   => fp_nmuladd(rm_3b, rs1_val, vd_val[i], vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfnmacc.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VMACC    => fp_muladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VNMACC   => fp_nmulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VMSAC    => fp_mulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VNMSAC   => fp_nmuladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VMADD    => fp_muladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VNMADD   => fp_nmulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VMSUB    => fp_mulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VNMSUB   => fp_nmuladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfnmadd.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvfmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VMACC    => fp_muladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VNMACC   => fp_nmulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VMSAC    => fp_mulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VNMSAC   => fp_nmuladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VMADD    => fp_muladd(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VNMADD   => fp_nmulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VMSUB    => fp_mulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VNMSUB   => fp_nmuladd(rm_3b, rs1_val, vd_val[i], vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfnmadd.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VMACC    => fp_muladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VNMACC   => fp_nmulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VMSAC    => fp_mulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VNMSAC   => fp_nmuladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VMADD    => fp_muladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VNMADD   => fp_nmulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VMSUB    => fp_mulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VNMSUB   => fp_nmuladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfnmsac.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvfmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VMACC    => fp_muladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VNMACC   => fp_nmulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VMSAC    => fp_mulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VNMSAC   => fp_nmuladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VMADD    => fp_muladd(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VNMADD   => fp_nmulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VMSUB    => fp_mulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VNMSUB   => fp_nmuladd(rm_3b, rs1_val, vd_val[i], vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfnmsac.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VMACC    => fp_muladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VNMACC   => fp_nmulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VMSAC    => fp_mulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VNMSAC   => fp_nmuladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VMADD    => fp_muladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VNMADD   => fp_nmulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VMSUB    => fp_mulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VNMSUB   => fp_nmuladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfnmsub.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvfmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VMACC    => fp_muladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VNMACC   => fp_nmulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VMSAC    => fp_mulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VNMSAC   => fp_nmuladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\n        VF_VMADD    => fp_muladd(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VNMADD   => fp_nmulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VMSUB    => fp_mulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\n        VF_VNMSUB   => fp_nmuladd(rm_3b, rs1_val, vd_val[i], vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfnmsub.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VMACC    => fp_muladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VNMACC   => fp_nmulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VMSAC    => fp_mulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VNMSAC   => fp_nmuladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\n        FVV_VMADD    => fp_muladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VNMADD   => fp_nmulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VMSUB    => fp_mulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\n        FVV_VNMSUB   => fp_nmuladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfrdiv.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\n        VF_VSGNJ         => [rs1_val['m - 1]] @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJN        => (0b1 ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJX        => ([vs2_val[i]['m - 1]] ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSLIDE1UP     => {\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        VF_VSLIDE1DOWN   => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfrec7.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010011", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfunary1_vs1(vfunary1)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfunary1 {\n        FVV_VSQRT      => {\n                            let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                              16  => riscv_f16Sqrt(rm_3b, vs2_val[i]),\n                              32  => riscv_f32Sqrt(rm_3b, vs2_val[i]),\n                              64  => riscv_f64Sqrt(rm_3b, vs2_val[i])\n                            };\n                            accrue_fflags(fflags);\n                            elem\n                          },\n        FVV_VRSQRT7    => {\n                            let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                              16  => riscv_f16Rsqrte7(rm_3b, vs2_val[i]),\n                              32  => riscv_f32Rsqrte7(rm_3b, vs2_val[i]),\n                              64  => riscv_f64Rsqrte7(rm_3b, vs2_val[i])\n                            };\n                            accrue_fflags(fflags);\n                            elem\n                          },\n        FVV_VREC7      => {\n                            let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                              16  => riscv_f16Recip7(rm_3b, vs2_val[i]),\n                              32  => riscv_f32Recip7(rm_3b, vs2_val[i]),\n                              64  => riscv_f64Recip7(rm_3b, vs2_val[i])\n                            };\n                            accrue_fflags(fflags);\n                            elem\n                          },\n        FVV_VCLASS     => fp_class(vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfredmax.vs",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_rfvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\n\n  if funct6 == FVV_VFWREDOSUM | funct6 == FVV_VFWREDUSUM then\n    process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\n  else\n    process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfredmin.vs",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_rfvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\n\n  if funct6 == FVV_VFWREDOSUM | funct6 == FVV_VFWREDUSUM then\n    process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\n  else\n    process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfredosum.vs",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_rfvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\n\n  if funct6 == FVV_VFWREDOSUM | funct6 == FVV_VFWREDUSUM then\n    process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\n  else\n    process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfredusum.vs",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_rfvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\n\n  if funct6 == FVV_VFWREDOSUM | funct6 == FVV_VFWREDUSUM then\n    process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\n  else\n    process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfrsqrt7.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010011", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfunary1_vs1(vfunary1)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfunary1 {\n        FVV_VSQRT      => {\n                            let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                              16  => riscv_f16Sqrt(rm_3b, vs2_val[i]),\n                              32  => riscv_f32Sqrt(rm_3b, vs2_val[i]),\n                              64  => riscv_f64Sqrt(rm_3b, vs2_val[i])\n                            };\n                            accrue_fflags(fflags);\n                            elem\n                          },\n        FVV_VRSQRT7    => {\n                            let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                              16  => riscv_f16Rsqrte7(rm_3b, vs2_val[i]),\n                              32  => riscv_f32Rsqrte7(rm_3b, vs2_val[i]),\n                              64  => riscv_f64Rsqrte7(rm_3b, vs2_val[i])\n                            };\n                            accrue_fflags(fflags);\n                            elem\n                          },\n        FVV_VREC7      => {\n                            let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                              16  => riscv_f16Recip7(rm_3b, vs2_val[i]),\n                              32  => riscv_f32Recip7(rm_3b, vs2_val[i]),\n                              64  => riscv_f64Recip7(rm_3b, vs2_val[i])\n                            };\n                            accrue_fflags(fflags);\n                            elem\n                          },\n        FVV_VCLASS     => fp_class(vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfrsub.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\n        VF_VSGNJ         => [rs1_val['m - 1]] @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJN        => (0b1 ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJX        => ([vs2_val[i]['m - 1]] ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSLIDE1UP     => {\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        VF_VSLIDE1DOWN   => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfsgnj.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\n        VF_VSGNJ         => [rs1_val['m - 1]] @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJN        => (0b1 ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJX        => ([vs2_val[i]['m - 1]] ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSLIDE1UP     => {\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        VF_VSLIDE1DOWN   => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfsgnj.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSGNJ    => [vs1_val[i]['m - 1]] @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJX   => ([vs2_val[i]['m - 1]] ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0]\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfsgnjn.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\n        VF_VSGNJ         => [rs1_val['m - 1]] @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJN        => (0b1 ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJX        => ([vs2_val[i]['m - 1]] ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSLIDE1UP     => {\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        VF_VSLIDE1DOWN   => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfsgnjn.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSGNJ    => [vs1_val[i]['m - 1]] @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJX   => ([vs2_val[i]['m - 1]] ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0]\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfsgnjx.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\n        VF_VSGNJ         => [rs1_val['m - 1]] @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJN        => (0b1 ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJX        => ([vs2_val[i]['m - 1]] ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSLIDE1UP     => {\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        VF_VSLIDE1DOWN   => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfsgnjx.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSGNJ    => [vs1_val[i]['m - 1]] @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJX   => ([vs2_val[i]['m - 1]] ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0]\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfslide1down.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\n        VF_VSGNJ         => [rs1_val['m - 1]] @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJN        => (0b1 ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJX        => ([vs2_val[i]['m - 1]] ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSLIDE1UP     => {\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        VF_VSLIDE1DOWN   => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfslide1up.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\n        VF_VSGNJ         => [rs1_val['m - 1]] @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJN        => (0b1 ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJX        => ([vs2_val[i]['m - 1]] ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSLIDE1UP     => {\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        VF_VSLIDE1DOWN   => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfsqrt.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010011", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfunary1_vs1(vfunary1)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfunary1 {\n        FVV_VSQRT      => {\n                            let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                              16  => riscv_f16Sqrt(rm_3b, vs2_val[i]),\n                              32  => riscv_f32Sqrt(rm_3b, vs2_val[i]),\n                              64  => riscv_f64Sqrt(rm_3b, vs2_val[i])\n                            };\n                            accrue_fflags(fflags);\n                            elem\n                          },\n        FVV_VRSQRT7    => {\n                            let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                              16  => riscv_f16Rsqrte7(rm_3b, vs2_val[i]),\n                              32  => riscv_f32Rsqrte7(rm_3b, vs2_val[i]),\n                              64  => riscv_f64Rsqrte7(rm_3b, vs2_val[i])\n                            };\n                            accrue_fflags(fflags);\n                            elem\n                          },\n        FVV_VREC7      => {\n                            let (fflags, elem) : (bits_fflags, bits('m)) = match 'm {\n                              16  => riscv_f16Recip7(rm_3b, vs2_val[i]),\n                              32  => riscv_f32Recip7(rm_3b, vs2_val[i]),\n                              64  => riscv_f64Recip7(rm_3b, vs2_val[i])\n                            };\n                            accrue_fflags(fflags);\n                            elem\n                          },\n        FVV_VCLASS     => fp_class(vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfsub.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\n        VF_VSGNJ         => [rs1_val['m - 1]] @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJN        => (0b1 ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSGNJX        => ([vs2_val[i]['m - 1]] ^ [rs1_val['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        VF_VSLIDE1UP     => {\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        VF_VSLIDE1DOWN   => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfsub.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\n        FVV_VSGNJ    => [vs1_val[i]['m - 1]] @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0],\n        FVV_VSGNJX   => ([vs2_val[i]['m - 1]] ^ [vs1_val[i]['m - 1]]) @ vs2_val[i][('m - 2)..0]\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwadd.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwvffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWVF_VADD    => fp_add(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val)),\n        FWVF_VSUB    => fp_sub(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val)),\n        FWVF_VMUL    => fp_mul(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwadd.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWVV_VADD    => fp_add(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i])),\n        FWVV_VSUB    => fp_sub(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i])),\n        FWVV_VMUL    => fp_mul(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i]))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwadd.wf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen)\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWF_VADD     => fp_add(rm_3b, vs2_val[i], fp_widen(rs1_val)),\n        FWF_VSUB     => fp_sub(rm_3b, vs2_val[i], fp_widen(rs1_val))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwadd.wv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWV_VADD     => fp_add(rm_3b, vs2_val[i], fp_widen(vs1_val[i])),\n        FWV_VSUB     => fp_sub(rm_3b, vs2_val[i], fp_widen(vs1_val[i]))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwcvt.f.f.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfwunary0_vs1(vfwunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 8 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfwunary0 {\n        FWV_CVT_XU_F     => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToUi32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToUi64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_X_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToI32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToI64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_XU     => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\n                                16 => riscv_ui32ToF32(rm_3b, zero_extend(vs2_val[i])),\n                                32 => riscv_ui32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_X      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\n                                16 => riscv_i32ToF32(rm_3b, sign_extend(vs2_val[i])),\n                                32 => riscv_i32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToF32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_RTZ_XU_F => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToUi32(0b001, vs2_val[i]),\n                                32 => riscv_f32ToUi64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_RTZ_X_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToI32(0b001, vs2_val[i]),\n                                32 => riscv_f32ToI64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwcvt.f.x.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfwunary0_vs1(vfwunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 8 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfwunary0 {\n        FWV_CVT_XU_F     => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToUi32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToUi64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_X_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToI32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToI64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_XU     => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\n                                16 => riscv_ui32ToF32(rm_3b, zero_extend(vs2_val[i])),\n                                32 => riscv_ui32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_X      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\n                                16 => riscv_i32ToF32(rm_3b, sign_extend(vs2_val[i])),\n                                32 => riscv_i32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToF32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_RTZ_XU_F => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToUi32(0b001, vs2_val[i]),\n                                32 => riscv_f32ToUi64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_RTZ_X_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToI32(0b001, vs2_val[i]),\n                                32 => riscv_f32ToI64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwcvt.f.xu.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfwunary0_vs1(vfwunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 8 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfwunary0 {\n        FWV_CVT_XU_F     => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToUi32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToUi64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_X_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToI32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToI64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_XU     => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\n                                16 => riscv_ui32ToF32(rm_3b, zero_extend(vs2_val[i])),\n                                32 => riscv_ui32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_X      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\n                                16 => riscv_i32ToF32(rm_3b, sign_extend(vs2_val[i])),\n                                32 => riscv_i32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToF32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_RTZ_XU_F => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToUi32(0b001, vs2_val[i]),\n                                32 => riscv_f32ToUi64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_RTZ_X_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToI32(0b001, vs2_val[i]),\n                                32 => riscv_f32ToI64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwcvt.rtz.x.f.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfwunary0_vs1(vfwunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 8 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfwunary0 {\n        FWV_CVT_XU_F     => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToUi32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToUi64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_X_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToI32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToI64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_XU     => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\n                                16 => riscv_ui32ToF32(rm_3b, zero_extend(vs2_val[i])),\n                                32 => riscv_ui32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_X      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\n                                16 => riscv_i32ToF32(rm_3b, sign_extend(vs2_val[i])),\n                                32 => riscv_i32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToF32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_RTZ_XU_F => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToUi32(0b001, vs2_val[i]),\n                                32 => riscv_f32ToUi64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_RTZ_X_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToI32(0b001, vs2_val[i]),\n                                32 => riscv_f32ToI64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwcvt.rtz.xu.f.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfwunary0_vs1(vfwunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 8 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfwunary0 {\n        FWV_CVT_XU_F     => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToUi32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToUi64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_X_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToI32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToI64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_XU     => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\n                                16 => riscv_ui32ToF32(rm_3b, zero_extend(vs2_val[i])),\n                                32 => riscv_ui32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_X      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\n                                16 => riscv_i32ToF32(rm_3b, sign_extend(vs2_val[i])),\n                                32 => riscv_i32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToF32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_RTZ_XU_F => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToUi32(0b001, vs2_val[i]),\n                                32 => riscv_f32ToUi64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_RTZ_X_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToI32(0b001, vs2_val[i]),\n                                32 => riscv_f32ToI64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwcvt.x.f.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfwunary0_vs1(vfwunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 8 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfwunary0 {\n        FWV_CVT_XU_F     => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToUi32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToUi64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_X_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToI32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToI64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_XU     => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\n                                16 => riscv_ui32ToF32(rm_3b, zero_extend(vs2_val[i])),\n                                32 => riscv_ui32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_X      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\n                                16 => riscv_i32ToF32(rm_3b, sign_extend(vs2_val[i])),\n                                32 => riscv_i32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToF32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_RTZ_XU_F => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToUi32(0b001, vs2_val[i]),\n                                32 => riscv_f32ToUi64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_RTZ_X_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToI32(0b001, vs2_val[i]),\n                                32 => riscv_f32ToI64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwcvt.xu.f.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "encdec_vfwunary0_vs1(vfwunary0)", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 8 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match vfwunary0 {\n        FWV_CVT_XU_F     => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToUi32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToUi64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_X_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToI32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToI64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_XU     => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\n                                16 => riscv_ui32ToF32(rm_3b, zero_extend(vs2_val[i])),\n                                32 => riscv_ui32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_X      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\n                                16 => riscv_i32ToF32(rm_3b, sign_extend(vs2_val[i])),\n                                32 => riscv_i32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_F_F      => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToF32(rm_3b, vs2_val[i]),\n                                32 => riscv_f32ToF64(rm_3b, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_RTZ_XU_F => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToUi32(0b001, vs2_val[i]),\n                                32 => riscv_f32ToUi64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            },\n        FWV_CVT_RTZ_X_F  => {\n                              let (fflags, elem) : (bits_fflags, bits('o)) = match 'm {\n                                8  => { handle_illegal(); return RETIRE_FAIL },\n                                16 => riscv_f16ToI32(0b001, vs2_val[i]),\n                                32 => riscv_f32ToI64(0b001, vs2_val[i])\n                              };\n                              accrue_fflags(fflags);\n                              elem\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwmacc.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwvfmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWVF_VMACC   => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVF_VNMACC  => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVF_VMSAC   => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVF_VNMSAC  => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwmacc.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwvvmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs1", "size": 5 }, { "field": "vs2", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWVV_VMACC   => fp_muladd(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVV_VNMACC  => fp_nmulsub(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVV_VMSAC   => fp_mulsub(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVV_VNMSAC  => fp_nmuladd(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwmsac.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwvfmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWVF_VMACC   => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVF_VNMACC  => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVF_VMSAC   => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVF_VNMSAC  => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwmsac.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwvvmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs1", "size": 5 }, { "field": "vs2", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWVV_VMACC   => fp_muladd(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVV_VNMACC  => fp_nmulsub(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVV_VMSAC   => fp_mulsub(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVV_VNMSAC  => fp_nmuladd(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwmul.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwvffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWVF_VADD    => fp_add(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val)),\n        FWVF_VSUB    => fp_sub(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val)),\n        FWVF_VMUL    => fp_mul(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwmul.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWVV_VADD    => fp_add(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i])),\n        FWVV_VSUB    => fp_sub(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i])),\n        FWVV_VMUL    => fp_mul(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i]))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwnmacc.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwvfmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWVF_VMACC   => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVF_VNMACC  => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVF_VMSAC   => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVF_VNMSAC  => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwnmacc.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwvvmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs1", "size": 5 }, { "field": "vs2", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWVV_VMACC   => fp_muladd(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVV_VNMACC  => fp_nmulsub(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVV_VMSAC   => fp_mulsub(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVV_VNMSAC  => fp_nmuladd(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwnmsac.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwvfmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWVF_VMACC   => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVF_VNMACC  => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVF_VMSAC   => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVF_VNMSAC  => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwnmsac.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwvvmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs1", "size": 5 }, { "field": "vs2", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWVV_VMACC   => fp_muladd(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVV_VNMACC  => fp_nmulsub(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVV_VMSAC   => fp_mulsub(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\n        FWVV_VNMSAC  => fp_nmuladd(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwredosum.vs",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_rfvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\n\n  if funct6 == FVV_VFWREDOSUM | funct6 == FVV_VFWREDUSUM then\n    process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\n  else\n    process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwredusum.vs",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_rfvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\n\n  if funct6 == FVV_VFWREDOSUM | funct6 == FVV_VFWREDUSUM then\n    process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\n  else\n    process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwsub.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwvffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWVF_VADD    => fp_add(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val)),\n        FWVF_VSUB    => fp_sub(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val)),\n        FWVF_VMUL    => fp_mul(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwsub.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWVV_VADD    => fp_add(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i])),\n        FWVV_VSUB    => fp_sub(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i])),\n        FWVV_VMUL    => fp_mul(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i]))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwsub.wf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwffunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen)\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWF_VADD     => fp_add(rm_3b, vs2_val[i], fp_widen(rs1_val)),\n        FWF_VSUB     => fp_sub(rm_3b, vs2_val[i], fp_widen(rs1_val))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vfwsub.wv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fwvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        FWV_VADD     => fp_add(rm_3b, vs2_val[i], fp_widen(vs1_val[i])),\n        FWV_VSUB     => fp_sub(rm_3b, vs2_val[i], fp_widen(vs1_val[i]))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vid.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vdvm",
  "format": "TBD",
  "fields": [ { "field": "0b010100", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "0b10001", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then result[i] = to_bits(SEW, i)\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "viota.m",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010100", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "0b10000", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) | not(assert_vstart(0)) | vd == vs2\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  var sum : int = 0;\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = to_bits(SEW, sum);\n      if vs2_val[i] then sum = sum + 1\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vle16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vle16ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vle32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vle32ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vle64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vle64ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vle8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vle8ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlm.v",
  "name": "TBD",
  "operands": [ { "name": "vd_or_vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd_or_vs3,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b000", "size": 3 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd_or_vs3", "size": 5 }, { "field": "encdec_lsop(op)", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW = 8;\n  let EMUL_pow = 0;\n  let vl_val = unsigned(vl);\n  let evl : int = if vl_val % 8 == 0 then vl_val / 8 else vl_val / 8 + 1; /* the effective vector length is evl=ceil(vl/8) */\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  assert(evl >= 0);\n  process_vm(vd_or_vs3, rs1, num_elem, evl, op)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxei16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxei32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxei64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxei8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg2ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg2ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg2ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg2ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg3ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg3ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg3ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg3ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg4ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg4ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg4ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg4ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg5ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg5ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg5ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg5ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg6ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg6ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg6ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg6ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg7ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg7ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg7ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg7ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg8ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg8ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg8ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vloxseg8ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b11", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlre16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlre32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlre64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlre8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlse16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlse32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlse64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlse8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg2e16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg2e16ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg2e32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg2e32ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg2e64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg2e64ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg2e8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg2e8ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg2re16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg2re32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg2re64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg2re8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg3e16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg3e16ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg3e32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg3e32ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg3e64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg3e64ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg3e8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg3e8ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg3re16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg3re32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg3re64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg3re8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg4e16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg4e16ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg4e32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg4e32ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg4e64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg4e64ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg4e8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg4e8ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg4re16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg4re32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg4re64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg4re8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg5e16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg5e16ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg5e32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg5e32ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg5e64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg5e64ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg5e8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg5e8ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg5re16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg5re32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg5re64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg5re8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg6e16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg6e16ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg6e32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg6e32ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg6e64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg6e64ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg6e8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg6e8ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg6re16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg6re32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg6re64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg6re8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg7e16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg7e16ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg7e32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg7e32ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg7e64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg7e64ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg7e8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg7e8ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg7re16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg7re32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg7re64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg7re8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg8e16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg8e16ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg8e32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg8e32ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg8e64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg8e64ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg8e8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg8e8ff.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b10000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg8re16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg8re32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg8re64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlseg8re8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg2e16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg2e32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg2e64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg2e8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg3e16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg3e32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg3e64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg3e8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg4e16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg4e32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg4e64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg4e8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg5e16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg5e32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg5e64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg5e8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg6e16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg6e32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg6e64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg6e8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg7e16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg7e32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg7e64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg7e8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg8e16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg8e32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg8e64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vlsseg8e8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxei16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxei32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxei64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxei8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg2ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg2ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg2ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg2ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg3ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg3ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg3ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg3ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg4ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg4ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg4ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg4ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg5ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg5ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg5ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg5ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg6ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg6ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg6ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg6ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg7ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg7ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg7ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg7ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg8ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg8ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg8ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vluxseg8ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b0000111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmacc.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvvmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVV_VMACC  => get_slice_int(SEW, signed(vs1_val[i]) * signed(vs2_val[i]), 0) + vd_val[i],\n        MVV_VNMSAC => vd_val[i] - get_slice_int(SEW, signed(vs1_val[i]) * signed(vs2_val[i]), 0),\n        MVV_VMADD  => get_slice_int(SEW, signed(vs1_val[i]) * signed(vd_val[i]), 0) + vs2_val[i],\n        MVV_VNMSUB => vs2_val[i] - get_slice_int(SEW, signed(vs1_val[i]) * signed(vd_val[i]), 0)\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmacc.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VMACC  => get_slice_int(SEW, signed(rs1_val) * signed(vs2_val[i]), 0) + vd_val[i],\n        MVX_VNMSAC => vd_val[i] - get_slice_int(SEW, signed(rs1_val) * signed(vs2_val[i]), 0),\n        MVX_VMADD  => get_slice_int(SEW, signed(rs1_val) * signed(vd_val[i]), 0) + vs2_val[i],\n        MVX_VNMSUB => vs2_val[i] - get_slice_int(SEW, signed(rs1_val) * signed(vd_val[i]), 0)\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmadc.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,simm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vimcfunct6(funct6)", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VIMC_VMADC    => unsigned(vs2_val[i]) + unsigned(imm_val) > 2 ^ SEW - 1\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmadc.vim",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,simm,v0",
  "format": "TBD",
  "fields": [ { "field": "encdec_vimfunct6(funct6)", "size": 6 }, { "field": "0b0", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VIM_VMADC    => unsigned(vs2_val[i]) + unsigned(imm_val) + unsigned(bool_to_bits(vm_val[i])) > 2 ^ SEW - 1\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmadc.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,vs1",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvmcfunct6(funct6)", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VVMC_VMADC    => unsigned(vs2_val[i]) + unsigned(vs1_val[i]) > 2 ^ SEW - 1,\n        VVMC_VMSBC    => unsigned(vs2_val[i]) - unsigned(vs1_val[i]) < 0\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmadc.vvm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,vs1,v0",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvmfunct6(funct6)", "size": 6 }, { "field": "0b0", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VVM_VMADC    => unsigned(vs2_val[i]) + unsigned(vs1_val[i]) + unsigned(bool_to_bits(vm_val[i])) > 2 ^ SEW - 1,\n        VVM_VMSBC    => unsigned(vs2_val[i]) - unsigned(vs1_val[i]) - unsigned(bool_to_bits(vm_val[i])) < 0\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmadc.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,rs1",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxmcfunct6(funct6)", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VXMC_VMADC    => unsigned(vs2_val[i]) + unsigned(rs1_val) > 2 ^ SEW - 1,\n        VXMC_VMSBC    => unsigned(vs2_val[i]) - unsigned(rs1_val) < 0\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmadc.vxm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,rs1,v0",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxmfunct6(funct6)", "size": 6 }, { "field": "0b0", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VXM_VMADC    => unsigned(vs2_val[i]) + unsigned(rs1_val) + unsigned(bool_to_bits(vm_val[i])) > 2 ^ SEW - 1,\n        VXM_VMSBC    => unsigned(vs2_val[i]) - unsigned(rs1_val) - unsigned(bool_to_bits(vm_val[i])) < 0\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmadd.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvvmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVV_VMACC  => get_slice_int(SEW, signed(vs1_val[i]) * signed(vs2_val[i]), 0) + vd_val[i],\n        MVV_VNMSAC => vd_val[i] - get_slice_int(SEW, signed(vs1_val[i]) * signed(vs2_val[i]), 0),\n        MVV_VMADD  => get_slice_int(SEW, signed(vs1_val[i]) * signed(vd_val[i]), 0) + vs2_val[i],\n        MVV_VNMSUB => vs2_val[i] - get_slice_int(SEW, signed(vs1_val[i]) * signed(vd_val[i]), 0)\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmadd.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VMACC  => get_slice_int(SEW, signed(rs1_val) * signed(vs2_val[i]), 0) + vd_val[i],\n        MVX_VNMSAC => vd_val[i] - get_slice_int(SEW, signed(rs1_val) * signed(vs2_val[i]), 0),\n        MVX_VMADD  => get_slice_int(SEW, signed(rs1_val) * signed(vd_val[i]), 0) + vs2_val[i],\n        MVX_VNMSUB => vs2_val[i] - get_slice_int(SEW, signed(rs1_val) * signed(vd_val[i]), 0)\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmand.mm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,vs1",
  "format": "TBD",
  "fields": [ { "field": "encdec_mmfunct6(funct6)", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = unsigned(vlenb) * 8;\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vs1_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs1);\n  let vs2_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\n  let vd_val  : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool) = undefined;\n  var mask    : vector('n, dec, bool) = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MM_VMAND     => vs2_val[i] & vs1_val[i],\n        MM_VMNAND    => not(vs2_val[i] & vs1_val[i]),\n        MM_VMANDN    => vs2_val[i] & not(vs1_val[i]),\n        MM_VMXOR     => vs2_val[i] != vs1_val[i],\n        MM_VMOR      => vs2_val[i] | vs1_val[i],\n        MM_VMNOR     => not(vs2_val[i] | vs1_val[i]),\n        MM_VMORN     => vs2_val[i] | not(vs1_val[i]),\n        MM_VMXNOR    => vs2_val[i] == vs1_val[i]\n      }\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmandn.mm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,vs1",
  "format": "TBD",
  "fields": [ { "field": "encdec_mmfunct6(funct6)", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = unsigned(vlenb) * 8;\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vs1_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs1);\n  let vs2_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\n  let vd_val  : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool) = undefined;\n  var mask    : vector('n, dec, bool) = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MM_VMAND     => vs2_val[i] & vs1_val[i],\n        MM_VMNAND    => not(vs2_val[i] & vs1_val[i]),\n        MM_VMANDN    => vs2_val[i] & not(vs1_val[i]),\n        MM_VMXOR     => vs2_val[i] != vs1_val[i],\n        MM_VMOR      => vs2_val[i] | vs1_val[i],\n        MM_VMNOR     => not(vs2_val[i] | vs1_val[i]),\n        MM_VMORN     => vs2_val[i] | not(vs1_val[i]),\n        MM_VMXNOR    => vs2_val[i] == vs1_val[i]\n      }\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmax.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmax.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmaxu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmaxu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmerge.vim",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false } ],
  "syntax": "vd,vs2,simm,v0",
  "format": "TBD",
  "fields": [ { "field": "0b010111", "size": 6 }, { "field": "0b0", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let start_element = get_start_element();\n  let end_element   = get_end_element();\n  let SEW           = get_sew();\n  let LMUL_pow      = get_lmul_pow();\n  let num_elem      = get_num_elem(LMUL_pow, SEW); /* max(VLMAX,VLEN/SEW)) */\n  let real_num_elem = if LMUL_pow >= 0 then num_elem else num_elem / (0 - LMUL_pow); /* VLMAX */\n\n  if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n\n  let tail_ag : agtype = get_vtype_vta();\n  foreach (i from 0 to (num_elem - 1)) {\n    if i < start_element then {\n      result[i] = vd_val[i]\n    } else if i > end_element | i >= real_num_elem then {\n      result[i] = match tail_ag {\n        UNDISTURBED => vd_val[i],\n        AGNOSTIC    => vd_val[i] /* TODO: configuration support */\n      }\n    } else {\n      /* the merge operates on all body elements */\n      result[i] = if vm_val[i] then imm_val else vs2_val[i]\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmerge.vvm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,vs1,v0",
  "format": "TBD",
  "fields": [ { "field": "0b010111", "size": 6 }, { "field": "0b0", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let start_element = get_start_element();\n  let end_element   = get_end_element();\n  let SEW           = get_sew();\n  let LMUL_pow      = get_lmul_pow();\n  let num_elem      = get_num_elem(LMUL_pow, SEW); /* max(VLMAX,VLEN/SEW)) */\n  let real_num_elem = if LMUL_pow >= 0 then num_elem else num_elem / (0 - LMUL_pow); /* VLMAX */\n\n  if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n\n  let tail_ag : agtype = get_vtype_vta();\n  foreach (i from 0 to (num_elem - 1)) {\n    if i < start_element then {\n      result[i] = vd_val[i]\n    } else if i > end_element | i >= real_num_elem then {\n      result[i] = match tail_ag {\n        UNDISTURBED => vd_val[i],\n        AGNOSTIC    => vd_val[i] /* TODO: configuration support */\n      }\n    } else {\n      /* the merge operates on all body elements */\n      result[i] = if vm_val[i] then vs1_val[i] else vs2_val[i]\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmerge.vxm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,rs1,v0",
  "format": "TBD",
  "fields": [ { "field": "0b010111", "size": 6 }, { "field": "0b0", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let start_element = get_start_element();\n  let end_element   = get_end_element();\n  let SEW           = get_sew();\n  let LMUL_pow      = get_lmul_pow();\n  let num_elem      = get_num_elem(LMUL_pow, SEW); /* max(VLMAX,VLEN/SEW)) */\n  let real_num_elem = if LMUL_pow >= 0 then num_elem else num_elem / (0 - LMUL_pow); /* VLMAX */\n\n  if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n\n  let tail_ag : agtype = get_vtype_vta();\n  foreach (i from 0 to (num_elem - 1)) {\n    if i < start_element then {\n      result[i] = vd_val[i]\n    } else if i > end_element | i >= real_num_elem then {\n      result[i] = match tail_ag {\n        UNDISTURBED => vd_val[i],\n        AGNOSTIC    => vd_val[i] /* TODO: configuration support */\n      }\n    } else {\n      /* the merge operates on all body elements */\n      result[i] = if vm_val[i] then rs1_val else vs2_val[i]\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmfeq.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvfmfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VFM_VMFEQ    => fp_eq(vs2_val[i], rs1_val),\n        VFM_VMFNE    => ~(fp_eq(vs2_val[i], rs1_val)),\n        VFM_VMFLE    => fp_le(vs2_val[i], rs1_val),\n        VFM_VMFLT    => fp_lt(vs2_val[i], rs1_val),\n        VFM_VMFGE    => fp_ge(vs2_val[i], rs1_val),\n        VFM_VMFGT    => fp_gt(vs2_val[i], rs1_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmfeq.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvmfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        FVVM_VMFEQ    => fp_eq(vs2_val[i], vs1_val[i]),\n        FVVM_VMFNE    => ~(fp_eq(vs2_val[i], vs1_val[i])),\n        FVVM_VMFLE    => fp_le(vs2_val[i], vs1_val[i]),\n        FVVM_VMFLT    => fp_lt(vs2_val[i], vs1_val[i])\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmfge.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvfmfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VFM_VMFEQ    => fp_eq(vs2_val[i], rs1_val),\n        VFM_VMFNE    => ~(fp_eq(vs2_val[i], rs1_val)),\n        VFM_VMFLE    => fp_le(vs2_val[i], rs1_val),\n        VFM_VMFLT    => fp_lt(vs2_val[i], rs1_val),\n        VFM_VMFGE    => fp_ge(vs2_val[i], rs1_val),\n        VFM_VMFGT    => fp_gt(vs2_val[i], rs1_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmfgt.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvfmfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VFM_VMFEQ    => fp_eq(vs2_val[i], rs1_val),\n        VFM_VMFNE    => ~(fp_eq(vs2_val[i], rs1_val)),\n        VFM_VMFLE    => fp_le(vs2_val[i], rs1_val),\n        VFM_VMFLT    => fp_lt(vs2_val[i], rs1_val),\n        VFM_VMFGE    => fp_ge(vs2_val[i], rs1_val),\n        VFM_VMFGT    => fp_gt(vs2_val[i], rs1_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmfle.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvfmfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VFM_VMFEQ    => fp_eq(vs2_val[i], rs1_val),\n        VFM_VMFNE    => ~(fp_eq(vs2_val[i], rs1_val)),\n        VFM_VMFLE    => fp_le(vs2_val[i], rs1_val),\n        VFM_VMFLT    => fp_lt(vs2_val[i], rs1_val),\n        VFM_VMFGE    => fp_ge(vs2_val[i], rs1_val),\n        VFM_VMFGT    => fp_gt(vs2_val[i], rs1_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmfle.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvmfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        FVVM_VMFEQ    => fp_eq(vs2_val[i], vs1_val[i]),\n        FVVM_VMFNE    => ~(fp_eq(vs2_val[i], vs1_val[i])),\n        FVVM_VMFLE    => fp_le(vs2_val[i], vs1_val[i]),\n        FVVM_VMFLT    => fp_lt(vs2_val[i], vs1_val[i])\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmflt.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvfmfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VFM_VMFEQ    => fp_eq(vs2_val[i], rs1_val),\n        VFM_VMFNE    => ~(fp_eq(vs2_val[i], rs1_val)),\n        VFM_VMFLE    => fp_le(vs2_val[i], rs1_val),\n        VFM_VMFLT    => fp_lt(vs2_val[i], rs1_val),\n        VFM_VMFGE    => fp_ge(vs2_val[i], rs1_val),\n        VFM_VMFGT    => fp_gt(vs2_val[i], rs1_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmflt.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvmfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        FVVM_VMFEQ    => fp_eq(vs2_val[i], vs1_val[i]),\n        FVVM_VMFNE    => ~(fp_eq(vs2_val[i], vs1_val[i])),\n        FVVM_VMFLE    => fp_le(vs2_val[i], vs1_val[i]),\n        FVVM_VMFLT    => fp_lt(vs2_val[i], vs1_val[i])\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmfne.vf",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvfmfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar_fp(rs1, 'm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VFM_VMFEQ    => fp_eq(vs2_val[i], rs1_val),\n        VFM_VMFNE    => ~(fp_eq(vs2_val[i], rs1_val)),\n        VFM_VMFLE    => fp_le(vs2_val[i], rs1_val),\n        VFM_VMFLT    => fp_lt(vs2_val[i], rs1_val),\n        VFM_VMFGE    => fp_ge(vs2_val[i], rs1_val),\n        VFM_VMFGT    => fp_gt(vs2_val[i], rs1_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmfne.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_fvvmfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let rm_3b    = fcsr[FRM];\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        FVVM_VMFEQ    => fp_eq(vs2_val[i], vs1_val[i]),\n        FVVM_VMFNE    => ~(fp_eq(vs2_val[i], vs1_val[i])),\n        FVVM_VMFLE    => fp_le(vs2_val[i], vs1_val[i]),\n        FVVM_VMFLT    => fp_lt(vs2_val[i], vs1_val[i])\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmin.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmin.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vminu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vminu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmnand.mm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,vs1",
  "format": "TBD",
  "fields": [ { "field": "encdec_mmfunct6(funct6)", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = unsigned(vlenb) * 8;\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vs1_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs1);\n  let vs2_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\n  let vd_val  : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool) = undefined;\n  var mask    : vector('n, dec, bool) = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MM_VMAND     => vs2_val[i] & vs1_val[i],\n        MM_VMNAND    => not(vs2_val[i] & vs1_val[i]),\n        MM_VMANDN    => vs2_val[i] & not(vs1_val[i]),\n        MM_VMXOR     => vs2_val[i] != vs1_val[i],\n        MM_VMOR      => vs2_val[i] | vs1_val[i],\n        MM_VMNOR     => not(vs2_val[i] | vs1_val[i]),\n        MM_VMORN     => vs2_val[i] | not(vs1_val[i]),\n        MM_VMXNOR    => vs2_val[i] == vs1_val[i]\n      }\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmnor.mm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,vs1",
  "format": "TBD",
  "fields": [ { "field": "encdec_mmfunct6(funct6)", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = unsigned(vlenb) * 8;\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vs1_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs1);\n  let vs2_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\n  let vd_val  : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool) = undefined;\n  var mask    : vector('n, dec, bool) = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MM_VMAND     => vs2_val[i] & vs1_val[i],\n        MM_VMNAND    => not(vs2_val[i] & vs1_val[i]),\n        MM_VMANDN    => vs2_val[i] & not(vs1_val[i]),\n        MM_VMXOR     => vs2_val[i] != vs1_val[i],\n        MM_VMOR      => vs2_val[i] | vs1_val[i],\n        MM_VMNOR     => not(vs2_val[i] | vs1_val[i]),\n        MM_VMORN     => vs2_val[i] | not(vs1_val[i]),\n        MM_VMXNOR    => vs2_val[i] == vs1_val[i]\n      }\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmor.mm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,vs1",
  "format": "TBD",
  "fields": [ { "field": "encdec_mmfunct6(funct6)", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = unsigned(vlenb) * 8;\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vs1_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs1);\n  let vs2_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\n  let vd_val  : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool) = undefined;\n  var mask    : vector('n, dec, bool) = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MM_VMAND     => vs2_val[i] & vs1_val[i],\n        MM_VMNAND    => not(vs2_val[i] & vs1_val[i]),\n        MM_VMANDN    => vs2_val[i] & not(vs1_val[i]),\n        MM_VMXOR     => vs2_val[i] != vs1_val[i],\n        MM_VMOR      => vs2_val[i] | vs1_val[i],\n        MM_VMNOR     => not(vs2_val[i] | vs1_val[i]),\n        MM_VMORN     => vs2_val[i] | not(vs1_val[i]),\n        MM_VMXNOR    => vs2_val[i] == vs1_val[i]\n      }\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmorn.mm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,vs1",
  "format": "TBD",
  "fields": [ { "field": "encdec_mmfunct6(funct6)", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = unsigned(vlenb) * 8;\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vs1_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs1);\n  let vs2_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\n  let vd_val  : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool) = undefined;\n  var mask    : vector('n, dec, bool) = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MM_VMAND     => vs2_val[i] & vs1_val[i],\n        MM_VMNAND    => not(vs2_val[i] & vs1_val[i]),\n        MM_VMANDN    => vs2_val[i] & not(vs1_val[i]),\n        MM_VMXOR     => vs2_val[i] != vs1_val[i],\n        MM_VMOR      => vs2_val[i] | vs1_val[i],\n        MM_VMNOR     => not(vs2_val[i] | vs1_val[i]),\n        MM_VMORN     => vs2_val[i] | not(vs1_val[i]),\n        MM_VMXNOR    => vs2_val[i] == vs1_val[i]\n      }\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsbc.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,vs1",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvmcfunct6(funct6)", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VVMC_VMADC    => unsigned(vs2_val[i]) + unsigned(vs1_val[i]) > 2 ^ SEW - 1,\n        VVMC_VMSBC    => unsigned(vs2_val[i]) - unsigned(vs1_val[i]) < 0\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsbc.vvm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,vs1,v0",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvmfunct6(funct6)", "size": 6 }, { "field": "0b0", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VVM_VMADC    => unsigned(vs2_val[i]) + unsigned(vs1_val[i]) + unsigned(bool_to_bits(vm_val[i])) > 2 ^ SEW - 1,\n        VVM_VMSBC    => unsigned(vs2_val[i]) - unsigned(vs1_val[i]) - unsigned(bool_to_bits(vm_val[i])) < 0\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsbc.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,rs1",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxmcfunct6(funct6)", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VXMC_VMADC    => unsigned(vs2_val[i]) + unsigned(rs1_val) > 2 ^ SEW - 1,\n        VXMC_VMSBC    => unsigned(vs2_val[i]) - unsigned(rs1_val) < 0\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsbc.vxm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,rs1,v0",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxmfunct6(funct6)", "size": 6 }, { "field": "0b0", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VXM_VMADC    => unsigned(vs2_val[i]) + unsigned(rs1_val) + unsigned(bool_to_bits(vm_val[i])) > 2 ^ SEW - 1,\n        VXM_VMSBC    => unsigned(vs2_val[i]) - unsigned(rs1_val) - unsigned(bool_to_bits(vm_val[i])) < 0\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsbf.m",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010100", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "0b00001", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = unsigned(vlenb) * 8;\n\n  if illegal_normal(vd, vm) | not(assert_vstart(0)) | vd == vs2\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\n  let vd_val  : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool) = undefined;\n  var mask    : vector('n, dec, bool) = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vd_val, vm_val);\n\n  var found_elem : bool = false;\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      if vs2_val[i] then found_elem = true;\n      result[i] = if found_elem then false else true\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmseq.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vicmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VICMP_VMSEQ    => vs2_val[i] == imm_val,\n        VICMP_VMSNE    => vs2_val[i] != imm_val,\n        VICMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(imm_val),\n        VICMP_VMSLE    => signed(vs2_val[i]) <= signed(imm_val),\n        VICMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(imm_val),\n        VICMP_VMSGT    => signed(vs2_val[i]) > signed(imm_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmseq.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvcmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VVCMP_VMSEQ    => vs2_val[i] == vs1_val[i],\n        VVCMP_VMSNE    => vs2_val[i] != vs1_val[i],\n        VVCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(vs1_val[i]),\n        VVCMP_VMSLT    => signed(vs2_val[i]) < signed(vs1_val[i]),\n        VVCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(vs1_val[i]),\n        VVCMP_VMSLE    => signed(vs2_val[i]) <= signed(vs1_val[i])\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmseq.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxcmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VXCMP_VMSEQ    => vs2_val[i] == rs1_val,\n        VXCMP_VMSNE    => vs2_val[i] != rs1_val,\n        VXCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(rs1_val),\n        VXCMP_VMSLT    => signed(vs2_val[i]) < signed(rs1_val),\n        VXCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(rs1_val),\n        VXCMP_VMSLE    => signed(vs2_val[i]) <= signed(rs1_val),\n        VXCMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(rs1_val),\n        VXCMP_VMSGT    => signed(vs2_val[i]) > signed(rs1_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsgt.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vicmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VICMP_VMSEQ    => vs2_val[i] == imm_val,\n        VICMP_VMSNE    => vs2_val[i] != imm_val,\n        VICMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(imm_val),\n        VICMP_VMSLE    => signed(vs2_val[i]) <= signed(imm_val),\n        VICMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(imm_val),\n        VICMP_VMSGT    => signed(vs2_val[i]) > signed(imm_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsgt.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxcmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VXCMP_VMSEQ    => vs2_val[i] == rs1_val,\n        VXCMP_VMSNE    => vs2_val[i] != rs1_val,\n        VXCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(rs1_val),\n        VXCMP_VMSLT    => signed(vs2_val[i]) < signed(rs1_val),\n        VXCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(rs1_val),\n        VXCMP_VMSLE    => signed(vs2_val[i]) <= signed(rs1_val),\n        VXCMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(rs1_val),\n        VXCMP_VMSGT    => signed(vs2_val[i]) > signed(rs1_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsgtu.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vicmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VICMP_VMSEQ    => vs2_val[i] == imm_val,\n        VICMP_VMSNE    => vs2_val[i] != imm_val,\n        VICMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(imm_val),\n        VICMP_VMSLE    => signed(vs2_val[i]) <= signed(imm_val),\n        VICMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(imm_val),\n        VICMP_VMSGT    => signed(vs2_val[i]) > signed(imm_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsgtu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxcmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VXCMP_VMSEQ    => vs2_val[i] == rs1_val,\n        VXCMP_VMSNE    => vs2_val[i] != rs1_val,\n        VXCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(rs1_val),\n        VXCMP_VMSLT    => signed(vs2_val[i]) < signed(rs1_val),\n        VXCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(rs1_val),\n        VXCMP_VMSLE    => signed(vs2_val[i]) <= signed(rs1_val),\n        VXCMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(rs1_val),\n        VXCMP_VMSGT    => signed(vs2_val[i]) > signed(rs1_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsif.m",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010100", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "0b00011", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = unsigned(vlenb) * 8;\n\n  if illegal_normal(vd, vm) | not(assert_vstart(0)) | vd == vs2\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\n  let vd_val  : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool) = undefined;\n  var mask    : vector('n, dec, bool) = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vd_val, vm_val);\n\n  var found_elem : bool = false;\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = if found_elem then false else true;\n      if vs2_val[i] then found_elem = true\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsle.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vicmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VICMP_VMSEQ    => vs2_val[i] == imm_val,\n        VICMP_VMSNE    => vs2_val[i] != imm_val,\n        VICMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(imm_val),\n        VICMP_VMSLE    => signed(vs2_val[i]) <= signed(imm_val),\n        VICMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(imm_val),\n        VICMP_VMSGT    => signed(vs2_val[i]) > signed(imm_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsle.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvcmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VVCMP_VMSEQ    => vs2_val[i] == vs1_val[i],\n        VVCMP_VMSNE    => vs2_val[i] != vs1_val[i],\n        VVCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(vs1_val[i]),\n        VVCMP_VMSLT    => signed(vs2_val[i]) < signed(vs1_val[i]),\n        VVCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(vs1_val[i]),\n        VVCMP_VMSLE    => signed(vs2_val[i]) <= signed(vs1_val[i])\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsle.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxcmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VXCMP_VMSEQ    => vs2_val[i] == rs1_val,\n        VXCMP_VMSNE    => vs2_val[i] != rs1_val,\n        VXCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(rs1_val),\n        VXCMP_VMSLT    => signed(vs2_val[i]) < signed(rs1_val),\n        VXCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(rs1_val),\n        VXCMP_VMSLE    => signed(vs2_val[i]) <= signed(rs1_val),\n        VXCMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(rs1_val),\n        VXCMP_VMSGT    => signed(vs2_val[i]) > signed(rs1_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsleu.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vicmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VICMP_VMSEQ    => vs2_val[i] == imm_val,\n        VICMP_VMSNE    => vs2_val[i] != imm_val,\n        VICMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(imm_val),\n        VICMP_VMSLE    => signed(vs2_val[i]) <= signed(imm_val),\n        VICMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(imm_val),\n        VICMP_VMSGT    => signed(vs2_val[i]) > signed(imm_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsleu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvcmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VVCMP_VMSEQ    => vs2_val[i] == vs1_val[i],\n        VVCMP_VMSNE    => vs2_val[i] != vs1_val[i],\n        VVCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(vs1_val[i]),\n        VVCMP_VMSLT    => signed(vs2_val[i]) < signed(vs1_val[i]),\n        VVCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(vs1_val[i]),\n        VVCMP_VMSLE    => signed(vs2_val[i]) <= signed(vs1_val[i])\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsleu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxcmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VXCMP_VMSEQ    => vs2_val[i] == rs1_val,\n        VXCMP_VMSNE    => vs2_val[i] != rs1_val,\n        VXCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(rs1_val),\n        VXCMP_VMSLT    => signed(vs2_val[i]) < signed(rs1_val),\n        VXCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(rs1_val),\n        VXCMP_VMSLE    => signed(vs2_val[i]) <= signed(rs1_val),\n        VXCMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(rs1_val),\n        VXCMP_VMSGT    => signed(vs2_val[i]) > signed(rs1_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmslt.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvcmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VVCMP_VMSEQ    => vs2_val[i] == vs1_val[i],\n        VVCMP_VMSNE    => vs2_val[i] != vs1_val[i],\n        VVCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(vs1_val[i]),\n        VVCMP_VMSLT    => signed(vs2_val[i]) < signed(vs1_val[i]),\n        VVCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(vs1_val[i]),\n        VVCMP_VMSLE    => signed(vs2_val[i]) <= signed(vs1_val[i])\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmslt.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxcmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VXCMP_VMSEQ    => vs2_val[i] == rs1_val,\n        VXCMP_VMSNE    => vs2_val[i] != rs1_val,\n        VXCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(rs1_val),\n        VXCMP_VMSLT    => signed(vs2_val[i]) < signed(rs1_val),\n        VXCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(rs1_val),\n        VXCMP_VMSLE    => signed(vs2_val[i]) <= signed(rs1_val),\n        VXCMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(rs1_val),\n        VXCMP_VMSGT    => signed(vs2_val[i]) > signed(rs1_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsltu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvcmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VVCMP_VMSEQ    => vs2_val[i] == vs1_val[i],\n        VVCMP_VMSNE    => vs2_val[i] != vs1_val[i],\n        VVCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(vs1_val[i]),\n        VVCMP_VMSLT    => signed(vs2_val[i]) < signed(vs1_val[i]),\n        VVCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(vs1_val[i]),\n        VVCMP_VMSLE    => signed(vs2_val[i]) <= signed(vs1_val[i])\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsltu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxcmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VXCMP_VMSEQ    => vs2_val[i] == rs1_val,\n        VXCMP_VMSNE    => vs2_val[i] != rs1_val,\n        VXCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(rs1_val),\n        VXCMP_VMSLT    => signed(vs2_val[i]) < signed(rs1_val),\n        VXCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(rs1_val),\n        VXCMP_VMSLE    => signed(vs2_val[i]) <= signed(rs1_val),\n        VXCMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(rs1_val),\n        VXCMP_VMSGT    => signed(vs2_val[i]) > signed(rs1_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsne.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vicmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VICMP_VMSEQ    => vs2_val[i] == imm_val,\n        VICMP_VMSNE    => vs2_val[i] != imm_val,\n        VICMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(imm_val),\n        VICMP_VMSLE    => signed(vs2_val[i]) <= signed(imm_val),\n        VICMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(imm_val),\n        VICMP_VMSGT    => signed(vs2_val[i]) > signed(imm_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsne.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvcmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VVCMP_VMSEQ    => vs2_val[i] == vs1_val[i],\n        VVCMP_VMSNE    => vs2_val[i] != vs1_val[i],\n        VVCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(vs1_val[i]),\n        VVCMP_VMSLT    => signed(vs2_val[i]) < signed(vs1_val[i]),\n        VVCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(vs1_val[i]),\n        VVCMP_VMSLE    => signed(vs2_val[i]) <= signed(vs1_val[i])\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsne.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxcmpfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool)     = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let res : bool = match funct6 {\n        VXCMP_VMSEQ    => vs2_val[i] == rs1_val,\n        VXCMP_VMSNE    => vs2_val[i] != rs1_val,\n        VXCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(rs1_val),\n        VXCMP_VMSLT    => signed(vs2_val[i]) < signed(rs1_val),\n        VXCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(rs1_val),\n        VXCMP_VMSLE    => signed(vs2_val[i]) <= signed(rs1_val),\n        VXCMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(rs1_val),\n        VXCMP_VMSGT    => signed(vs2_val[i]) > signed(rs1_val)\n      };\n      result[i] = res\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmsof.m",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010100", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "0b00010", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = unsigned(vlenb) * 8;\n\n  if illegal_normal(vd, vm) | not(assert_vstart(0)) | vd == vs2\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\n  let vd_val  : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool) = undefined;\n  var mask    : vector('n, dec, bool) = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vd_val, vm_val);\n\n  var found_elem : bool = false;\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      if vs2_val[i] & not(found_elem) then {\n        result[i] = true;\n        found_elem = true\n      } else {\n        result[i] = false\n      }\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmul.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVV_VAADDU   => {\n                          let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VAADD    => {\n                          let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUBU   => {\n                          let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUB    => {\n                          let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VDIVU    => {\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          to_bits(SEW, q)\n                        },\n        MVV_VDIV     => {\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* check for signed overflow */\n                          let q' : int = if q > elem_max then elem_min else q;\n                          to_bits(SEW, q')\n                        },\n        MVV_VREMU    => {\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        },\n        MVV_VREM     => {\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmul.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VAADDU       => {\n                              let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VAADD        => {\n                              let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUBU       => {\n                              let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUB        => {\n                              let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VSLIDE1UP    => {\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        MVX_VSLIDE1DOWN  => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            },\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VDIVU        => {\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\n                              to_bits(SEW, q)\n                            },\n        MVX_VDIV         => {\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* check for signed overflow */\n                              let q' : int = if q > elem_max then elem_min else q;\n                              to_bits(SEW, q')\n                            },\n        MVX_VREMU        => {\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            },\n        MVX_VREM         => {\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmulh.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVV_VAADDU   => {\n                          let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VAADD    => {\n                          let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUBU   => {\n                          let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUB    => {\n                          let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VDIVU    => {\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          to_bits(SEW, q)\n                        },\n        MVV_VDIV     => {\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* check for signed overflow */\n                          let q' : int = if q > elem_max then elem_min else q;\n                          to_bits(SEW, q')\n                        },\n        MVV_VREMU    => {\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        },\n        MVV_VREM     => {\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmulh.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VAADDU       => {\n                              let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VAADD        => {\n                              let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUBU       => {\n                              let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUB        => {\n                              let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VSLIDE1UP    => {\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        MVX_VSLIDE1DOWN  => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            },\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VDIVU        => {\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\n                              to_bits(SEW, q)\n                            },\n        MVX_VDIV         => {\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* check for signed overflow */\n                              let q' : int = if q > elem_max then elem_min else q;\n                              to_bits(SEW, q')\n                            },\n        MVX_VREMU        => {\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            },\n        MVX_VREM         => {\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmulhsu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVV_VAADDU   => {\n                          let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VAADD    => {\n                          let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUBU   => {\n                          let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUB    => {\n                          let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VDIVU    => {\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          to_bits(SEW, q)\n                        },\n        MVV_VDIV     => {\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* check for signed overflow */\n                          let q' : int = if q > elem_max then elem_min else q;\n                          to_bits(SEW, q')\n                        },\n        MVV_VREMU    => {\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        },\n        MVV_VREM     => {\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmulhsu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VAADDU       => {\n                              let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VAADD        => {\n                              let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUBU       => {\n                              let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUB        => {\n                              let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VSLIDE1UP    => {\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        MVX_VSLIDE1DOWN  => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            },\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VDIVU        => {\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\n                              to_bits(SEW, q)\n                            },\n        MVX_VDIV         => {\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* check for signed overflow */\n                              let q' : int = if q > elem_max then elem_min else q;\n                              to_bits(SEW, q')\n                            },\n        MVX_VREMU        => {\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            },\n        MVX_VREM         => {\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmulhu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVV_VAADDU   => {\n                          let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VAADD    => {\n                          let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUBU   => {\n                          let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUB    => {\n                          let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VDIVU    => {\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          to_bits(SEW, q)\n                        },\n        MVV_VDIV     => {\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* check for signed overflow */\n                          let q' : int = if q > elem_max then elem_min else q;\n                          to_bits(SEW, q')\n                        },\n        MVV_VREMU    => {\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        },\n        MVV_VREM     => {\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmulhu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VAADDU       => {\n                              let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VAADD        => {\n                              let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUBU       => {\n                              let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUB        => {\n                              let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VSLIDE1UP    => {\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        MVX_VSLIDE1DOWN  => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            },\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VDIVU        => {\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\n                              to_bits(SEW, q)\n                            },\n        MVX_VDIV         => {\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* check for signed overflow */\n                              let q' : int = if q > elem_max then elem_min else q;\n                              to_bits(SEW, q')\n                            },\n        MVX_VREMU        => {\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            },\n        MVX_VREM         => {\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmv.s.x",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b010000", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let num_elem = get_num_elem(0, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  assert(num_elem > 0);\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, 'm);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, 0, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, 0, vd_val, vm_val);\n\n  /* one body element */\n  if mask[0] then result[0] = rs1_val;\n\n  /* others treated as tail elements */\n  let tail_ag : agtype = get_vtype_vta();\n  foreach (i from 1 to (num_elem - 1)) {\n    result[i] = match tail_ag {\n      UNDISTURBED => vd_val[i],\n      AGNOSTIC    => vd_val[i] /* TODO: configuration support */\n    }\n  };\n\n  write_vreg(num_elem, SEW, 0, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmv.v.i",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false } ],
  "syntax": "vd,simm",
  "format": "TBD",
  "fields": [ { "field": "0b010111", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then result[i] = imm_val\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmv.v.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs1",
  "format": "TBD",
  "fields": [ { "field": "0b010111", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then result[i] = vs1_val[i]\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmv.v.x",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b010111", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let rs1_val : bits('m)                  = get_scalar(rs1, 'm);\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then result[i] = rs1_val\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmv.x.s",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,vs2",
  "format": "TBD",
  "fields": [ { "field": "0b010000", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "0b00000", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let num_elem = get_num_elem(0, SEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  assert(num_elem > 0);\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, 0, vs2);\n  X(rd) = if sizeof(xlen) < SEW then slice(vs2_val[0], 0, sizeof(xlen))\n          else if sizeof(xlen) > SEW then sign_extend(vs2_val[0])\n          else vs2_val[0];\n  vstart = zeros();\n\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmv1r.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2",
  "format": "TBD",
  "fields": [ { "field": "0b100111", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 0 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let start_element = get_start_element();\n  let SEW     = get_sew();\n  let imm_val = unsigned(zero_extend(sizeof(xlen), simm));\n  let EMUL    = imm_val + 1;\n\n  if not(EMUL == 1 | EMUL == 2 | EMUL == 4 | EMUL == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  let EMUL_pow = log2(EMUL);\n  let num_elem = get_num_elem(EMUL_pow, SEW);\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n\n  foreach (i from 0 to (num_elem - 1)) {\n    result[i] = if i < start_element then vd_val[i] else vs2_val[i]\n  };\n\n  write_vreg(num_elem, SEW, EMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmv2r.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2",
  "format": "TBD",
  "fields": [ { "field": "0b100111", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 0 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let start_element = get_start_element();\n  let SEW     = get_sew();\n  let imm_val = unsigned(zero_extend(sizeof(xlen), simm));\n  let EMUL    = imm_val + 1;\n\n  if not(EMUL == 1 | EMUL == 2 | EMUL == 4 | EMUL == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  let EMUL_pow = log2(EMUL);\n  let num_elem = get_num_elem(EMUL_pow, SEW);\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n\n  foreach (i from 0 to (num_elem - 1)) {\n    result[i] = if i < start_element then vd_val[i] else vs2_val[i]\n  };\n\n  write_vreg(num_elem, SEW, EMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmv4r.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2",
  "format": "TBD",
  "fields": [ { "field": "0b100111", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 0 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let start_element = get_start_element();\n  let SEW     = get_sew();\n  let imm_val = unsigned(zero_extend(sizeof(xlen), simm));\n  let EMUL    = imm_val + 1;\n\n  if not(EMUL == 1 | EMUL == 2 | EMUL == 4 | EMUL == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  let EMUL_pow = log2(EMUL);\n  let num_elem = get_num_elem(EMUL_pow, SEW);\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n\n  foreach (i from 0 to (num_elem - 1)) {\n    result[i] = if i < start_element then vd_val[i] else vs2_val[i]\n  };\n\n  write_vreg(num_elem, SEW, EMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmv8r.v",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2",
  "format": "TBD",
  "fields": [ { "field": "0b100111", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 0 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let start_element = get_start_element();\n  let SEW     = get_sew();\n  let imm_val = unsigned(zero_extend(sizeof(xlen), simm));\n  let EMUL    = imm_val + 1;\n\n  if not(EMUL == 1 | EMUL == 2 | EMUL == 4 | EMUL == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  let EMUL_pow = log2(EMUL);\n  let num_elem = get_num_elem(EMUL_pow, SEW);\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n\n  foreach (i from 0 to (num_elem - 1)) {\n    result[i] = if i < start_element then vd_val[i] else vs2_val[i]\n  };\n\n  write_vreg(num_elem, SEW, EMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmxnor.mm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,vs1",
  "format": "TBD",
  "fields": [ { "field": "encdec_mmfunct6(funct6)", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = unsigned(vlenb) * 8;\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vs1_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs1);\n  let vs2_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\n  let vd_val  : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool) = undefined;\n  var mask    : vector('n, dec, bool) = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MM_VMAND     => vs2_val[i] & vs1_val[i],\n        MM_VMNAND    => not(vs2_val[i] & vs1_val[i]),\n        MM_VMANDN    => vs2_val[i] & not(vs1_val[i]),\n        MM_VMXOR     => vs2_val[i] != vs1_val[i],\n        MM_VMOR      => vs2_val[i] | vs1_val[i],\n        MM_VMNOR     => not(vs2_val[i] | vs1_val[i]),\n        MM_VMORN     => vs2_val[i] | not(vs1_val[i]),\n        MM_VMXNOR    => vs2_val[i] == vs1_val[i]\n      }\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vmxor.mm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,vs1",
  "format": "TBD",
  "fields": [ { "field": "encdec_mmfunct6(funct6)", "size": 6 }, { "field": "0b1", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = unsigned(vlenb) * 8;\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vs1_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs1);\n  let vs2_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\n  let vd_val  : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vd);\n  var result  : vector('n, dec, bool) = undefined;\n  var mask    : vector('n, dec, bool) = undefined;\n\n  (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MM_VMAND     => vs2_val[i] & vs1_val[i],\n        MM_VMNAND    => not(vs2_val[i] & vs1_val[i]),\n        MM_VMANDN    => vs2_val[i] & not(vs1_val[i]),\n        MM_VMXOR     => vs2_val[i] != vs1_val[i],\n        MM_VMOR      => vs2_val[i] | vs1_val[i],\n        MM_VMNOR     => not(vs2_val[i] | vs1_val[i]),\n        MM_VMORN     => vs2_val[i] | not(vs1_val[i]),\n        MM_VMXNOR    => vs2_val[i] == vs1_val[i]\n      }\n    }\n  };\n\n  write_vmask(num_elem, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vnclip.wi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_nifunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW_widen <= 64);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let shift_amount = get_shift_amount(imm_val, SEW_widen);\n      let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n      result[i] = match funct6 {\n        NI_VNCLIPU => {\n                        let result_wide = (vs2_val[i] >> shift_amount) + zero_extend('o, rounding_incr);\n                        unsigned_saturation('m, result_wide)\n                      },\n        NI_VNCLIP  => {\n                        let v_double : bits('m * 4) = sign_extend(vs2_val[i]);\n                        let result_wide = slice(v_double >> shift_amount, 0, 'o) + zero_extend('o, rounding_incr);\n                        signed_saturation('m, result_wide)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vnclip.wv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_nvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW_widen <= 64);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let shift_amount = get_shift_amount(vs1_val[i], SEW_widen);\n      let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n      result[i] = match funct6 {\n        NV_VNCLIPU => {\n                        let result_wide = (vs2_val[i] >> shift_amount) + zero_extend('o, rounding_incr);\n                        unsigned_saturation('m, result_wide);\n                      },\n        NV_VNCLIP  => {\n                        let v_double : bits('m * 4) = sign_extend(vs2_val[i]);\n                        let result_wide = slice(v_double >> shift_amount, 0, 'o) + zero_extend('o, rounding_incr);\n                        signed_saturation('m, result_wide);\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vnclip.wx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_nxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW_widen <= 64);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let shift_amount = get_shift_amount(rs1_val, SEW_widen);\n      let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n      result[i] = match funct6 {\n        NX_VNCLIPU => {\n                        let result_wide = (vs2_val[i] >> shift_amount) + zero_extend('o, rounding_incr);\n                        unsigned_saturation('m, result_wide)\n                      },\n        NX_VNCLIP  => {\n                        let v_double : bits('m * 4) = sign_extend(vs2_val[i]);\n                        let result_wide = slice(v_double >> shift_amount, 0, 'o) + zero_extend('o, rounding_incr);\n                        signed_saturation('m, result_wide)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vnclipu.wi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_nifunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW_widen <= 64);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let shift_amount = get_shift_amount(imm_val, SEW_widen);\n      let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n      result[i] = match funct6 {\n        NI_VNCLIPU => {\n                        let result_wide = (vs2_val[i] >> shift_amount) + zero_extend('o, rounding_incr);\n                        unsigned_saturation('m, result_wide)\n                      },\n        NI_VNCLIP  => {\n                        let v_double : bits('m * 4) = sign_extend(vs2_val[i]);\n                        let result_wide = slice(v_double >> shift_amount, 0, 'o) + zero_extend('o, rounding_incr);\n                        signed_saturation('m, result_wide)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vnclipu.wv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_nvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW_widen <= 64);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let shift_amount = get_shift_amount(vs1_val[i], SEW_widen);\n      let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n      result[i] = match funct6 {\n        NV_VNCLIPU => {\n                        let result_wide = (vs2_val[i] >> shift_amount) + zero_extend('o, rounding_incr);\n                        unsigned_saturation('m, result_wide);\n                      },\n        NV_VNCLIP  => {\n                        let v_double : bits('m * 4) = sign_extend(vs2_val[i]);\n                        let result_wide = slice(v_double >> shift_amount, 0, 'o) + zero_extend('o, rounding_incr);\n                        signed_saturation('m, result_wide);\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vnclipu.wx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_nxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW_widen <= 64);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      let shift_amount = get_shift_amount(rs1_val, SEW_widen);\n      let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n      result[i] = match funct6 {\n        NX_VNCLIPU => {\n                        let result_wide = (vs2_val[i] >> shift_amount) + zero_extend('o, rounding_incr);\n                        unsigned_saturation('m, result_wide)\n                      },\n        NX_VNCLIP  => {\n                        let v_double : bits('m * 4) = sign_extend(vs2_val[i]);\n                        let result_wide = slice(v_double >> shift_amount, 0, 'o) + zero_extend('o, rounding_incr);\n                        signed_saturation('m, result_wide)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vnmsac.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvvmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVV_VMACC  => get_slice_int(SEW, signed(vs1_val[i]) * signed(vs2_val[i]), 0) + vd_val[i],\n        MVV_VNMSAC => vd_val[i] - get_slice_int(SEW, signed(vs1_val[i]) * signed(vs2_val[i]), 0),\n        MVV_VMADD  => get_slice_int(SEW, signed(vs1_val[i]) * signed(vd_val[i]), 0) + vs2_val[i],\n        MVV_VNMSUB => vs2_val[i] - get_slice_int(SEW, signed(vs1_val[i]) * signed(vd_val[i]), 0)\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vnmsac.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VMACC  => get_slice_int(SEW, signed(rs1_val) * signed(vs2_val[i]), 0) + vd_val[i],\n        MVX_VNMSAC => vd_val[i] - get_slice_int(SEW, signed(rs1_val) * signed(vs2_val[i]), 0),\n        MVX_VMADD  => get_slice_int(SEW, signed(rs1_val) * signed(vd_val[i]), 0) + vs2_val[i],\n        MVX_VNMSUB => vs2_val[i] - get_slice_int(SEW, signed(rs1_val) * signed(vd_val[i]), 0)\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vnmsub.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvvmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVV_VMACC  => get_slice_int(SEW, signed(vs1_val[i]) * signed(vs2_val[i]), 0) + vd_val[i],\n        MVV_VNMSAC => vd_val[i] - get_slice_int(SEW, signed(vs1_val[i]) * signed(vs2_val[i]), 0),\n        MVV_VMADD  => get_slice_int(SEW, signed(vs1_val[i]) * signed(vd_val[i]), 0) + vs2_val[i],\n        MVV_VNMSUB => vs2_val[i] - get_slice_int(SEW, signed(vs1_val[i]) * signed(vd_val[i]), 0)\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vnmsub.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxmafunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VMACC  => get_slice_int(SEW, signed(rs1_val) * signed(vs2_val[i]), 0) + vd_val[i],\n        MVX_VNMSAC => vd_val[i] - get_slice_int(SEW, signed(rs1_val) * signed(vs2_val[i]), 0),\n        MVX_VMADD  => get_slice_int(SEW, signed(rs1_val) * signed(vd_val[i]), 0) + vs2_val[i],\n        MVX_VNMSUB => vs2_val[i] - get_slice_int(SEW, signed(rs1_val) * signed(vd_val[i]), 0)\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vnsra.wi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_nisfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW_widen <= 64);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        NIS_VNSRL  => {\n                        let shift_amount = get_shift_amount(imm_val, SEW_widen);\n                        slice(vs2_val[i] >> shift_amount, 0, SEW)\n                      },\n        NIS_VNSRA  => {\n                        let shift_amount = get_shift_amount(imm_val, SEW_widen);\n                        let v_double : bits('o * 2) = sign_extend(vs2_val[i]);\n                        let arith_shifted : bits('o) = slice(v_double >> shift_amount, 0, SEW_widen);\n                        slice(arith_shifted, 0, SEW)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vnsra.wv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_nvsfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW_widen <= 64);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        NVS_VNSRL  => {\n                        let shift_amount = get_shift_amount(vs1_val[i], SEW_widen);\n                        slice(vs2_val[i] >> shift_amount, 0, SEW)\n                      },\n        NVS_VNSRA  => {\n                        let shift_amount = get_shift_amount(vs1_val[i], SEW_widen);\n                        let v_double : bits('o * 2) = sign_extend(vs2_val[i]);\n                        let arith_shifted : bits('o) = slice(v_double >> shift_amount, 0, SEW_widen);\n                        slice(arith_shifted, 0, SEW)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vnsra.wx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_nxsfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW_widen <= 64);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        NXS_VNSRL  => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW_widen);\n                        slice(vs2_val[i] >> shift_amount, 0, SEW)\n                      },\n        NXS_VNSRA  => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW_widen);\n                        let v_double : bits('o * 2) = sign_extend(vs2_val[i]);\n                        let arith_shifted : bits('o) = slice(v_double >> shift_amount, 0, SEW_widen);\n                        slice(arith_shifted, 0, SEW)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vnsrl.wi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_nisfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW_widen <= 64);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        NIS_VNSRL  => {\n                        let shift_amount = get_shift_amount(imm_val, SEW_widen);\n                        slice(vs2_val[i] >> shift_amount, 0, SEW)\n                      },\n        NIS_VNSRA  => {\n                        let shift_amount = get_shift_amount(imm_val, SEW_widen);\n                        let v_double : bits('o * 2) = sign_extend(vs2_val[i]);\n                        let arith_shifted : bits('o) = slice(v_double >> shift_amount, 0, SEW_widen);\n                        slice(arith_shifted, 0, SEW)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vnsrl.wv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_nvsfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW_widen <= 64);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        NVS_VNSRL  => {\n                        let shift_amount = get_shift_amount(vs1_val[i], SEW_widen);\n                        slice(vs2_val[i] >> shift_amount, 0, SEW)\n                      },\n        NVS_VNSRA  => {\n                        let shift_amount = get_shift_amount(vs1_val[i], SEW_widen);\n                        let v_double : bits('o * 2) = sign_extend(vs2_val[i]);\n                        let arith_shifted : bits('o) = slice(v_double >> shift_amount, 0, SEW_widen);\n                        slice(arith_shifted, 0, SEW)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vnsrl.wx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_nxsfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW_widen <= 64);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        NXS_VNSRL  => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW_widen);\n                        slice(vs2_val[i] >> shift_amount, 0, SEW)\n                      },\n        NXS_VNSRA  => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW_widen);\n                        let v_double : bits('o * 2) = sign_extend(vs2_val[i]);\n                        let arith_shifted : bits('o) = slice(v_double >> shift_amount, 0, SEW_widen);\n                        slice(arith_shifted, 0, SEW)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vor.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vifunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VI_VADD    => vs2_val[i] + imm_val,\n        VI_VRSUB   => imm_val - vs2_val[i],\n        VI_VAND    => vs2_val[i] & imm_val,\n        VI_VOR     => vs2_val[i] | imm_val,\n        VI_VXOR    => vs2_val[i] ^ imm_val,\n        VI_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, imm_val) ),\n        VI_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, imm_val) ),\n        VI_VSLL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VI_VSRL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VI_VSRA    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VI_VSSRL   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VI_VSSRA   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vor.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vor.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vpopc.m",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "rd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010000", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "0b10000", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = unsigned(vlenb) * 8;\n\n  if illegal_vd_unmasked() | not(assert_vstart(0)) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\n  let vs2_val : vector('n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\n  var result  : vector('n, dec, bool) = undefined;\n  var mask    : vector('n, dec, bool) = undefined;\n\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vs2_val, vm_val);\n\n  var count : nat = 0;\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] & vs2_val[i] then count = count + 1;\n  };\n\n  X(rd) = to_bits(sizeof(xlen), count);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vredand.vs",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_rmvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\n\n  if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL };\n\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\n\n  let 'n = num_elem_vs;\n  let 'd = num_elem_vd;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\n  let vd_val  : vector('d, dec, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\n  let mask    : vector('n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\n\n  var sum : bits('m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\n  foreach (i from 0 to (num_elem_vs - 1)) {\n    if mask[i] then {\n      sum = match funct6 {\n        MVV_VREDSUM   => sum + vs2_val[i],\n        MVV_VREDAND   => sum & vs2_val[i],\n        MVV_VREDOR    => sum | vs2_val[i],\n        MVV_VREDXOR   => sum ^ vs2_val[i],\n        MVV_VREDMIN   => to_bits(SEW, min(signed(vs2_val[i]), signed(sum))),\n        MVV_VREDMINU  => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(sum))),\n        MVV_VREDMAX   => to_bits(SEW, max(signed(vs2_val[i]), signed(sum))),\n        MVV_VREDMAXU  => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(sum)))\n      }\n    }\n  };\n\n  write_single_element(SEW, 0, vd, sum);\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\n  /* TODO: configuration support for agnostic behavior */\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vredmax.vs",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_rmvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\n\n  if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL };\n\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\n\n  let 'n = num_elem_vs;\n  let 'd = num_elem_vd;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\n  let vd_val  : vector('d, dec, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\n  let mask    : vector('n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\n\n  var sum : bits('m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\n  foreach (i from 0 to (num_elem_vs - 1)) {\n    if mask[i] then {\n      sum = match funct6 {\n        MVV_VREDSUM   => sum + vs2_val[i],\n        MVV_VREDAND   => sum & vs2_val[i],\n        MVV_VREDOR    => sum | vs2_val[i],\n        MVV_VREDXOR   => sum ^ vs2_val[i],\n        MVV_VREDMIN   => to_bits(SEW, min(signed(vs2_val[i]), signed(sum))),\n        MVV_VREDMINU  => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(sum))),\n        MVV_VREDMAX   => to_bits(SEW, max(signed(vs2_val[i]), signed(sum))),\n        MVV_VREDMAXU  => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(sum)))\n      }\n    }\n  };\n\n  write_single_element(SEW, 0, vd, sum);\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\n  /* TODO: configuration support for agnostic behavior */\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vredmaxu.vs",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_rmvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\n\n  if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL };\n\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\n\n  let 'n = num_elem_vs;\n  let 'd = num_elem_vd;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\n  let vd_val  : vector('d, dec, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\n  let mask    : vector('n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\n\n  var sum : bits('m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\n  foreach (i from 0 to (num_elem_vs - 1)) {\n    if mask[i] then {\n      sum = match funct6 {\n        MVV_VREDSUM   => sum + vs2_val[i],\n        MVV_VREDAND   => sum & vs2_val[i],\n        MVV_VREDOR    => sum | vs2_val[i],\n        MVV_VREDXOR   => sum ^ vs2_val[i],\n        MVV_VREDMIN   => to_bits(SEW, min(signed(vs2_val[i]), signed(sum))),\n        MVV_VREDMINU  => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(sum))),\n        MVV_VREDMAX   => to_bits(SEW, max(signed(vs2_val[i]), signed(sum))),\n        MVV_VREDMAXU  => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(sum)))\n      }\n    }\n  };\n\n  write_single_element(SEW, 0, vd, sum);\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\n  /* TODO: configuration support for agnostic behavior */\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vredmin.vs",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_rmvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\n\n  if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL };\n\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\n\n  let 'n = num_elem_vs;\n  let 'd = num_elem_vd;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\n  let vd_val  : vector('d, dec, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\n  let mask    : vector('n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\n\n  var sum : bits('m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\n  foreach (i from 0 to (num_elem_vs - 1)) {\n    if mask[i] then {\n      sum = match funct6 {\n        MVV_VREDSUM   => sum + vs2_val[i],\n        MVV_VREDAND   => sum & vs2_val[i],\n        MVV_VREDOR    => sum | vs2_val[i],\n        MVV_VREDXOR   => sum ^ vs2_val[i],\n        MVV_VREDMIN   => to_bits(SEW, min(signed(vs2_val[i]), signed(sum))),\n        MVV_VREDMINU  => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(sum))),\n        MVV_VREDMAX   => to_bits(SEW, max(signed(vs2_val[i]), signed(sum))),\n        MVV_VREDMAXU  => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(sum)))\n      }\n    }\n  };\n\n  write_single_element(SEW, 0, vd, sum);\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\n  /* TODO: configuration support for agnostic behavior */\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vredminu.vs",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_rmvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\n\n  if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL };\n\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\n\n  let 'n = num_elem_vs;\n  let 'd = num_elem_vd;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\n  let vd_val  : vector('d, dec, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\n  let mask    : vector('n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\n\n  var sum : bits('m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\n  foreach (i from 0 to (num_elem_vs - 1)) {\n    if mask[i] then {\n      sum = match funct6 {\n        MVV_VREDSUM   => sum + vs2_val[i],\n        MVV_VREDAND   => sum & vs2_val[i],\n        MVV_VREDOR    => sum | vs2_val[i],\n        MVV_VREDXOR   => sum ^ vs2_val[i],\n        MVV_VREDMIN   => to_bits(SEW, min(signed(vs2_val[i]), signed(sum))),\n        MVV_VREDMINU  => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(sum))),\n        MVV_VREDMAX   => to_bits(SEW, max(signed(vs2_val[i]), signed(sum))),\n        MVV_VREDMAXU  => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(sum)))\n      }\n    }\n  };\n\n  write_single_element(SEW, 0, vd, sum);\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\n  /* TODO: configuration support for agnostic behavior */\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vredor.vs",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_rmvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\n\n  if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL };\n\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\n\n  let 'n = num_elem_vs;\n  let 'd = num_elem_vd;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\n  let vd_val  : vector('d, dec, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\n  let mask    : vector('n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\n\n  var sum : bits('m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\n  foreach (i from 0 to (num_elem_vs - 1)) {\n    if mask[i] then {\n      sum = match funct6 {\n        MVV_VREDSUM   => sum + vs2_val[i],\n        MVV_VREDAND   => sum & vs2_val[i],\n        MVV_VREDOR    => sum | vs2_val[i],\n        MVV_VREDXOR   => sum ^ vs2_val[i],\n        MVV_VREDMIN   => to_bits(SEW, min(signed(vs2_val[i]), signed(sum))),\n        MVV_VREDMINU  => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(sum))),\n        MVV_VREDMAX   => to_bits(SEW, max(signed(vs2_val[i]), signed(sum))),\n        MVV_VREDMAXU  => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(sum)))\n      }\n    }\n  };\n\n  write_single_element(SEW, 0, vd, sum);\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\n  /* TODO: configuration support for agnostic behavior */\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vredsum.vs",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_rmvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\n\n  if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL };\n\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\n\n  let 'n = num_elem_vs;\n  let 'd = num_elem_vd;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\n  let vd_val  : vector('d, dec, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\n  let mask    : vector('n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\n\n  var sum : bits('m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\n  foreach (i from 0 to (num_elem_vs - 1)) {\n    if mask[i] then {\n      sum = match funct6 {\n        MVV_VREDSUM   => sum + vs2_val[i],\n        MVV_VREDAND   => sum & vs2_val[i],\n        MVV_VREDOR    => sum | vs2_val[i],\n        MVV_VREDXOR   => sum ^ vs2_val[i],\n        MVV_VREDMIN   => to_bits(SEW, min(signed(vs2_val[i]), signed(sum))),\n        MVV_VREDMINU  => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(sum))),\n        MVV_VREDMAX   => to_bits(SEW, max(signed(vs2_val[i]), signed(sum))),\n        MVV_VREDMAXU  => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(sum)))\n      }\n    }\n  };\n\n  write_single_element(SEW, 0, vd, sum);\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\n  /* TODO: configuration support for agnostic behavior */\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vredxor.vs",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_rmvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\n\n  if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL };\n\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\n\n  let 'n = num_elem_vs;\n  let 'd = num_elem_vd;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\n  let vd_val  : vector('d, dec, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\n  let mask    : vector('n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\n\n  var sum : bits('m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\n  foreach (i from 0 to (num_elem_vs - 1)) {\n    if mask[i] then {\n      sum = match funct6 {\n        MVV_VREDSUM   => sum + vs2_val[i],\n        MVV_VREDAND   => sum & vs2_val[i],\n        MVV_VREDOR    => sum | vs2_val[i],\n        MVV_VREDXOR   => sum ^ vs2_val[i],\n        MVV_VREDMIN   => to_bits(SEW, min(signed(vs2_val[i]), signed(sum))),\n        MVV_VREDMINU  => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(sum))),\n        MVV_VREDMAX   => to_bits(SEW, max(signed(vs2_val[i]), signed(sum))),\n        MVV_VREDMAXU  => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(sum)))\n      }\n    }\n  };\n\n  write_single_element(SEW, 0, vd, sum);\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\n  /* TODO: configuration support for agnostic behavior */\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vrem.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVV_VAADDU   => {\n                          let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VAADD    => {\n                          let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUBU   => {\n                          let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUB    => {\n                          let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VDIVU    => {\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          to_bits(SEW, q)\n                        },\n        MVV_VDIV     => {\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* check for signed overflow */\n                          let q' : int = if q > elem_max then elem_min else q;\n                          to_bits(SEW, q')\n                        },\n        MVV_VREMU    => {\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        },\n        MVV_VREM     => {\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vrem.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VAADDU       => {\n                              let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VAADD        => {\n                              let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUBU       => {\n                              let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUB        => {\n                              let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VSLIDE1UP    => {\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        MVX_VSLIDE1DOWN  => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            },\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VDIVU        => {\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\n                              to_bits(SEW, q)\n                            },\n        MVX_VDIV         => {\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* check for signed overflow */\n                              let q' : int = if q > elem_max then elem_min else q;\n                              to_bits(SEW, q')\n                            },\n        MVX_VREMU        => {\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            },\n        MVX_VREM         => {\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vremu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVV_VAADDU   => {\n                          let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VAADD    => {\n                          let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                          slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUBU   => {\n                          let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VASUB    => {\n                          let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i]);\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                          slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                        },\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\n        MVV_VDIVU    => {\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          to_bits(SEW, q)\n                        },\n        MVV_VDIV     => {\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* check for signed overflow */\n                          let q' : int = if q > elem_max then elem_min else q;\n                          to_bits(SEW, q')\n                        },\n        MVV_VREMU    => {\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        },\n        MVV_VREM     => {\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\n                          to_bits(SEW, r)\n                        }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vremu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VAADDU       => {\n                              let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VAADD        => {\n                              let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUBU       => {\n                              let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUB        => {\n                              let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VSLIDE1UP    => {\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        MVX_VSLIDE1DOWN  => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            },\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VDIVU        => {\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\n                              to_bits(SEW, q)\n                            },\n        MVX_VDIV         => {\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* check for signed overflow */\n                              let q' : int = if q > elem_max then elem_min else q;\n                              to_bits(SEW, q')\n                            },\n        MVX_VREMU        => {\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            },\n        MVX_VREM         => {\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vrgather.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_visgfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : nat                       = unsigned(zero_extend(sizeof(xlen), simm));\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VI_VSLIDEUP    => {\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                            if i >= imm_val then vs2_val[i - imm_val] else vd_val[i]\n                          },\n        VI_VSLIDEDOWN  => {\n                            let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                            assert(VLMAX > 0 & VLMAX <= 'n);\n                            if i + imm_val < VLMAX then vs2_val[i + imm_val] else zeros()\n                          },\n        VI_VRGATHER    => {\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                            let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                            assert(VLMAX > 0 & VLMAX <= 'n);\n                            if imm_val < VLMAX then vs2_val[imm_val] else zeros()\n                          }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vrgather.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vrgather.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxsgfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : nat                       = unsigned(X(rs1));\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VSLIDEUP    => {\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                            if i >= rs1_val then vs2_val[i - rs1_val] else vd_val[i]\n                          },\n        VX_VSLIDEDOWN  => {\n                            let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                            assert(VLMAX > 0 & VLMAX <= 'n);\n                            if i + rs1_val < VLMAX then vs2_val[i + rs1_val] else zeros()\n                          },\n        VX_VRGATHER    => {\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                            let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                            assert(VLMAX > 0 & VLMAX <= 'n);\n                            if rs1_val < VLMAX then vs2_val[rs1_val] else zeros()\n                          }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vrgatherei16.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vrsub.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vifunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VI_VADD    => vs2_val[i] + imm_val,\n        VI_VRSUB   => imm_val - vs2_val[i],\n        VI_VAND    => vs2_val[i] & imm_val,\n        VI_VOR     => vs2_val[i] | imm_val,\n        VI_VXOR    => vs2_val[i] ^ imm_val,\n        VI_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, imm_val) ),\n        VI_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, imm_val) ),\n        VI_VSLL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VI_VSRL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VI_VSRA    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VI_VSSRL   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VI_VSSRA   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vrsub.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsadd.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vifunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VI_VADD    => vs2_val[i] + imm_val,\n        VI_VRSUB   => imm_val - vs2_val[i],\n        VI_VAND    => vs2_val[i] & imm_val,\n        VI_VOR     => vs2_val[i] | imm_val,\n        VI_VXOR    => vs2_val[i] ^ imm_val,\n        VI_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, imm_val) ),\n        VI_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, imm_val) ),\n        VI_VSLL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VI_VSRL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VI_VSRA    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VI_VSSRL   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VI_VSSRA   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsadd.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsadd.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsaddu.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vifunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VI_VADD    => vs2_val[i] + imm_val,\n        VI_VRSUB   => imm_val - vs2_val[i],\n        VI_VAND    => vs2_val[i] & imm_val,\n        VI_VOR     => vs2_val[i] | imm_val,\n        VI_VXOR    => vs2_val[i] ^ imm_val,\n        VI_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, imm_val) ),\n        VI_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, imm_val) ),\n        VI_VSLL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VI_VSRL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VI_VSRA    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VI_VSSRL   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VI_VSSRA   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsaddu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsaddu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsbc.vvm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,vs1,v0",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvmsfunct6(funct6)", "size": 6 }, { "field": "0b0", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  /* for bypassing normal masking in init_masked_result */\n  var vec_trues : vector('n, dec, bool) = undefined;\n  foreach (i from 0 to (num_elem - 1)) {\n    vec_trues[i] = true\n  };\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VVMS_VADC     => to_bits(SEW, unsigned(vs2_val[i]) + unsigned(vs1_val[i]) + unsigned(bool_to_bits(vm_val[i]))),\n        VVMS_VSBC     => to_bits(SEW, unsigned(vs2_val[i]) - unsigned(vs1_val[i]) - unsigned(bool_to_bits(vm_val[i])))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsbc.vxm",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd,vs2,rs1,v0",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxmsfunct6(funct6)", "size": 6 }, { "field": "0b0", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  /* for bypassing normal masking in init_masked_result */\n  var vec_trues : vector('n, dec, bool) = undefined;\n  foreach (i from 0 to (num_elem - 1)) {\n    vec_trues[i] = true\n  };\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VXMS_VADC     => to_bits(SEW, unsigned(vs2_val[i]) + unsigned(rs1_val) + unsigned(bool_to_bits(vm_val[i]))),\n        VXMS_VSBC     => to_bits(SEW, unsigned(vs2_val[i]) - unsigned(rs1_val) - unsigned(bool_to_bits(vm_val[i])))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vse16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vse32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vse64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vse8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsetivli",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "uimm", "type": "regidx", "optional": false },{ "name": "sew", "type": "bits(3)", "optional": false },{ "name": "lmul", "type": "bits(3)", "optional": true, "default": "m1" },{ "name": "ta", "type": "bits(1)", "optional": true, "default": "tu" },{ "name": "ma", "type": "bits(1)", "optional": true, "default": "mu" } ],
  "syntax": "rd,uimm,sew_flag(sew)maybe_lmul_flag(lmul)maybe_ta_flag(ta)maybe_ma_flag(ma)",
  "format": "TBD",
  "fields": [ { "field": "0b1100", "size": 4 }, { "field": "ma", "size": 1 }, { "field": "ta", "size": 1 }, { "field": "sew", "size": 3 }, { "field": "lmul", "size": 3 }, { "field": "uimm", "size": 5 }, { "field": "0b111", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  /* set vtype */\n  vtype.bits = 0b0 @ zeros(sizeof(xlen) - 9) @ ma @ ta @ sew @ lmul;\n\n  /* check new SEW and LMUL are legal and calculate VLMAX */\n  let VLEN_pow     = get_vlen_pow();\n  let ELEN_pow     = get_elen_pow();\n  let LMUL_pow_new = get_lmul_pow();\n  let SEW_pow_new  = get_sew_pow();\n  if SEW_pow_new > (LMUL_pow_new + ELEN_pow) then { handle_illegal_vtype(); return RETIRE_SUCCESS };\n  let VLMAX = 2 ^ (VLEN_pow + LMUL_pow_new - SEW_pow_new);\n\n  /* set vl according to VLMAX and AVL */\n  let AVL = unsigned(uimm); /* AVL is encoded as 5-bit zero-extended imm in the rs1 field */\n  vl = calculate_new_vl(AVL, VLMAX);\n  X(rd) = vl;\n\n  /* reset vstart to 0 */\n  vstart = zeros();\n\n  print_reg(\"CSR vtype <- \" ^ BitStr(vtype.bits));\n  print_reg(\"CSR vl <- \" ^ BitStr(vl));\n  print_reg(\"CSR vstart <- \" ^ BitStr(vstart));\n\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsetvl",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b1000000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b111", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let LMUL_pow_ori  = get_lmul_pow();\n  let SEW_pow_ori   = get_sew_pow();\n  let ratio_pow_ori = SEW_pow_ori - LMUL_pow_ori;\n\n  /* set vtype */\n  vtype.bits = X(rs2);\n\n  /* check new SEW and LMUL are legal and calculate VLMAX */\n  let VLEN_pow     = get_vlen_pow();\n  let ELEN_pow     = get_elen_pow();\n  let LMUL_pow_new = get_lmul_pow();\n  let SEW_pow_new  = get_sew_pow();\n  if SEW_pow_new > (LMUL_pow_new + ELEN_pow) then { handle_illegal_vtype(); return RETIRE_SUCCESS };\n  let VLMAX = 2 ^ (VLEN_pow + LMUL_pow_new - SEW_pow_new);\n\n  /* set vl according to VLMAX and AVL */\n  if (rs1 != 0b00000) then { /* normal stripmining */\n    let rs1_val = X(rs1);\n    let AVL = unsigned(rs1_val);\n    vl = calculate_new_vl(AVL, VLMAX);\n    X(rd) = vl;\n  } else if (rd != 0b00000) then { /* set vl to VLMAX */\n    let AVL = unsigned(ones(sizeof(xlen)));\n    vl = to_bits(sizeof(xlen), VLMAX);\n    X(rd) = vl;\n  } else { /* keep existing vl */\n    let AVL = unsigned(vl);\n    let ratio_pow_new = SEW_pow_new - LMUL_pow_new;\n    if (ratio_pow_new != ratio_pow_ori) then { handle_illegal_vtype(); return RETIRE_SUCCESS }\n  };\n\n  /* reset vstart to 0 */\n  vstart = zeros();\n\n  print_reg(\"CSR vtype <- \" ^ BitStr(vtype.bits));\n  print_reg(\"CSR vl <- \" ^ BitStr(vl));\n  print_reg(\"CSR vstart <- \" ^ BitStr(vstart));\n\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsetvli",
  "name": "TBD",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "sew", "type": "bits(3)", "optional": false },{ "name": "lmul", "type": "bits(3)", "optional": true, "default": "m1" },{ "name": "ta", "type": "bits(1)", "optional": true, "default": "tu" },{ "name": "ma", "type": "bits(1)", "optional": true, "default": "mu" } ],
  "syntax": "rd,rs1,sew_flag(sew)maybe_lmul_flag(lmul)maybe_ta_flag(ta)maybe_ma_flag(ma)",
  "format": "TBD",
  "fields": [ { "field": "0b0000", "size": 4 }, { "field": "ma", "size": 1 }, { "field": "ta", "size": 1 }, { "field": "sew", "size": 3 }, { "field": "lmul", "size": 3 }, { "field": "rs1", "size": 5 }, { "field": "0b111", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let LMUL_pow_ori  = get_lmul_pow();\n  let SEW_pow_ori   = get_sew_pow();\n  let ratio_pow_ori = SEW_pow_ori - LMUL_pow_ori;\n\n  /* set vtype */\n  vtype.bits = 0b0 @ zeros(sizeof(xlen) - 9) @ ma @ ta @ sew @ lmul;\n\n  /* check new SEW and LMUL are legal and calculate VLMAX */\n  let VLEN_pow     = get_vlen_pow();\n  let ELEN_pow     = get_elen_pow();\n  let LMUL_pow_new = get_lmul_pow();\n  let SEW_pow_new  = get_sew_pow();\n  if SEW_pow_new > (LMUL_pow_new + ELEN_pow) then { handle_illegal_vtype(); return RETIRE_SUCCESS };\n  let VLMAX = 2 ^ (VLEN_pow + LMUL_pow_new - SEW_pow_new);\n\n  /* set vl according to VLMAX and AVL */\n  if (rs1 != 0b00000) then { /* normal stripmining */\n    let rs1_val = X(rs1);\n    let AVL = unsigned(rs1_val);\n    vl = calculate_new_vl(AVL, VLMAX);\n    X(rd) = vl;\n  } else if (rd != 0b00000) then { /* set vl to VLMAX */\n    let AVL = unsigned(ones(sizeof(xlen)));\n    vl = to_bits(sizeof(xlen), VLMAX);\n    X(rd) = vl;\n  } else { /* keep existing vl */\n    let AVL = unsigned(vl);\n    let ratio_pow_new = SEW_pow_new - LMUL_pow_new;\n    if (ratio_pow_new != ratio_pow_ori) then { handle_illegal_vtype(); return RETIRE_SUCCESS }\n  };\n\n  /* reset vstart to 0 */\n  vstart = zeros();\n\n  print_reg(\"CSR vtype <- \" ^ BitStr(vtype.bits));\n  print_reg(\"CSR vl <- \" ^ BitStr(vl));\n  print_reg(\"CSR vstart <- \" ^ BitStr(vstart));\n\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsext.vf2",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vext2_vs1(funct6)", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_half = SEW / 2;\n  let LMUL_pow_half = LMUL_pow - 1;\n\n  if  illegal_variable_width(vd, vm, SEW_half, LMUL_pow_half) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_half, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_half;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_half, LMUL_pow_half, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW > SEW_half);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VEXT2_ZVF2 => zero_extend(vs2_val[i]),\n        VEXT2_SVF2 => sign_extend(vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsext.vf4",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vext4_vs1(funct6)", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_quart = SEW / 4;\n  let LMUL_pow_quart = LMUL_pow - 2;\n\n  if  illegal_variable_width(vd, vm, SEW_quart, LMUL_pow_quart) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_quart, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_quart;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_quart, LMUL_pow_quart, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW > SEW_quart);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VEXT4_ZVF4 => zero_extend(vs2_val[i]),\n        VEXT4_SVF4 => sign_extend(vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsext.vf8",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vext8_vs1(funct6)", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_eighth = SEW / 8;\n  let LMUL_pow_eighth = LMUL_pow - 3;\n\n  if  illegal_variable_width(vd, vm, SEW_eighth, LMUL_pow_eighth) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_eighth, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_eighth;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_eighth, LMUL_pow_eighth, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW > SEW_eighth);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VEXT8_ZVF8 => zero_extend(vs2_val[i]),\n        VEXT8_SVF8 => sign_extend(vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vslide1down.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VAADDU       => {\n                              let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VAADD        => {\n                              let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUBU       => {\n                              let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUB        => {\n                              let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VSLIDE1UP    => {\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        MVX_VSLIDE1DOWN  => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            },\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VDIVU        => {\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\n                              to_bits(SEW, q)\n                            },\n        MVX_VDIV         => {\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* check for signed overflow */\n                              let q' : int = if q > elem_max then elem_min else q;\n                              to_bits(SEW, q')\n                            },\n        MVX_VREMU        => {\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            },\n        MVX_VREM         => {\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vslide1up.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_mvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        MVX_VAADDU       => {\n                              let result_add = zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VAADD        => {\n                              let result_add = sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\n                              slice(result_add >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUBU       => {\n                              let result_sub = zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VASUB        => {\n                              let result_sub = sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val);\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\n                              slice(result_sub >> 1, 0, 'm) + zero_extend('m, rounding_incr)\n                            },\n        MVX_VSLIDE1UP    => {\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              if i == 0 then rs1_val else vs2_val[i - 1]\n                            },\n        MVX_VSLIDE1DOWN  => {\n                              let last_elem = get_end_element();\n                              assert(last_elem < num_elem);\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\n                            },\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\n        MVX_VDIVU        => {\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\n                              to_bits(SEW, q)\n                            },\n        MVX_VDIV         => {\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* check for signed overflow */\n                              let q' : int = if q > elem_max then elem_min else q;\n                              to_bits(SEW, q')\n                            },\n        MVX_VREMU        => {\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            },\n        MVX_VREM         => {\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\n                              to_bits(SEW, r)\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vslidedown.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_visgfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : nat                       = unsigned(zero_extend(sizeof(xlen), simm));\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VI_VSLIDEUP    => {\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                            if i >= imm_val then vs2_val[i - imm_val] else vd_val[i]\n                          },\n        VI_VSLIDEDOWN  => {\n                            let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                            assert(VLMAX > 0 & VLMAX <= 'n);\n                            if i + imm_val < VLMAX then vs2_val[i + imm_val] else zeros()\n                          },\n        VI_VRGATHER    => {\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                            let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                            assert(VLMAX > 0 & VLMAX <= 'n);\n                            if imm_val < VLMAX then vs2_val[imm_val] else zeros()\n                          }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vslidedown.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxsgfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : nat                       = unsigned(X(rs1));\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VSLIDEUP    => {\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                            if i >= rs1_val then vs2_val[i - rs1_val] else vd_val[i]\n                          },\n        VX_VSLIDEDOWN  => {\n                            let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                            assert(VLMAX > 0 & VLMAX <= 'n);\n                            if i + rs1_val < VLMAX then vs2_val[i + rs1_val] else zeros()\n                          },\n        VX_VRGATHER    => {\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                            let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                            assert(VLMAX > 0 & VLMAX <= 'n);\n                            if rs1_val < VLMAX then vs2_val[rs1_val] else zeros()\n                          }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vslideup.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_visgfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : nat                       = unsigned(zero_extend(sizeof(xlen), simm));\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VI_VSLIDEUP    => {\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                            if i >= imm_val then vs2_val[i - imm_val] else vd_val[i]\n                          },\n        VI_VSLIDEDOWN  => {\n                            let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                            assert(VLMAX > 0 & VLMAX <= 'n);\n                            if i + imm_val < VLMAX then vs2_val[i + imm_val] else zeros()\n                          },\n        VI_VRGATHER    => {\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                            let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                            assert(VLMAX > 0 & VLMAX <= 'n);\n                            if imm_val < VLMAX then vs2_val[imm_val] else zeros()\n                          }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vslideup.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxsgfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : nat                       = unsigned(X(rs1));\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VSLIDEUP    => {\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                            if i >= rs1_val then vs2_val[i - rs1_val] else vd_val[i]\n                          },\n        VX_VSLIDEDOWN  => {\n                            let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                            assert(VLMAX > 0 & VLMAX <= 'n);\n                            if i + rs1_val < VLMAX then vs2_val[i + rs1_val] else zeros()\n                          },\n        VX_VRGATHER    => {\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                            let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                            assert(VLMAX > 0 & VLMAX <= 'n);\n                            if rs1_val < VLMAX then vs2_val[rs1_val] else zeros()\n                          }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsll.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vifunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VI_VADD    => vs2_val[i] + imm_val,\n        VI_VRSUB   => imm_val - vs2_val[i],\n        VI_VAND    => vs2_val[i] & imm_val,\n        VI_VOR     => vs2_val[i] | imm_val,\n        VI_VXOR    => vs2_val[i] ^ imm_val,\n        VI_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, imm_val) ),\n        VI_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, imm_val) ),\n        VI_VSLL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VI_VSRL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VI_VSRA    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VI_VSSRL   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VI_VSSRA   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsll.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsll.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsm.v",
  "name": "TBD",
  "operands": [ { "name": "vd_or_vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vd_or_vs3,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "0b000", "size": 3 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01011", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd_or_vs3", "size": 5 }, { "field": "encdec_lsop(op)", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW = 8;\n  let EMUL_pow = 0;\n  let vl_val = unsigned(vl);\n  let evl : int = if vl_val % 8 == 0 then vl_val / 8 else vl_val / 8 + 1; /* the effective vector length is evl=ceil(vl/8) */\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\n\n  assert(evl >= 0);\n  process_vm(vd_or_vs3, rs1, num_elem, evl, op)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsmul.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsmul.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxei16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxei32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxei64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxei8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg2ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg2ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg2ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg2ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg3ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg3ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg3ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg3ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg4ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg4ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg4ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg4ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg5ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg5ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg5ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg5ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg6ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg6ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg6ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg6ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg7ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg7ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg7ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg7ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg8ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg8ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg8ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsoxseg8ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsr.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vs3,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = 1;\n  let EEW = 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsra.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vifunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VI_VADD    => vs2_val[i] + imm_val,\n        VI_VRSUB   => imm_val - vs2_val[i],\n        VI_VAND    => vs2_val[i] & imm_val,\n        VI_VOR     => vs2_val[i] | imm_val,\n        VI_VXOR    => vs2_val[i] ^ imm_val,\n        VI_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, imm_val) ),\n        VI_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, imm_val) ),\n        VI_VSLL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VI_VSRL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VI_VSRA    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VI_VSSRL   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VI_VSSRA   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsra.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsra.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsrl.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vifunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VI_VADD    => vs2_val[i] + imm_val,\n        VI_VRSUB   => imm_val - vs2_val[i],\n        VI_VAND    => vs2_val[i] & imm_val,\n        VI_VOR     => vs2_val[i] | imm_val,\n        VI_VXOR    => vs2_val[i] ^ imm_val,\n        VI_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, imm_val) ),\n        VI_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, imm_val) ),\n        VI_VSLL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VI_VSRL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VI_VSRA    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VI_VSSRL   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VI_VSSRA   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsrl.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsrl.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsse16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsse32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsse64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsse8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg2e16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg2e32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg2e64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg2e8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg2r.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vs3,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = 1;\n  let EEW = 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg3e16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg3e32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg3e64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg3e8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg3r.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vs3,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = 1;\n  let EEW = 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg4e16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg4e32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg4e64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg4e8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg4r.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vs3,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = 1;\n  let EEW = 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg5e16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg5e32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg5e64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg5e8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg5r.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vs3,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = 1;\n  let EEW = 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg6e16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg6e32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg6e64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg6e8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg6r.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vs3,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = 1;\n  let EEW = 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg7e16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg7e32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg7e64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg7e8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg7r.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vs3,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = 1;\n  let EEW = 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg8e16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg8e32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg8e64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg8e8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1)vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsseg8r.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "vs3,(rs1)",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b00", "size": 2 }, { "field": "0b1", "size": 1 }, { "field": "0b01000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = 1;\n  let EEW = 8;\n  let VLEN = unsigned(vlenb) * 8;\n  let elem_per_reg : int = VLEN / EEW;\n  let nf_int = nfields_int(nf);\n\n  assert(elem_per_reg >= 0);\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssra.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vifunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VI_VADD    => vs2_val[i] + imm_val,\n        VI_VRSUB   => imm_val - vs2_val[i],\n        VI_VAND    => vs2_val[i] & imm_val,\n        VI_VOR     => vs2_val[i] | imm_val,\n        VI_VXOR    => vs2_val[i] ^ imm_val,\n        VI_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, imm_val) ),\n        VI_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, imm_val) ),\n        VI_VSLL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VI_VSRL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VI_VSRA    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VI_VSSRL   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VI_VSSRA   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssra.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssra.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssrl.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vifunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VI_VADD    => vs2_val[i] + imm_val,\n        VI_VRSUB   => imm_val - vs2_val[i],\n        VI_VAND    => vs2_val[i] & imm_val,\n        VI_VOR     => vs2_val[i] | imm_val,\n        VI_VXOR    => vs2_val[i] ^ imm_val,\n        VI_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, imm_val) ),\n        VI_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, imm_val) ),\n        VI_VSLL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VI_VSRL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VI_VSRA    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VI_VSSRL   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VI_VSSRA   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssrl.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssrl.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg2e16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg2e32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg2e64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg2e8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg3e16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg3e32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg3e64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg3e8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg4e16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg4e32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg4e64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg4e8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg5e16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg5e32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg5e64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg5e8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg6e16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg6e32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg6e64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg6e8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg7e16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg7e32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg7e64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg7e8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg8e16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg8e32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg8e64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssseg8e8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),rs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b10", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let load_width_bytes = vlewidth_bytesnumber(width);\n  let EEW = load_width_bytes * 8;\n  let EEW_pow = vlewidth_pow(width);\n  let SEW_pow = get_sew_pow();\n  let LMUL_pow = get_lmul_pow();\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\n  let num_elem = get_num_elem(EMUL_pow, EEW);\n  let nf_int = nfields_int(nf);\n\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssub.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssub.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssubu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vssubu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsub.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsub.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxei16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxei32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxei64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxei8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg2ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg2ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg2ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg2ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg3ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg3ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg3ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg3ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg4ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg4ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg4ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg4ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg5ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg5ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg5ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg5ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg6ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg6ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg6ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg6ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg7ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg7ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg7ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg7ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg8ei16.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg8ei32.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg8ei64.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vsuxseg8ei8.v",
  "name": "TBD",
  "operands": [ { "name": "vs3", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vs3,(rs1),vs2vm",
  "format": "TBD",
  "fields": [ { "field": "nf", "size": 0 }, { "field": "0b0", "size": 1 }, { "field": "0b01", "size": 2 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "encdec_vlewidth(width)", "size": 3 }, { "field": "vs3", "size": 5 }, { "field": "0b0100111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let EEW_index_pow = vlewidth_pow(width);\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\n  let EEW_data_pow = get_sew_pow();\n  let EEW_data_bytes = get_sew_bytes();\n  let EMUL_data_pow = get_lmul_pow();\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\n  let nf_int = nfields_int(nf);\n\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\n\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwadd.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WVV_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\n        WVV_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\n        WVV_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\n        WVV_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i])),\n        WVV_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(vs1_val[i])),\n        WVV_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(vs1_val[i])),\n        WVV_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(vs1_val[i]))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwadd.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WVX_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\n        WVX_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\n        WVX_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\n        WVX_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val)),\n        WVX_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(rs1_val)),\n        WVX_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(rs1_val)),\n        WVX_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(rs1_val))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwadd.wv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WV_VADD  => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\n        WV_VSUB  => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\n        WV_VADDU => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\n        WV_VSUBU => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i]))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwadd.wx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen)\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WX_VADD  => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\n        WX_VSUB  => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\n        WX_VADDU => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\n        WX_VSUBU => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwaddu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WVV_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\n        WVV_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\n        WVV_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\n        WVV_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i])),\n        WVV_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(vs1_val[i])),\n        WVV_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(vs1_val[i])),\n        WVV_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(vs1_val[i]))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwaddu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WVX_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\n        WVX_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\n        WVX_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\n        WVX_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val)),\n        WVX_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(rs1_val)),\n        WVX_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(rs1_val)),\n        WVX_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(rs1_val))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwaddu.wv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WV_VADD  => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\n        WV_VSUB  => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\n        WV_VADDU => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\n        WV_VSUBU => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i]))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwaddu.wx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen)\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WX_VADD  => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\n        WX_VSUB  => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\n        WX_VADDU => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\n        WX_VSUBU => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwmacc.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wmvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WMVV_VWMACC   => to_bits(SEW_widen, signed(vs1_val[i]) * signed(vs2_val[i])) + vd_val[i],\n        WMVV_VWMACCU  => to_bits(SEW_widen, unsigned(vs1_val[i]) * unsigned(vs2_val[i])) + vd_val[i],\n        WMVV_VWMACCSU => to_bits(SEW_widen, signed(vs1_val[i]) * unsigned(vs2_val[i]))+ vd_val[i]\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwmacc.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wmvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WMVX_VWMACCU  => (to_bits(SEW_widen, unsigned(rs1_val) * unsigned(vs2_val[i]) )) + vd_val[i],\n        WMVX_VWMACC   => (to_bits(SEW_widen, signed(rs1_val) * signed(vs2_val[i]) )) + vd_val[i],\n        WMVX_VWMACCUS => (to_bits(SEW_widen, unsigned(rs1_val) * signed(vs2_val[i]) ))+ vd_val[i],\n        WMVX_VWMACCSU => (to_bits(SEW_widen, signed(rs1_val) * unsigned(vs2_val[i]) ))+ vd_val[i]\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwmaccsu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wmvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WMVV_VWMACC   => to_bits(SEW_widen, signed(vs1_val[i]) * signed(vs2_val[i])) + vd_val[i],\n        WMVV_VWMACCU  => to_bits(SEW_widen, unsigned(vs1_val[i]) * unsigned(vs2_val[i])) + vd_val[i],\n        WMVV_VWMACCSU => to_bits(SEW_widen, signed(vs1_val[i]) * unsigned(vs2_val[i]))+ vd_val[i]\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwmaccsu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wmvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WMVX_VWMACCU  => (to_bits(SEW_widen, unsigned(rs1_val) * unsigned(vs2_val[i]) )) + vd_val[i],\n        WMVX_VWMACC   => (to_bits(SEW_widen, signed(rs1_val) * signed(vs2_val[i]) )) + vd_val[i],\n        WMVX_VWMACCUS => (to_bits(SEW_widen, unsigned(rs1_val) * signed(vs2_val[i]) ))+ vd_val[i],\n        WMVX_VWMACCSU => (to_bits(SEW_widen, signed(rs1_val) * unsigned(vs2_val[i]) ))+ vd_val[i]\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwmaccu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wmvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WMVV_VWMACC   => to_bits(SEW_widen, signed(vs1_val[i]) * signed(vs2_val[i])) + vd_val[i],\n        WMVV_VWMACCU  => to_bits(SEW_widen, unsigned(vs1_val[i]) * unsigned(vs2_val[i])) + vd_val[i],\n        WMVV_VWMACCSU => to_bits(SEW_widen, signed(vs1_val[i]) * unsigned(vs2_val[i]))+ vd_val[i]\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwmaccu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wmvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WMVX_VWMACCU  => (to_bits(SEW_widen, unsigned(rs1_val) * unsigned(vs2_val[i]) )) + vd_val[i],\n        WMVX_VWMACC   => (to_bits(SEW_widen, signed(rs1_val) * signed(vs2_val[i]) )) + vd_val[i],\n        WMVX_VWMACCUS => (to_bits(SEW_widen, unsigned(rs1_val) * signed(vs2_val[i]) ))+ vd_val[i],\n        WMVX_VWMACCSU => (to_bits(SEW_widen, signed(rs1_val) * unsigned(vs2_val[i]) ))+ vd_val[i]\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwmaccus.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,rs1,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wmvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WMVX_VWMACCU  => (to_bits(SEW_widen, unsigned(rs1_val) * unsigned(vs2_val[i]) )) + vd_val[i],\n        WMVX_VWMACC   => (to_bits(SEW_widen, signed(rs1_val) * signed(vs2_val[i]) )) + vd_val[i],\n        WMVX_VWMACCUS => (to_bits(SEW_widen, unsigned(rs1_val) * signed(vs2_val[i]) ))+ vd_val[i],\n        WMVX_VWMACCSU => (to_bits(SEW_widen, signed(rs1_val) * unsigned(vs2_val[i]) ))+ vd_val[i]\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwmul.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WVV_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\n        WVV_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\n        WVV_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\n        WVV_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i])),\n        WVV_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(vs1_val[i])),\n        WVV_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(vs1_val[i])),\n        WVV_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(vs1_val[i]))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwmul.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WVX_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\n        WVX_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\n        WVX_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\n        WVX_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val)),\n        WVX_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(rs1_val)),\n        WVX_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(rs1_val)),\n        WVX_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(rs1_val))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwmulsu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WVV_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\n        WVV_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\n        WVV_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\n        WVV_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i])),\n        WVV_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(vs1_val[i])),\n        WVV_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(vs1_val[i])),\n        WVV_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(vs1_val[i]))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwmulsu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WVX_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\n        WVX_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\n        WVX_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\n        WVX_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val)),\n        WVX_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(rs1_val)),\n        WVX_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(rs1_val)),\n        WVX_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(rs1_val))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwmulu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WVV_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\n        WVV_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\n        WVV_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\n        WVV_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i])),\n        WVV_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(vs1_val[i])),\n        WVV_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(vs1_val[i])),\n        WVV_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(vs1_val[i]))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwmulu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WVX_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\n        WVX_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\n        WVX_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\n        WVX_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val)),\n        WVX_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(rs1_val)),\n        WVX_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(rs1_val)),\n        WVX_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(rs1_val))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwredsum.vs",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_rivvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\n  let num_elem_vd = get_num_elem(0, SEW_widen); /* vd regardless of LMUL setting */\n\n  if illegal_reduction_widen(SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL };\n\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\n\n  let 'n = num_elem_vs;\n  let 'd = num_elem_vd;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\n  let vd_val  : vector('d, dec, bits('o)) = read_vreg(num_elem_vd, SEW_widen, 0, vd);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\n  let mask    : vector('n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\n\n  var sum : bits('o) = read_single_element(SEW_widen, 0, vs1); /* vs1 regardless of LMUL setting */\n  foreach (i from 0 to (num_elem_vs - 1)) {\n    if mask[i] then {\n      let elem : bits('o) = match funct6 {\n        IVV_VWREDSUMU  => to_bits(SEW_widen, unsigned(vs2_val[i])),\n        IVV_VWREDSUM   => to_bits(SEW_widen, signed(vs2_val[i]))\n      };\n      sum = sum + elem\n    }\n  };\n\n  write_single_element(SEW_widen, 0, vd, sum);\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\n  /* TODO: configuration support for agnostic behavior */\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwredsumu.vs",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_rivvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\n  let num_elem_vd = get_num_elem(0, SEW_widen); /* vd regardless of LMUL setting */\n\n  if illegal_reduction_widen(SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL };\n\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\n\n  let 'n = num_elem_vs;\n  let 'd = num_elem_vd;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\n  let vd_val  : vector('d, dec, bits('o)) = read_vreg(num_elem_vd, SEW_widen, 0, vd);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\n  let mask    : vector('n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\n\n  var sum : bits('o) = read_single_element(SEW_widen, 0, vs1); /* vs1 regardless of LMUL setting */\n  foreach (i from 0 to (num_elem_vs - 1)) {\n    if mask[i] then {\n      let elem : bits('o) = match funct6 {\n        IVV_VWREDSUMU  => to_bits(SEW_widen, unsigned(vs2_val[i])),\n        IVV_VWREDSUM   => to_bits(SEW_widen, signed(vs2_val[i]))\n      };\n      sum = sum + elem\n    }\n  };\n\n  write_single_element(SEW_widen, 0, vd, sum);\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\n  /* TODO: configuration support for agnostic behavior */\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwsub.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WVV_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\n        WVV_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\n        WVV_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\n        WVV_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i])),\n        WVV_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(vs1_val[i])),\n        WVV_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(vs1_val[i])),\n        WVV_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(vs1_val[i]))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwsub.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WVX_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\n        WVX_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\n        WVX_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\n        WVX_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val)),\n        WVX_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(rs1_val)),\n        WVX_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(rs1_val)),\n        WVX_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(rs1_val))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwsub.wv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WV_VADD  => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\n        WV_VSUB  => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\n        WV_VADDU => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\n        WV_VSUBU => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i]))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwsub.wx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen)\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WX_VADD  => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\n        WX_VSUB  => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\n        WX_VADDU => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\n        WX_VSUBU => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwsubu.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WVV_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\n        WVV_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\n        WVV_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\n        WVV_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i])),\n        WVV_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(vs1_val[i])),\n        WVV_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(vs1_val[i])),\n        WVV_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(vs1_val[i]))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwsubu.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WVX_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\n        WVX_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\n        WVX_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\n        WVX_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val)),\n        WVX_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(rs1_val)),\n        WVX_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(rs1_val)),\n        WVX_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(rs1_val))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwsubu.wv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WV_VADD  => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\n        WV_VSUB  => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\n        WV_VADDU => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\n        WV_VSUBU => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i]))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vwsubu.wx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_wxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b110", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n\n  if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen)\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\n  var result  : vector('n, dec, bits('o)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        WX_VADD  => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\n        WX_VSUB  => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\n        WX_VADDU => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\n        WX_VSUBU => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vxor.vi",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "simm", "type": "bits(5)", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,simmvm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vifunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "simm", "size": 5 }, { "field": "0b011", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let imm_val : bits('m)                  = sign_extend(simm);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VI_VADD    => vs2_val[i] + imm_val,\n        VI_VRSUB   => imm_val - vs2_val[i],\n        VI_VAND    => vs2_val[i] & imm_val,\n        VI_VOR     => vs2_val[i] | imm_val,\n        VI_VXOR    => vs2_val[i] ^ imm_val,\n        VI_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, imm_val) ),\n        VI_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, imm_val) ),\n        VI_VSLL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VI_VSRL    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VI_VSRA    => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VI_VSSRL   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VI_VSSRA   => {\n                        let shift_amount = get_shift_amount(zero_extend('m, simm), SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vxor.vv",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,vs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vvfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vs1", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW_pow  = get_sew_pow();\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let VLEN_pow = get_vlen_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VV_VADD          => vs2_val[i] + vs1_val[i],\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\n        VV_VAND          => vs2_val[i] & vs1_val[i],\n        VV_VOR           => vs2_val[i] | vs1_val[i],\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\n        VV_VSADDU        => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, vs1_val[i])),\n        VV_VSADD         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, vs1_val[i])),\n        VV_VSSUBU        => {\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\n                              else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, vs1_val[i]))\n                            },\n        VV_VSSUB         => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, vs1_val[i])),\n        VV_VSMUL         => {\n                              let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                              let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                              signed_saturation('m, result_wide['m..0])\n                            },\n        VV_VSLL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] << shift_amount\n                            },\n        VV_VSRL          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              vs2_val[i] >> shift_amount\n                            },\n        VV_VSRA          => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW)\n                            },\n        VV_VSSRL         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                            },\n        VV_VSSRA         => {\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                              let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                            },\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\n        VV_VRGATHER      => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              let idx = unsigned(vs1_val[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            },\n        VV_VRGATHEREI16  => {\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\n                              let vs1_new : vector('n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\n                              let idx = unsigned(vs1_new[i]);\n                              let VLMAX = 2 ^ (LMUL_pow + VLEN_pow - SEW_pow);\n                              assert(VLMAX <= 'n);\n                              if idx < VLMAX then vs2_val[idx] else zeros()\n                            }\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vxor.vx",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2,rs1vm",
  "format": "TBD",
  "fields": [ { "field": "encdec_vxfunct6(funct6)", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW      = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let rs1_val : bits('m)                  = get_scalar(rs1, SEW);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VX_VADD    => vs2_val[i] + rs1_val,\n        VX_VSUB    => vs2_val[i] - rs1_val,\n        VX_VRSUB   => rs1_val - vs2_val[i],\n        VX_VAND    => vs2_val[i] & rs1_val,\n        VX_VOR     => vs2_val[i] | rs1_val,\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\n        VX_VSADDU  => unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) + zero_extend('m + 1, rs1_val) ),\n        VX_VSADD   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) + sign_extend('m + 1, rs1_val) ),\n        VX_VSSUBU  => {\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\n                        else unsigned_saturation('m, zero_extend('m + 1, vs2_val[i]) - zero_extend('m + 1, rs1_val) )\n                      },\n        VX_VSSUB   => signed_saturation('m, sign_extend('m + 1, vs2_val[i]) - sign_extend('m + 1, rs1_val) ),\n        VX_VSMUL   => {\n                        let result_mul = to_bits('m * 2, signed(vs2_val[i]) * signed(rs1_val));\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, 'm - 1);\n                        let result_wide = (result_mul >> ('m - 1)) + zero_extend('m * 2, rounding_incr);\n                        signed_saturation('m, result_wide['m..0])\n                      },\n        VX_VSLL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] << shift_amount\n                      },\n        VX_VSRL    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        vs2_val[i] >> shift_amount\n                      },\n        VX_VSRA    => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW)\n                      },\n        VX_VSSRL   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        (vs2_val[i] >> shift_amount) + zero_extend('m, rounding_incr)\n                      },\n        VX_VSSRA   => {\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\n                        let v_double : bits('m * 2) = sign_extend(vs2_val[i]);\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend('m, rounding_incr)\n                      },\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vzext.vf2",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vext2_vs1(funct6)", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_half = SEW / 2;\n  let LMUL_pow_half = LMUL_pow - 1;\n\n  if  illegal_variable_width(vd, vm, SEW_half, LMUL_pow_half) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_half, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_half;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_half, LMUL_pow_half, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW > SEW_half);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VEXT2_ZVF2 => zero_extend(vs2_val[i]),\n        VEXT2_SVF2 => sign_extend(vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vzext.vf4",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vext4_vs1(funct6)", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_quart = SEW / 4;\n  let LMUL_pow_quart = LMUL_pow - 2;\n\n  if  illegal_variable_width(vd, vm, SEW_quart, LMUL_pow_quart) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_quart, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_quart;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_quart, LMUL_pow_quart, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW > SEW_quart);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VEXT4_ZVF4 => zero_extend(vs2_val[i]),\n        VEXT4_SVF4 => sign_extend(vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "vzext.vf8",
  "name": "TBD",
  "operands": [ { "name": "vd", "type": "regidx", "optional": false },{ "name": "vs2", "type": "regidx", "optional": false },{ "name": "vm", "type": "bits(1)", "optional": true, "default": "v0.t" } ],
  "syntax": "vd,vs2vm",
  "format": "TBD",
  "fields": [ { "field": "0b010010", "size": 6 }, { "field": "vm", "size": 1 }, { "field": "vs2", "size": 5 }, { "field": "vext8_vs1(funct6)", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "vd", "size": 5 }, { "field": "0b1010111", "size": 7 } ],
  "extensions": [ "V" ],
  "function": "{\n  let SEW = get_sew();\n  let LMUL_pow = get_lmul_pow();\n  let num_elem = get_num_elem(LMUL_pow, SEW);\n  let SEW_eighth = SEW / 8;\n  let LMUL_pow_eighth = LMUL_pow - 3;\n\n  if  illegal_variable_width(vd, vm, SEW_eighth, LMUL_pow_eighth) |\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_eighth, LMUL_pow))\n  then { handle_illegal(); return RETIRE_FAIL };\n\n  let 'n = num_elem;\n  let 'm = SEW;\n  let 'o = SEW_eighth;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\n  let vd_val  : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\n  let vs2_val : vector('n, dec, bits('o)) = read_vreg(num_elem, SEW_eighth, LMUL_pow_eighth, vs2);\n  var result  : vector('n, dec, bits('m)) = undefined;\n  var mask    : vector('n, dec, bool)     = undefined;\n\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\n\n  assert(SEW > SEW_eighth);\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then {\n      result[i] = match funct6 {\n        VEXT8_ZVF8 => zero_extend(vs2_val[i]),\n        VEXT8_SVF8 => sign_extend(vs2_val[i])\n      }\n    }\n  };\n\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\n  vstart = zeros();\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "wfi",
  "name": "TBD",
  "operands": [  ],
  "syntax": "",
  "format": "TBD",
  "fields": [ { "field": "0b000100000101", "size": 12 }, { "field": "0b00000", "size": 5 }, { "field": "0b000", "size": 3 }, { "field": "0b00000", "size": 5 }, { "field": "0b1110011", "size": 7 } ],
  "extensions": [  ],
  "function": "match cur_privilege {\n    Machine    => { platform_wfi(); RETIRE_SUCCESS },\n    Supervisor => if   mstatus[TW] == 0b1\n                  then { handle_illegal(); RETIRE_FAIL }\n                  else { platform_wfi(); RETIRE_SUCCESS },\n    User       => { handle_illegal(); RETIRE_FAIL }\n  }",
  "description": "TBD"
},
{
  "mnemonic": "xnor",
  "name": "exclusive NOR",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0110000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbb","Zbkb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ANDN => rs1_val & ~(rs2_val),\n    RISCV_ORN  => rs1_val | ~(rs2_val),\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\n    RISCV_ROL  => if sizeof(xlen) == 32\n                  then rs1_val <<< rs2_val[4..0]\n                  else rs1_val <<< rs2_val[5..0],\n    RISCV_ROR  => if sizeof(xlen) == 32\n                  then rs1_val >>> rs2_val[4..0]\n                  else rs1_val >>> rs2_val[5..0]\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "xor",
  "name": "exclusive OR",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0100000", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b101", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits = match op {\n    RISCV_ADD  => rs1_val + rs2_val,\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\n    RISCV_AND  => rs1_val & rs2_val,\n    RISCV_OR   => rs1_val | rs2_val,\n    RISCV_XOR  => rs1_val ^ rs2_val,\n    RISCV_SLL  => if   sizeof(xlen) == 32\n                  then rs1_val << (rs2_val[4..0])\n                  else rs1_val << (rs2_val[5..0]),\n    RISCV_SRL  => if   sizeof(xlen) == 32\n                  then rs1_val >> (rs2_val[4..0])\n                  else rs1_val >> (rs2_val[5..0]),\n    RISCV_SUB  => rs1_val - rs2_val,\n    RISCV_SRA  => if   sizeof(xlen) == 32\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe R-type (Register-type) instruction format is used for operations\nthat involve three registers. The specific operation is determined\nby the opcode and funct7 fields. The result is written to the\ndestination register (rd), and the source operands are specified\nby the source registers (rs1 and rs2). The format is common for\narithmetic, logical, and shift operations.\n "
},
{
  "mnemonic": "xori",
  "name": "XOR immediate",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "imm", "type": "bits(12)", "optional": false } ],
  "syntax": "rd,rs1,imm",
  "format": "TBD",
  "fields": [ { "field": "imm", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "encdec_iop(op)", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [  ],
  "function": "{\n  let rs1_val = X(rs1);\n  let immext : xlenbits = sign_extend(imm);\n  let result : xlenbits = match op {\n    RISCV_ADDI  => rs1_val + immext,\n    RISCV_SLTI  => zero_extend(bool_to_bits(rs1_val <_s immext)),\n    RISCV_SLTIU => zero_extend(bool_to_bits(rs1_val <_u immext)),\n    RISCV_ANDI  => rs1_val & immext,\n    RISCV_ORI   => rs1_val | immext,\n    RISCV_XORI  => rs1_val ^ immext\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "\nThe ITYPE instruction operates on an immediate value, adding, comparing, or\nperforming bitwise operations with the contents of register rs1.\nThe immediate value, rs1, and the operation code (iop) determine the operation.\nThe result is stored in register rd.\nThe supported immediate operations (iop) include:\n  - \"addi\"  : Add immediate\n  - \"slti\"  : Set less than immediate (signed)\n  - \"sltiu\" : Set less than immediate (unsigned)\n  - \"andi\"  : AND immediate\n  - \"ori\"   : OR immediate\n  - \"xori\"  : XOR immediate\n\nNote: The immediate value is sign-extended before performing the operation.\n "
},
{
  "mnemonic": "xperm4",
  "name": "crossbar permutation (nibbles)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010100", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b010", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbkx" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  var result : xlenbits = zeros();\n  foreach (i from 0 to (sizeof(xlen) - 4) by 4) {\n    let index = unsigned(rs2_val[i+3..i]);\n    result[i+3..i] = if 4*index < sizeof(xlen)\n                     then rs1_val[4*index+3..4*index]\n                     else zeros()\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "xperm8",
  "name": "crossbar permutation (bytes)",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false },{ "name": "rs2", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1,rs2",
  "format": "TBD",
  "fields": [ { "field": "0b0010100", "size": 7 }, { "field": "rs2", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0110011", "size": 7 } ],
  "extensions": [ "Zbkx" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  var result : xlenbits = zeros();\n  foreach (i from 0 to (sizeof(xlen) - 8) by 8) {\n    let index = unsigned(rs2_val[i+7..i]);\n    result[i+7..i] = if 8*index < sizeof(xlen)\n                     then rs1_val[8*index+7..8*index]\n                     else zeros()\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "zext.h",
  "name": "zero-extend halfword",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b0000100", "size": 7 }, { "field": "0b00000", "size": 5 }, { "field": "rs1", "size": 5 }, { "field": "0b100", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0111011", "size": 7 } ],
  "extensions": [ "Zbb" ],
  "function": "{\n  let rs1_val = X(rs1);\n  let result : xlenbits = match op {\n    RISCV_SEXTB => sign_extend(rs1_val[7..0]),\n    RISCV_SEXTH => sign_extend(rs1_val[15..0]),\n    RISCV_ZEXTH => zero_extend(rs1_val[15..0])\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
},
{
  "mnemonic": "zip",
  "name": "bit interleave",
  "operands": [ { "name": "rd", "type": "regidx", "optional": false },{ "name": "rs1", "type": "regidx", "optional": false } ],
  "syntax": "rd,rs1",
  "format": "TBD",
  "fields": [ { "field": "0b000010001111", "size": 12 }, { "field": "rs1", "size": 5 }, { "field": "0b001", "size": 3 }, { "field": "rd", "size": 5 }, { "field": "0b0010011", "size": 7 } ],
  "extensions": [ "Zbkb" ],
  "function": "{\n  assert(sizeof(xlen) == 32);\n  let rs1_val = X(rs1);\n  var result : xlenbits = zeros();\n  foreach (i from 0 to (sizeof(xlen_bytes)*4 - 1)) {\n    result[i*2] = rs1_val[i];\n    result[i*2 + 1] = rs1_val[i + sizeof(xlen_bytes)*4];\n  };\n  X(rd) = result;\n  RETIRE_SUCCESS\n}",
  "description": "TBD"
}
  ],
  "registers": 
[ 
  {
    "name": "mcounteren",
    "type": "Counteren"
  },

  {
    "name": "scounteren",
    "type": "Counteren"
  },

  {
    "name": "mcountinhibit",
    "type": "Counterin"
  },

  {
    "name": "fcsr",
    "type": "Fcsr"
  },

  {
    "name": "menvcfg",
    "type": "MEnvcfg"
  },

  {
    "name": "mcause",
    "type": "Mcause"
  },

  {
    "name": "scause",
    "type": "Mcause"
  },

  {
    "name": "ucause",
    "type": "Mcause"
  },

  {
    "name": "medeleg",
    "type": "Medeleg"
  },

  {
    "name": "mideleg",
    "type": "Minterrupts"
  },

  {
    "name": "mie",
    "type": "Minterrupts"
  },

  {
    "name": "mip",
    "type": "Minterrupts"
  },

  {
    "name": "misa",
    "type": "Misa"
  },

  {
    "name": "mstatus",
    "type": "Mstatus"
  },

  {
    "name": "mstatush",
    "type": "Mstatush"
  },

  {
    "name": "mtvec",
    "type": "Mtvec"
  },

  {
    "name": "stvec",
    "type": "Mtvec"
  },

  {
    "name": "utvec",
    "type": "Mtvec"
  },

  {
    "name": "cur_privilege",
    "type": "Privilege"
  },

  {
    "name": "senvcfg",
    "type": "SEnvcfg"
  },

  {
    "name": "sedeleg",
    "type": "Sedeleg"
  },

  {
    "name": "sideleg",
    "type": "Sinterrupts"
  },

  {
    "name": "vcsr",
    "type": "Vcsr"
  },

  {
    "name": "vtype",
    "type": "Vtype"
  },

  {
    "name": "htif_cmd_write",
    "type": "bit"
  },

  {
    "name": "elen",
    "type": "bits(1)"
  },

  {
    "name": "vxsat",
    "type": "bits(1)"
  },

  {
    "name": "vstart",
    "type": "bits(16)"
  },

  {
    "name": "vxrm",
    "type": "bits(2)"
  },

  {
    "name": "mvendorid",
    "type": "bits(32)"
  },

  {
    "name": "htif_payload_writes",
    "type": "bits(4)"
  },

  {
    "name": "vlen",
    "type": "bits(4)"
  },

  {
    "name": "float_fflags",
    "type": "bits(64)"
  },

  {
    "name": "float_result",
    "type": "bits(64)"
  },

  {
    "name": "htif_exit_code",
    "type": "bits(64)"
  },

  {
    "name": "htif_tohost",
    "type": "bits(64)"
  },

  {
    "name": "mcycle",
    "type": "bits(64)"
  },

  {
    "name": "minstret",
    "type": "bits(64)"
  },

  {
    "name": "mtime",
    "type": "bits(64)"
  },

  {
    "name": "mtimecmp",
    "type": "bits(64)"
  },

  {
    "name": "htif_done",
    "type": "bool"
  },

  {
    "name": "minstret_increment",
    "type": "bool"
  },

  {
    "name": "f0",
    "type": "fregtype"
  },

  {
    "name": "f1",
    "type": "fregtype"
  },

  {
    "name": "f10",
    "type": "fregtype"
  },

  {
    "name": "f11",
    "type": "fregtype"
  },

  {
    "name": "f12",
    "type": "fregtype"
  },

  {
    "name": "f13",
    "type": "fregtype"
  },

  {
    "name": "f14",
    "type": "fregtype"
  },

  {
    "name": "f15",
    "type": "fregtype"
  },

  {
    "name": "f16",
    "type": "fregtype"
  },

  {
    "name": "f17",
    "type": "fregtype"
  },

  {
    "name": "f18",
    "type": "fregtype"
  },

  {
    "name": "f19",
    "type": "fregtype"
  },

  {
    "name": "f2",
    "type": "fregtype"
  },

  {
    "name": "f20",
    "type": "fregtype"
  },

  {
    "name": "f21",
    "type": "fregtype"
  },

  {
    "name": "f22",
    "type": "fregtype"
  },

  {
    "name": "f23",
    "type": "fregtype"
  },

  {
    "name": "f24",
    "type": "fregtype"
  },

  {
    "name": "f25",
    "type": "fregtype"
  },

  {
    "name": "f26",
    "type": "fregtype"
  },

  {
    "name": "f27",
    "type": "fregtype"
  },

  {
    "name": "f28",
    "type": "fregtype"
  },

  {
    "name": "f29",
    "type": "fregtype"
  },

  {
    "name": "f3",
    "type": "fregtype"
  },

  {
    "name": "f30",
    "type": "fregtype"
  },

  {
    "name": "f31",
    "type": "fregtype"
  },

  {
    "name": "f4",
    "type": "fregtype"
  },

  {
    "name": "f5",
    "type": "fregtype"
  },

  {
    "name": "f6",
    "type": "fregtype"
  },

  {
    "name": "f7",
    "type": "fregtype"
  },

  {
    "name": "f8",
    "type": "fregtype"
  },

  {
    "name": "f9",
    "type": "fregtype"
  },

  {
    "name": "x1",
    "type": "regtype"
  },

  {
    "name": "x10",
    "type": "regtype"
  },

  {
    "name": "x11",
    "type": "regtype"
  },

  {
    "name": "x12",
    "type": "regtype"
  },

  {
    "name": "x13",
    "type": "regtype"
  },

  {
    "name": "x14",
    "type": "regtype"
  },

  {
    "name": "x15",
    "type": "regtype"
  },

  {
    "name": "x16",
    "type": "regtype"
  },

  {
    "name": "x17",
    "type": "regtype"
  },

  {
    "name": "x18",
    "type": "regtype"
  },

  {
    "name": "x19",
    "type": "regtype"
  },

  {
    "name": "x2",
    "type": "regtype"
  },

  {
    "name": "x20",
    "type": "regtype"
  },

  {
    "name": "x21",
    "type": "regtype"
  },

  {
    "name": "x22",
    "type": "regtype"
  },

  {
    "name": "x23",
    "type": "regtype"
  },

  {
    "name": "x24",
    "type": "regtype"
  },

  {
    "name": "x25",
    "type": "regtype"
  },

  {
    "name": "x26",
    "type": "regtype"
  },

  {
    "name": "x27",
    "type": "regtype"
  },

  {
    "name": "x28",
    "type": "regtype"
  },

  {
    "name": "x29",
    "type": "regtype"
  },

  {
    "name": "x3",
    "type": "regtype"
  },

  {
    "name": "x30",
    "type": "regtype"
  },

  {
    "name": "x31",
    "type": "regtype"
  },

  {
    "name": "x4",
    "type": "regtype"
  },

  {
    "name": "x5",
    "type": "regtype"
  },

  {
    "name": "x6",
    "type": "regtype"
  },

  {
    "name": "x7",
    "type": "regtype"
  },

  {
    "name": "x8",
    "type": "regtype"
  },

  {
    "name": "x9",
    "type": "regtype"
  },

  {
    "name": "pmpcfg_n",
    "type": "vector(64, Pmpcfg_ent)"
  },

  {
    "name": "pmpaddr_n",
    "type": "vector(64, xlenbits)"
  },

  {
    "name": "tlb",
    "type": "vector(num_tlb_entries, option(TLB_Entry))"
  },

  {
    "name": "vr0",
    "type": "vregtype"
  },

  {
    "name": "vr1",
    "type": "vregtype"
  },

  {
    "name": "vr10",
    "type": "vregtype"
  },

  {
    "name": "vr11",
    "type": "vregtype"
  },

  {
    "name": "vr12",
    "type": "vregtype"
  },

  {
    "name": "vr13",
    "type": "vregtype"
  },

  {
    "name": "vr14",
    "type": "vregtype"
  },

  {
    "name": "vr15",
    "type": "vregtype"
  },

  {
    "name": "vr16",
    "type": "vregtype"
  },

  {
    "name": "vr17",
    "type": "vregtype"
  },

  {
    "name": "vr18",
    "type": "vregtype"
  },

  {
    "name": "vr19",
    "type": "vregtype"
  },

  {
    "name": "vr2",
    "type": "vregtype"
  },

  {
    "name": "vr20",
    "type": "vregtype"
  },

  {
    "name": "vr21",
    "type": "vregtype"
  },

  {
    "name": "vr22",
    "type": "vregtype"
  },

  {
    "name": "vr23",
    "type": "vregtype"
  },

  {
    "name": "vr24",
    "type": "vregtype"
  },

  {
    "name": "vr25",
    "type": "vregtype"
  },

  {
    "name": "vr26",
    "type": "vregtype"
  },

  {
    "name": "vr27",
    "type": "vregtype"
  },

  {
    "name": "vr28",
    "type": "vregtype"
  },

  {
    "name": "vr29",
    "type": "vregtype"
  },

  {
    "name": "vr3",
    "type": "vregtype"
  },

  {
    "name": "vr30",
    "type": "vregtype"
  },

  {
    "name": "vr31",
    "type": "vregtype"
  },

  {
    "name": "vr4",
    "type": "vregtype"
  },

  {
    "name": "vr5",
    "type": "vregtype"
  },

  {
    "name": "vr6",
    "type": "vregtype"
  },

  {
    "name": "vr7",
    "type": "vregtype"
  },

  {
    "name": "vr8",
    "type": "vregtype"
  },

  {
    "name": "vr9",
    "type": "vregtype"
  },

  {
    "name": "PC",
    "type": "xlenbits"
  },

  {
    "name": "cur_inst",
    "type": "xlenbits"
  },

  {
    "name": "instbits",
    "type": "xlenbits"
  },

  {
    "name": "marchid",
    "type": "xlenbits"
  },

  {
    "name": "mconfigptr",
    "type": "xlenbits"
  },

  {
    "name": "mepc",
    "type": "xlenbits"
  },

  {
    "name": "mhartid",
    "type": "xlenbits"
  },

  {
    "name": "mimpid",
    "type": "xlenbits"
  },

  {
    "name": "mscratch",
    "type": "xlenbits"
  },

  {
    "name": "mtval",
    "type": "xlenbits"
  },

  {
    "name": "nextPC",
    "type": "xlenbits"
  },

  {
    "name": "satp",
    "type": "xlenbits"
  },

  {
    "name": "sepc",
    "type": "xlenbits"
  },

  {
    "name": "sscratch",
    "type": "xlenbits"
  },

  {
    "name": "stval",
    "type": "xlenbits"
  },

  {
    "name": "tselect",
    "type": "xlenbits"
  },

  {
    "name": "uepc",
    "type": "xlenbits"
  },

  {
    "name": "uscratch",
    "type": "xlenbits"
  },

  {
    "name": "utval",
    "type": "xlenbits"
  },

  {
    "name": "vl",
    "type": "xlenbits"
  },

  {
    "name": "vlenb",
    "type": "xlenbits"
  }
]
,
  "formats": [
"I",
"R",
"TBD"
  ],
  "extensions": [
"D",
"F",
"M",
"Svinval",
"V",
"Zaamo",
"Zalrsc",
"Zba",
"Zbb",
"Zbc",
"Zbkb",
"Zbkc",
"Zbkx",
"Zbs",
"Zca",
"Zcb",
"Zcd",
"Zcf",
"Zfa",
"Zfh",
"Zicbom",
"Zicboz",
"Zicond",
"Zknd",
"Zkne",
"Zknh",
"Zksed",
"Zksh",
"Zmmul"
  ],
  "functions": [
  {
    "name": "riscv_f32Div",
    "source": "{\n  extern_f32Div(rm, v1, v2);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "fmake_H",
    "source": "sign @ exp @ mant"
  },
  {
    "name": "undefined_RISCV_strong_access",
    "source": "Error - couldn't locate func"
  },
  {
    "name": "riscv_f16ToUi16",
    "source": "{\n  let (_, sig32) = riscv_f16ToUi32(rm, v);\n  if unsigned(sig32) > unsigned(ones(16)) then (nvFlag(), ones(16))\n  else (zeros(5), sig32[15 .. 0]);\n}"
  },
  {
    "name": "pt_walk",
    "source": "{\n  let vpn_j      = vpn_j_of_va(sv_params, va, level);\n  let pte_offset = vpn_j << sv_params.log_pte_size_bytes;\n  let pte_addr   = pt_base + pte_offset;\n\n  // In Sv32, physical addrs are actually 34 bits, not XLEN(=32) bits.\n  // Below, 'pte_phys_addr' is XLEN bits because it's an arg to\n  // 'mem_read_priv()' [riscv_mem.sail] where it's declared as xlenbits.\n  // That def and this use need to be fixed together (TODO)\n  let pte_phys_addr : xlenbits = pte_addr[(sizeof(xlen) - 1) .. 0];\n\n  // Read this-level PTE from mem\n  let mem_result = mem_read_priv(Read(Data),              // AccessType\n                                 Supervisor,              // Privilege\n                                 pte_phys_addr,\n                                 2 ^ sv_params.log_pte_size_bytes,\n                                 false,                   // aq\n                                 false,                   // rl\n                                 false);                  // res\n\n  match mem_result {\n    MemException(_) => PTW_Failure(PTW_Access(), ext_ptw),\n    MemValue(pte)   => {\n      // Extend to 64 bits even on RV32 for simplicity.\n      let pte : bits(64) = zero_extend(pte);\n\n      let pte_flags = Mk_PTE_Flags(pte[7 .. 0]);\n      if pte_is_invalid(pte_flags) then\n        PTW_Failure(PTW_Invalid_PTE(), ext_ptw)\n      else {\n        let ppns : bits(64) = PPNs_of_PTE(sv_params, pte);\n        let global'         = global | (pte_flags[G] == 0b1);\n        if pte_is_ptr(pte_flags) then {\n          // Non-Leaf PTE\n          if level > 0 then {\n            // follow the pointer to walk next level\n            let pt_base' : bits(64) = ppns << pagesize_bits;\n            let level'              = level - 1;\n            pt_walk(sv_params, va, ac, priv, mxr, do_sum,\n                    pt_base', level', global', ext_ptw)\n          }\n          else\n            // level 0 PTE, but contains a pointer instead of a leaf\n            PTW_Failure(PTW_Invalid_PTE(), ext_ptw)\n        }\n        else {\n          // Leaf PTE\n          let ext_pte   = msbs_of_PTE(sv_params, pte);\n          let pte_check = check_PTE_permission(ac, priv, mxr, do_sum, pte_flags,\n                                               ext_pte, ext_ptw);\n          match pte_check {\n            PTE_Check_Failure(ext_ptw, ext_ptw_fail) =>\n              PTW_Failure(ext_get_ptw_error(ext_ptw_fail), ext_ptw),\n            PTE_Check_Success(ext_ptw) =>\n              if level > 0 then {\n                // Superpage; construct mask for lower-level PPNs from the PTE\n                let mask_bits = level * sv_params.pte_PPN_j_size_bits;\n                // Clear the lowest `mask_bits` bits.\n                let ppns_masked = (ppns >> mask_bits) << mask_bits;\n                if not(ppns == ppns_masked) then\n                  // misaligned superpage mapping\n                  PTW_Failure(PTW_Misaligned(), ext_ptw)\n                else {\n                  // Compose final PA in superpage:\n                  // Superpage PPN + lower VPNs + pagesize_bits page-offset\n                  let mask : bits(64) = ~ (ones() << mask_bits);\n                  let ppn = ppns | (vpns_of_va(sv_params, va) & mask);\n                  let pa  = (ppn << pagesize_bits) | zero_extend(offset_of_va(va));\n                  PTW_Success(pa, pte, pte_addr, level, global', ext_ptw)\n                }\n              }\n              else {\n                let pa = (ppns << pagesize_bits) | zero_extend(offset_of_va(va));\n                PTW_Success(pa, pte, pte_addr, level, global', ext_ptw)\n              }\n          }\n        }\n      }\n    }\n  }\n}"
  },
  {
    "name": "flt_S",
    "source": "{\n  let (s1, e1, m1) = fsplit_S (v1);\n  let (s2, e2, m2) = fsplit_S (v2);\n\n  let result : bool =\n    if (s1 == 0b0) & (s2 == 0b0) then\n      if   (e1 == e2)\n      then unsigned (m1) < unsigned (m2)\n      else unsigned (e1) < unsigned (e2)\n    else if (s1 == 0b0) & (s2 == 0b1)\n    then false\n    else if (s1 == 0b1) & (s2 == 0b0)\n    then true\n    else\n        if   (e1 == e2)\n        then unsigned (m1) > unsigned (m2)\n        else unsigned (e1) > unsigned (e2);\n\n  let fflags = if is_quiet then\n                 if   (f_is_SNaN_S(v1) | f_is_SNaN_S(v2))\n                 then nvFlag()\n                 else zeros()\n               else\n                 if   (f_is_NaN_S(v1) | f_is_NaN_S(v2))\n                 then nvFlag()\n                 else zeros();\n\n  (result, fflags)\n}"
  },
  {
    "name": "_shl_int_general",
    "source": "if n >= 0 then _shl_int(m, n) else _shr_int(m, negate(n))"
  },
  {
    "name": "pmpWriteCfg",
    "source": "if pmpLocked(cfg) then cfg\n  else {\n    // Bits 5 and 6 are zero.\n    let cfg = Mk_Pmpcfg_ent(v & 0x9f);\n\n    // \"The R, W, and X fields form a collective WARL field for which the combinations with R=0 and W=1 are reserved.\"\n    // In this implementation if R=0 and W=1 then R, W and X are all set to 0.\n    // This is the least risky option from a security perspective.\n    let cfg = if cfg[W] == 0b1 & cfg[R] == 0b0 then [cfg with X = 0b0, W = 0b0, R = 0b0] else cfg;\n\n    // \"When G >= 1, the NA4 mode is not selectable.\"\n    // In this implementation we set it to OFF if NA4 is selected.\n    // This is the least risky option from a security perspective.\n    let cfg = if sys_pmp_grain() >= 1 & pmpAddrMatchType_of_bits(cfg[A]) == NA4\n              then [cfg with A = pmpAddrMatchType_to_bits(OFF)]\n              else cfg;\n\n    cfg\n  }"
  },
  {
    "name": "riscv_f32ToI64",
    "source": "{\n  extern_f32ToI64(rm, v);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "check_PTE_permission",
    "source": "{\n  let pte_U = pte_flags[U];\n  let pte_R = pte_flags[R];\n  let pte_W = pte_flags[W];\n  let pte_X = pte_flags[X];\n  let success : bool =\n    match (ac, priv) {\n      (Read(_),         User)       => (pte_U == 0b1)\n                                       & ((pte_R == 0b1)\n                                          | ((pte_X == 0b1 & mxr))),\n      (Write(_),        User)       => (pte_U == 0b1) & (pte_W == 0b1),\n      (ReadWrite(_, _), User)       => (pte_U == 0b1)\n                                       & (pte_W == 0b1)\n                                       & ((pte_R == 0b1) | ((pte_X == 0b1) & mxr)),\n      (Execute(),       User)       => (pte_U == 0b1) & (pte_X == 0b1),\n      (Read(_),         Supervisor) => ((pte_U == 0b0) | do_sum)\n                                       & ((pte_R == 0b1) | ((pte_X == 0b1) & mxr)),\n      (Write(_),        Supervisor) => ((pte_U == 0b0) | do_sum)\n                                       & (pte_W == 0b1),\n      (ReadWrite(_, _), Supervisor) => ((pte_U == 0b0) | do_sum)\n                                       & (pte_W == 0b1)\n                                       & ((pte_R == 0b1)\n                                          | ((pte_X == 0b1) & mxr)),\n      (Execute(),       Supervisor) => (pte_U == 0b0) & (pte_X == 0b1),\n      (_,               Machine)    => internal_error(__FILE__, __LINE__,\n                                                      \"m-mode mem perm check\")};\n  if success then PTE_Check_Success(())\n  else            PTE_Check_Failure((), ())\n}"
  },
  {
    "name": "htif_store",
    "source": "{\n  if   get_config_print_platform()\n  then print_platform(\"htif[\" ^ BitStr(paddr) ^ \"] <- \" ^ BitStr(data));\n  /* Store the written value so that we can ack it later. */\n  if      width == 8\n  then    { htif_cmd_write = bitone;\n            htif_payload_writes = htif_payload_writes + 1;\n            htif_tohost = zero_extend(data) }\n  else if width == 4 & paddr == plat_htif_tohost()\n  then    { if   data == htif_tohost[31 .. 0]\n            then htif_payload_writes = htif_payload_writes + 1\n            else htif_payload_writes = 0x1;\n            htif_tohost = vector_update_subrange(htif_tohost, 31, 0, data) }\n  else if width == 4 & paddr == plat_htif_tohost() + 4\n  then    { if   data[15 .. 0] == htif_tohost[47 .. 32]\n            then htif_payload_writes = htif_payload_writes + 1\n            else htif_payload_writes = 0x1;\n            htif_cmd_write = bitone;\n            htif_tohost = vector_update_subrange(htif_tohost, 63, 32, data) }\n  /* unaligned command writes are not supported and will not be detected */\n  else    { htif_tohost = zero_extend(data) };\n\n  /* Execute if there were repeated writes of the same payload without\n   * a cmd (e.g. in riscv-tests), or we have a complete htif command.\n   */\n  if   (((htif_cmd_write == bitone) & (unsigned(htif_payload_writes) > 0))\n        | (unsigned(htif_payload_writes) > 2))\n  then {\n    let cmd = Mk_htif_cmd(htif_tohost);\n    match cmd[device] {\n      0x00 => { /* syscall-proxy */\n        if   get_config_print_platform()\n        then print_platform(\"htif-syscall-proxy cmd: \" ^ BitStr(cmd[payload]));\n        if   cmd[payload][0] == bitone\n        then {\n             htif_done = true;\n             htif_exit_code = (sail_zero_extend(cmd[payload], 64) >> 1)\n        }\n        else ()\n      },\n      0x01 => { /* terminal */\n        if   get_config_print_platform()\n        then print_platform(\"htif-term cmd: \" ^ BitStr(cmd[payload]));\n        match cmd[cmd] {\n          0x00 => /* TODO: terminal input handling */ (),\n          0x01 => plat_term_write(cmd[payload][7..0]),\n          c    => print(\"Unknown term cmd: \" ^ BitStr(c))\n        };\n        /* reset to ack */\n        reset_htif()\n      },\n      d => print(\"htif-???? cmd: \" ^ BitStr(data))\n    }\n  };\n  MemValue(true)\n}"
  },
  {
    "name": "riscv_f64Lt",
    "source": "{\n  extern_f64Lt(v1, v2);\n  (float_fflags[4 .. 0], bit_to_bool(float_result[0]))\n}"
  },
  {
    "name": "wF_S",
    "source": "{\n  assert(sizeof(flen) >= 32);\n  assert(sys_enable_fdext() & not(sys_enable_zfinx()));\n  F(i) = nan_box(data)\n}"
  },
  {
    "name": "riscv_f16Div",
    "source": "{\n  extern_f16Div(rm, v1, v2);\n  (float_fflags[4 .. 0], float_result[15 .. 0])\n}"
  },
  {
    "name": "riscv_f16Le_quiet",
    "source": "{\n  extern_f16Le_quiet(v1, v2);\n  (float_fflags[4 .. 0], bit_to_bool(float_result[0]))\n}"
  },
  {
    "name": "illegal_fp_reduction_widen",
    "source": "{\n  not(valid_vtype()) | not(assert_vstart(0)) | not(valid_fp_op(SEW, rm_3b)) |\n  not(valid_eew_emul(SEW_widen, LMUL_pow_widen))\n}"
  },
  {
    "name": "riscv_i32ToF64",
    "source": "{\n  extern_i32ToF64(rm, v);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "illegal_fp_vd_masked",
    "source": "{\n  not(valid_vtype()) | vd == 0b00000 | not(valid_fp_op(SEW, rm_3b))\n}"
  },
  {
    "name": "mem_write_value_meta",
    "source": "{\n  let typ = Write(ext_acc);\n  let ep = effectivePrivilege(typ, mstatus, cur_privilege);\n  mem_write_value_priv_meta(paddr, width, value, typ, ep, meta, aq, rl, con)\n}"
  },
  {
    "name": "get_scalar",
    "source": "{\n  if SEW <= sizeof(xlen) then {\n    /* Least significant SEW bits */\n    X(rs1)[SEW - 1 .. 0]\n  } else {\n    /* Sign extend to SEW */\n    sign_extend(SEW, X(rs1))\n  }\n}"
  },
  {
    "name": "illegal_variable_width",
    "source": "{\n  not(valid_vtype()) | not(valid_rd_mask(vd, vm)) | not(valid_eew_emul(SEW_new, LMUL_pow_new))\n}"
  },
  {
    "name": "riscv_f32MulAdd",
    "source": "{\n  extern_f32MulAdd(rm, v1, v2, v3);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "legalize_scounteren",
    "source": "{\n  /* no HPM counters yet */\n  [c with IR = [v[2]], TM = [v[1]], CY = [v[0]]]\n}"
  },
  {
    "name": "riscv_f16MulAdd",
    "source": "{\n  extern_f16MulAdd(rm, v1, v2, v3);\n  (float_fflags[4 .. 0], float_result[15 .. 0])\n}"
  },
  {
    "name": "lower_mip",
    "source": "{\n  let s : Sinterrupts = Mk_Sinterrupts(zero_extend(0b0));\n  let s = [s with SEI = m[SEI] & d[SEI]];\n  let s = [s with STI = m[STI] & d[STI]];\n  let s = [s with SSI = m[SSI] & d[SSI]];\n\n  let s = [s with UEI = m[UEI] & d[UEI]];\n  let s = [s with UTI = m[UTI] & d[UTI]];\n  let s = [s with USI = m[USI] & d[USI]];\n  s\n}"
  },
  {
    "name": "ext_check_phys_mem_read",
    "source": "Ext_PhysAddr_OK ()"
  },
  {
    "name": "translate_TLB_miss",
    "source": "{\n  let initial_level = sv_params.levels - 1;\n  let ptw_result    = pt_walk(sv_params, vAddr, ac, priv, mxr, do_sum,\n                              ptb, initial_level, false, ext_ptw);\n  match ptw_result {\n    PTW_Failure(f, ext_ptw) => TR_Failure(f, ext_ptw),\n    PTW_Success(pAddr, pte, pteAddr, level, global, ext_ptw) => {\n      let ext_pte   = msbs_of_PTE(sv_params, pte);\n      // Without TLBs, this 'match' expression can be replaced simply\n      // by: 'TR_Address(pAddr, ext_ptw)'    (see TLB_NOTE above)\n      match update_PTE_Bits(sv_params, pte, ac) {\n        None() => {\n          add_to_TLB(asid, vAddr, pAddr, pte, pteAddr, level, global,\n                     sv_params.vpn_size_bits,\n                     pagesize_bits);\n          TR_Address(pAddr, ext_ptw)\n        },\n        Some(pte') =>\n          // See riscv_platform.sail\n          if not(plat_enable_dirty_update()) then\n            // pte needs dirty/accessed update but that is not enabled\n            TR_Failure(PTW_PTE_Update(), ext_ptw)\n          else {\n            // Writeback the PTE (which has new A/D bits)\n            let pte_phys_addr = pteAddr[(sizeof(xlen) - 1) .. 0];\n\n            match write_pte(pte_phys_addr, 2 ^ sv_params.log_pte_size_bytes, pte') {\n              MemValue(_) => {\n                add_to_TLB(asid, vAddr, pAddr, pte', pteAddr, level, global,\n                           sv_params.vpn_size_bits,\n                           pagesize_bits);\n                TR_Address(pAddr, ext_ptw)\n              },\n              MemException(e) =>\n                TR_Failure(PTW_Access(), ext_ptw)\n            }\n          }\n        }\n      }\n    }\n}"
  },
  {
    "name": "riscv_f32ToF16",
    "source": "{\n  extern_f32ToF16(rm, v);\n  (float_fflags[4 .. 0], float_result[15 .. 0])\n}"
  },
  {
    "name": "hex_bits_backwards",
    "source": "parse_hex_bits(n, str)"
  },
  {
    "name": "unsigned_saturation",
    "source": "{\n  if unsigned(elem) > unsigned(ones('m)) then {\n    vxsat = 0b1;\n    ones('m)\n  } else {\n    vxsat = 0b0;\n    elem['m - 1 .. 0]\n  }\n}"
  },
  {
    "name": "hex_bits_signed_backwards",
    "source": "parse_hex_bits_signed(n, str)"
  },
  {
    "name": "mem_write_value_priv",
    "source": "mem_write_value_priv_meta(paddr, width, value, Write(default_write_acc), priv, default_meta, aq, rl, con)"
  },
  {
    "name": "legalize_uie",
    "source": "{\n  lift_uie(s, d, Mk_Uinterrupts(v))\n}"
  },
  {
    "name": "legalize_sie",
    "source": "{\n  lift_sie(m, d, Mk_Sinterrupts(v))\n}"
  },
  {
    "name": "process_fstore",
    "source": "match value {\n    MemValue(true)  => { RETIRE_SUCCESS },\n    MemValue(false) => { internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\") },\n    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\n  }"
  },
  {
    "name": "valid_hex_bits_signed",
    "source": "{\n  if string_take(str, 1) == \"-\"\n  then valid_hex_bits(n, string_drop(str, 1))\n  else valid_hex_bits(n, str)\n}"
  },
  {
    "name": "get_num_elem",
    "source": "{\n  let VLEN = unsigned(vlenb) * 8;\n  let LMUL_pow_reg = if LMUL_pow < 0 then 0 else LMUL_pow;\n  /* Ignore lmul < 1 so that the entire vreg is read, allowing all masking to\n   * be handled in init_masked_result */\n  let num_elem = 2 ^ (LMUL_pow_reg) * VLEN / SEW;\n  assert(num_elem > 0);\n  num_elem\n}"
  },
  {
    "name": "illegal_normal",
    "source": "{\n  not(valid_vtype()) | not(valid_rd_mask(vd, vm))\n}"
  },
  {
    "name": "riscv_f16ToI8",
    "source": "{\n  let (_, sig32) = riscv_f16ToI32(rm, v);\n  if signed(sig32) > signed(0b0 @ ones(7)) then (nvFlag(), 0b0 @ ones(7))\n  else if signed(sig32) < signed(0b1 @ zeros(7)) then (nvFlag(), 0b1 @ zeros(7))\n  else (zeros(5), sig32[7 .. 0]);\n}"
  },
  {
    "name": "set_mstatus_SXL",
    "source": "{\n  if   sizeof(xlen) == 32\n  then m\n  else {\n    let m = vector_update_subrange(m.bits, 35, 34,  a);\n    Mk_Mstatus(m)\n  }\n}"
  },
  {
    "name": "validDoubleRegs",
    "source": "{\n  if extensionEnabled(Ext_Zdinx) & sizeof(xlen) == 32 then\n    foreach (i from 0 to (n - 1))\n      if (regs[i][0] == bitone) then return false;\n  true\n}"
  },
  {
    "name": "illegal_fp_normal",
    "source": "{\n  not(valid_vtype()) | not(valid_rd_mask(vd, vm)) | not(valid_fp_op(SEW, rm_3b))\n}"
  },
  {
    "name": "pmpWriteAddrReg",
    "source": "{\n  pmpaddr_n[n] = pmpWriteAddr(\n    pmpLocked(pmpcfg_n[n]),\n    if n + 1 < 64 then pmpTORLocked(pmpcfg_n[n + 1]) else false,\n    pmpaddr_n[n],\n    v,\n  );\n}"
  },
  {
    "name": "fmake_S",
    "source": "sign @ exp @ mant"
  },
  {
    "name": "get_scalar_fp",
    "source": "{\n  assert(sizeof(flen) >= SEW, \"invalid vector floating-point type width: FLEN < SEW\");\n  match SEW {\n    16 => F_H(rs1),\n    32 => F_S(rs1),\n    64 => F_D(rs1)\n  }\n}"
  },
  {
    "name": "set_xret_target",
    "source": "{\n  let target = legalize_xepc(value);\n  match p {\n    Machine    => mepc = target,\n    Supervisor => sepc = target,\n    User       => uepc = target\n  };\n  target\n}"
  },
  {
    "name": "riscv_f16ToI32",
    "source": "{\n  extern_f16ToI32(rm, v);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "riscv_f32Add",
    "source": "{\n  extern_f32Add(rm, v1, v2);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "fp_le",
    "source": "{\n  let (fflags, result_val) : (bits_fflags, bool) = match 'm {\n    16  => riscv_f16Le(op1, op2),\n    32  => riscv_f32Le(op1, op2),\n    64  => riscv_f64Le(op1, op2)\n  };\n  accrue_fflags(fflags);\n  result_val\n}"
  },
  {
    "name": "wF_D",
    "source": "{\n  assert(sizeof(flen) >= 64);\n  assert(sys_enable_fdext() & not(sys_enable_zfinx()));\n  F(i) = data\n}"
  },
  {
    "name": "ext_fetch_check_pc",
    "source": "Ext_FetchAddr_OK(pc)"
  },
  {
    "name": "illegal_fp_variable_width",
    "source": "{\n  not(valid_vtype()) | not(valid_rd_mask(vd, vm)) | not(valid_fp_op(SEW, rm_3b)) |\n  not(valid_eew_emul(SEW_new, LMUL_pow_new))\n}"
  },
  {
    "name": "within_htif_readable",
    "source": "plat_htif_tohost() == addr | (plat_htif_tohost() + 4 == addr & width == 4)"
  },
  {
    "name": "within_mmio_readable",
    "source": "within_clint(addr, width) | (within_htif_readable(addr, width) & 1 <= 'n)"
  },
  {
    "name": "fp_nmuladd",
    "source": "{\n  let op1 = negate_fp(op1);\n  let (fflags, result_val) : (bits_fflags, bits('m)) = match 'm {\n    16  => riscv_f16MulAdd(rm_3b, op1, op2, opadd),\n    32  => riscv_f32MulAdd(rm_3b, op1, op2, opadd),\n    64  => riscv_f64MulAdd(rm_3b, op1, op2, opadd)\n  };\n  accrue_fflags(fflags);\n  result_val\n}"
  },
  {
    "name": "lower_sip",
    "source": "{\n  let u : Uinterrupts = Mk_Uinterrupts(zero_extend(0b0));\n  let u = [u with UEI = s[UEI] & d[UEI]];\n  let u = [u with UTI = s[UTI] & d[UTI]];\n  let u = [u with USI = s[USI] & d[USI]];\n  u\n}"
  },
  {
    "name": "riscv_f64ToUi64",
    "source": "{\n  extern_f64ToUi64(rm, v);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "lift_sie",
    "source": "{\n  let m : Minterrupts = o;\n  let m = if d[SEI] == 0b1 then [m with SEI = s[SEI]] else m;\n  let m = if d[STI] == 0b1 then [m with STI = s[STI]] else m;\n  let m = if d[SSI] == 0b1 then [m with SSI = s[SSI]] else m;\n  if extensionEnabled(Ext_N) then {\n    let m = if d[UEI] == 0b1 then [m with UEI = s[UEI]] else m;\n    let m = if d[UTI] == 0b1 then [m with UTI = s[UTI]] else m;\n    let m = if d[USI] == 0b1 then [m with USI = s[USI]] else m;\n    m\n  } else m\n}"
  },
  {
    "name": "riscv_i32ToF16",
    "source": "{\n  extern_i32ToF16(rm, v);\n  (float_fflags[4 .. 0], float_result[15 .. 0])\n}"
  },
  {
    "name": "process_vlxseg",
    "source": "{\n  let EMUL_data_reg : int = if EMUL_data_pow <= 0 then 1 else 2 ^ (EMUL_data_pow);\n  let width_type : word_width = size_bytes(EEW_data_bytes);\n  let vm_val  : vector('n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\n  let vd_seg  : vector('n, dec, bits('f * 'db * 8)) = read_vreg_seg(num_elem, EEW_data_bytes * 8, EMUL_data_pow, nf, vd);\n  let vs2_val : vector('n, dec, bits('ib * 8)) = read_vreg(num_elem, EEW_index_bytes * 8, EMUL_index_pow, vs2);\n\n  let (result, mask) = init_masked_result(num_elem, nf * EEW_data_bytes * 8, EMUL_data_pow, vd_seg, vm_val);\n\n  /* currently mop = 1 (unordered) or 3 (ordered) do the same operations */\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then { /* active segments */\n      vstart = to_bits(16, i);\n      foreach (j from 0 to (nf - 1)) {\n        let elem_offset : int = signed(vs2_val[i]) + j * EEW_data_bytes;\n        match ext_data_get_addr(rs1, to_bits(sizeof(xlen), elem_offset), Read(Data), EEW_data_bytes) {\n          Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); return RETIRE_FAIL },\n          Ext_DataAddr_OK(vaddr) =>\n            if check_misaligned(vaddr, width_type)\n            then { handle_mem_exception(vaddr, E_Load_Addr_Align()); return RETIRE_FAIL }\n            else match translateAddr(vaddr, Read(Data)) {\n              TR_Failure(e, _)     => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n              TR_Address(paddr, _) => {\n                match mem_read(Read(Data), paddr, EEW_data_bytes, false, false, false) {\n                  MemValue(elem)   => write_single_element(EEW_data_bytes * 8, i, vd + to_bits(5, j * EMUL_data_reg), elem),\n                  MemException(e)  => { handle_mem_exception(vaddr, e); return RETIRE_FAIL }\n                }\n              }\n            }\n        }\n      }\n    } else { /* prestart, masked or tail segments */\n      foreach (j from 0 to (nf - 1)) {\n        let skipped_elem = (result[i] >> (j * EEW_data_bytes * 8))[(EEW_data_bytes * 8 - 1) .. 0];\n        write_single_element(EEW_data_bytes * 8, i, vd + to_bits(5, j * EMUL_data_reg), skipped_elem)\n      }\n    }\n  };\n\n  vstart = zeros();\n  RETIRE_SUCCESS\n}"
  },
  {
    "name": "riscv_f32ToI32",
    "source": "{\n  extern_f32ToI32(rm, v);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "read_single_element",
    "source": "{\n  let VLEN = unsigned(vlenb) * 8;\n  assert(VLEN >= EEW);\n  let 'elem_per_reg : int = VLEN / EEW;\n  assert('elem_per_reg >= 0);\n  let real_vrid  : regidx = vrid + to_bits(5, index / 'elem_per_reg);\n  let real_index : int    = index % 'elem_per_reg;\n  let vrid_val : vector('elem_per_reg, dec, bits('m)) = read_single_vreg('elem_per_reg, EEW, real_vrid);\n  assert(0 <= real_index & real_index < 'elem_per_reg);\n  vrid_val[real_index]\n}"
  },
  {
    "name": "legalize_mcounteren",
    "source": "{\n  /* no HPM counters yet */\n  [c with IR = [v[2]], TM = [v[1]], CY = [v[0]]]\n}"
  },
  {
    "name": "riscv_f16Lt",
    "source": "{\n  extern_f16Lt(v1, v2);\n  (float_fflags[4 .. 0], bit_to_bool(float_result[0]))\n}"
  },
  {
    "name": "fdiv_int",
    "source": "{\n  if n < 0 & m > 0 then {\n    tdiv_int(n + 1, m) - 1\n  } else if n > 0 & m < 0 then {\n    tdiv_int(n - 1, m) - 1\n  } else {\n    tdiv_int(n, m)\n  }\n}"
  },
  {
    "name": "rvfi_read",
    "source": "()"
  },
  {
    "name": "fp_max",
    "source": "{\n  let (fflags, op1_lt_op2) : (bits_fflags, bool) = match 'm {\n    16  => riscv_f16Lt_quiet(op1, op2),\n    32  => riscv_f32Lt_quiet(op1, op2),\n    64  => riscv_f64Lt_quiet(op1, op2)\n  };\n\n  let result_val = if (f_is_NaN(op1) & f_is_NaN(op2)) then canonical_NaN('m)\n                else if f_is_NaN(op1) then op2\n                else if f_is_NaN(op2) then op1\n                else if (f_is_neg_zero(op1) & f_is_pos_zero(op2)) then op2\n                else if (f_is_neg_zero(op2) & f_is_pos_zero(op1)) then op1\n                else if op1_lt_op2 then op2\n                else op1;\n  accrue_fflags(fflags);\n  result_val\n}"
  },
  {
    "name": "wX_bits",
    "source": "{\n  wX(unsigned(i)) = data\n}"
  },
  {
    "name": "read_vreg",
    "source": "{\n  var result : vector('n, dec, bits('m)) = undefined;\n  let VLEN = unsigned(vlenb) * 8;\n  let LMUL_pow_reg = if LMUL_pow < 0 then 0 else LMUL_pow;\n\n  /* Check for valid vrid */\n  if unsigned(vrid) + 2 ^ LMUL_pow_reg > 32 then {\n    /* vrid would read past largest vreg (v31) */\n    assert(false, \"invalid register group: vrid overflow the largest number\")\n  } else if unsigned(vrid) % (2 ^ LMUL_pow_reg) != 0 then {\n    /* vrid must be a multiple of emul */\n    assert(false, \"invalid register group: vrid is not a multiple of EMUL\")\n  } else {\n    if LMUL_pow < 0 then {\n      result = read_single_vreg('n, SEW, vrid);\n    } else {\n      let 'num_elem_single : int = VLEN / SEW;\n      assert('num_elem_single >= 0);\n      foreach (i_lmul from 0 to (2 ^ LMUL_pow_reg - 1)) {\n        let r_start_i : int = i_lmul * 'num_elem_single;\n        let r_end_i   : int = r_start_i + 'num_elem_single - 1;\n        let vrid_lmul     : regidx = vrid + to_bits(5, i_lmul);\n        let single_result : vector('num_elem_single, dec, bits('m)) = read_single_vreg('num_elem_single, SEW, vrid_lmul);\n        foreach (r_i from r_start_i to r_end_i) {\n          let s_i : int = r_i - r_start_i;\n          assert(0 <= r_i & r_i < num_elem);\n          assert(0 <= s_i & s_i < 'num_elem_single);\n          result[r_i] = single_result[s_i];\n        }\n      }\n    }\n  };\n\n  result\n}"
  },
  {
    "name": "mem_write_ea",
    "source": "if (rl | con) & not(is_aligned_addr(addr, width))\n  then MemException(E_SAMO_Addr_Align())\n  else MemValue(write_ram_ea(write_kind_of_flags(aq, rl, con), addr, width))"
  },
  {
    "name": "valid_fp_op",
    "source": "{\n  /* 128-bit floating-point values will be supported in future extensions */\n  let valid_sew = (SEW >= 16 & SEW <= 128);\n  let valid_rm = not(rm_3b == 0b101 | rm_3b == 0b110 | rm_3b == 0b111);\n  valid_sew & valid_rm\n}"
  },
  {
    "name": "riscv_f16Sqrt",
    "source": "{\n  extern_f16Sqrt(rm, v);\n  (float_fflags[4 .. 0], float_result[15 .. 0])\n}"
  },
  {
    "name": "riscv_i64ToF16",
    "source": "{\n  extern_i64ToF16(rm, v);\n  (float_fflags[4 .. 0], float_result[15 .. 0])\n}"
  },
  {
    "name": "riscv_f64Recip7",
    "source": "{\n  let (round_abnormal_true, res_true) = recip7(v, rm, true);\n  let (round_abnormal_false, res_false) = recip7(v, rm, false);\n  match fp_class(v)[15 .. 0] {\n    0x0001 => (zeros(5), 0x8000000000000000),\n    0x0080 => (zeros(5), 0x0000000000000000),\n    0x0008 => (dzFlag(), 0xfff0000000000000),\n    0x0010 => (dzFlag(), 0x7ff0000000000000),\n    0x0100 => (nvFlag(), 0x7ff8000000000000),\n    0x0200 => (zeros(5), 0x7ff8000000000000),\n    0x0004 => if round_abnormal_true then (nxFlag() | ofFlag(), res_true[63 .. 0]) else (zeros(5), res_true[63 .. 0]),\n    0x0020 => if round_abnormal_true then (nxFlag() | ofFlag(), res_true[63 .. 0]) else (zeros(5), res_true[63 .. 0]),\n    _      => if round_abnormal_false then (nxFlag() | ofFlag(), res_false[63 .. 0]) else (zeros(5), res_false[63 .. 0])\n  }\n}"
  },
  {
    "name": "riscv_i64ToF32",
    "source": "{\n  extern_i64ToF32(rm, v);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "write_single_element",
    "source": "{\n  let VLEN = unsigned(vlenb) * 8;\n  let 'elem_per_reg : int = VLEN / EEW;\n  assert('elem_per_reg >= 0);\n  let real_vrid  : regidx = vrid + to_bits(5, index / 'elem_per_reg);\n  let real_index : int    = index % 'elem_per_reg;\n\n  let vrid_val : vector('elem_per_reg, dec, bits('m)) = read_single_vreg('elem_per_reg, EEW, real_vrid);\n  var r : vregtype = zeros();\n  foreach (i from ('elem_per_reg - 1) downto 0) {\n    r = r << EEW;\n    if i == real_index then {\n      r = r | zero_extend(value);\n    } else {\n      r = r | zero_extend(vrid_val[i]);\n    }\n  };\n  V(real_vrid) = r;\n}"
  },
  {
    "name": "pmpCheckRWX",
    "source": "{\n  match acc {\n    Read(_)      => ent[R] == 0b1,\n    Write(_)     => ent[W] == 0b1,\n    ReadWrite(_) => ent[R] == 0b1 & ent[W] == 0b1,\n    Execute()    => ent[X] == 0b1\n  }\n}"
  },
  {
    "name": "riscv_f32ToI16",
    "source": "{\n  let (_, sig32) = riscv_f32ToI32(rm, v);\n  if signed(sig32) > signed(0b0 @ ones(15)) then (nvFlag(), 0b0 @ ones(15))\n  else if signed(sig32) < signed(0b1 @ zeros(15)) then (nvFlag(), 0b1 @ zeros(15))\n  else (zeros(5), sig32[15 .. 0]);\n}"
  },
  {
    "name": "rvfi_wX",
    "source": "()"
  },
  {
    "name": "pmpAddrRange",
    "source": "{\n  match pmpAddrMatchType_of_bits(cfg[A]) {\n    OFF   => None(),\n    TOR   => { Some ((prev_pmpaddr, pmpaddr)) },\n    NA4   => {\n               // NA4 is not selectable when the PMP grain G >= 1. See pmpWriteCfg().\n               assert(sys_pmp_grain() < 1, \"NA4 cannot be selected when PMP grain G >= 1.\");\n               let lo = pmpaddr;\n               Some((lo, lo + 4))\n             },\n    NAPOT => {\n               // Example pmpaddr: 0b00010101111\n               //                          ^--- last 0 dictates region size & alignment\n               let mask = pmpaddr ^ (pmpaddr + 1);\n               // pmpaddr + 1:     0b00010110000\n               // mask:            0b00000011111\n               // ~mask:           0b11111100000\n               let lo   = pmpaddr & (~ (mask));\n               // mask + 1:        0b00000100000\n               let len  = mask + 1;\n               Some((lo, (lo + len)))\n             }\n  }\n}"
  },
  {
    "name": "concat_str_dec",
    "source": "concat_str(str, dec_str(x))"
  },
  {
    "name": "riscv_f32Eq",
    "source": "{\n  extern_f32Eq(v1, v2);\n  (float_fflags[4 .. 0], bit_to_bool(float_result[0]))\n}"
  },
  {
    "name": "undefined_mul_op",
    "source": "Error - couldn't locate func"
  },
  {
    "name": "legalize_ustatus",
    "source": "{\n  let u = Mk_Ustatus(v);\n  let s = lower_mstatus(m);     // lower current mstatus to sstatus\n  let s = lift_ustatus(s, u);   // get updated sstatus\n  let m = lift_sstatus(m, s);   // lift it to an updated mstatus\n  m\n}"
  },
  {
    "name": "legalize_mideleg",
    "source": "{\n  /* M-mode interrupt delegation bits \"should\" be hardwired to 0. */\n  /* FIXME: needs verification against eventual spec language. */\n  [Mk_Minterrupts(v) with MEI = 0b0, MTI = 0b0, MSI = 0b0]\n}"
  },
  {
    "name": "riscv_f64ToI64",
    "source": "{\n  extern_f64ToI64(rm, v);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "MemoryOpResult_add_meta",
    "source": "match r {\n  MemValue(v)     => MemValue(v, m),\n  MemException(e) => MemException(e)\n}"
  },
  {
    "name": "riscv_f32ToF64",
    "source": "{\n  extern_f32ToF64(rm, v);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "fp_sub",
    "source": "{\n  let (fflags, result_val) : (bits_fflags, bits('m)) = match 'm {\n    16  => riscv_f16Sub(rm_3b, op1, op2),\n    32  => riscv_f32Sub(rm_3b, op1, op2),\n    64  => riscv_f64Sub(rm_3b, op1, op2)\n  };\n  accrue_fflags(fflags);\n  result_val\n}"
  },
  {
    "name": "process_fload64",
    "source": "if   sizeof(flen) == 64\n  then match value {\n         MemValue(result) => { F(rd) = result; RETIRE_SUCCESS },\n         MemException(e)  => { handle_mem_exception(addr, e); RETIRE_FAIL }\n       }\n  else {\n    /* should not get here */\n    RETIRE_FAIL\n  }"
  },
  {
    "name": "riscv_f16ToUi8",
    "source": "{\n  let (_, sig32) = riscv_f16ToUi32(rm, v);\n  if unsigned(sig32) > unsigned(ones(8)) then (nvFlag(), ones(8))\n  else (zeros(5), sig32[7 .. 0]);\n}"
  },
  {
    "name": "riscv_f32Sub",
    "source": "{\n  extern_f32Sub(rm, v1, v2);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "legalize_senvcfg",
    "source": "{\n  let v = Mk_SEnvcfg(v);\n  let o = [o with FIOM = if sys_enable_writable_fiom() then v[FIOM] else 0b0];\n  // Other extensions are not implemented yet so all other fields are read only zero.\n  o\n}"
  },
  {
    "name": "shift_right_arith64",
    "source": "let v128 : bits(128) = sign_extend(v) in\n    (v128 >> shift)[63..0]"
  },
  {
    "name": "pmpCheckPerms",
    "source": "{\n  match priv {\n    Machine => if   pmpLocked(ent)\n               then pmpCheckRWX(ent, acc)\n               else true,\n    _       => pmpCheckRWX(ent, acc)\n  }\n}"
  },
  {
    "name": "write_pte",
    "source": "mem_write_value_priv(paddr, pte_size, pte[pte_size * 8 - 1 .. 0], Supervisor, false, false, false)"
  },
  {
    "name": "translationException",
    "source": "{\n  match (a, f) {\n    (_, PTW_Ext_Error(e))        => E_Extension(ext_translate_exception(e)),\n    (ReadWrite(_), PTW_Access()) => E_SAMO_Access_Fault(),\n    (ReadWrite(_), _)            => E_SAMO_Page_Fault(),\n    (Read(_), PTW_Access())      => E_Load_Access_Fault(),\n    (Read(_), _)                 => E_Load_Page_Fault(),\n    (Write(_), PTW_Access())     => E_SAMO_Access_Fault(),\n    (Write(_), _)                => E_SAMO_Page_Fault(),\n    (Execute(), PTW_Access())    => E_Fetch_Access_Fault(),\n    (Execute(), _)               => E_Fetch_Page_Fault()\n  }\n}"
  },
  {
    "name": "within_phys_mem",
    "source": "{\n  /* To avoid overflow issues when physical memory extends to the end\n   * of the addressable range, we need to perform address bound checks\n   * on unsigned unbounded integers.\n   */\n  let addr_int     = unsigned(addr);\n  let ram_base_int = unsigned(plat_ram_base ());\n  let rom_base_int = unsigned(plat_rom_base ());\n  let ram_size_int = unsigned(plat_ram_size ());\n  let rom_size_int = unsigned(plat_rom_size ());\n\n  /* todo: iterate over segment list */\n  if      (  ram_base_int <= addr_int\n           & (addr_int + sizeof('n)) <= (ram_base_int + ram_size_int))\n  then    true\n  else if (  rom_base_int <= addr_int\n           & (addr_int + sizeof('n)) <= (rom_base_int + rom_size_int))\n  then    true\n  else {\n    print_platform(\"within_phys_mem: \" ^ BitStr(addr) ^ \" not within phys-mem:\");\n    print_platform(\"  plat_rom_base: \" ^ BitStr(plat_rom_base ()));\n    print_platform(\"  plat_rom_size: \" ^ BitStr(plat_rom_size ()));\n    print_platform(\"  plat_ram_base: \" ^ BitStr(plat_ram_base ()));\n    print_platform(\"  plat_ram_size: \" ^ BitStr(plat_ram_size ()));\n    false\n  }\n}"
  },
  {
    "name": "illegal_fp_vd_unmasked",
    "source": "{\n  not(valid_vtype()) | not(valid_fp_op(SEW, rm_3b))\n}"
  },
  {
    "name": "sail_address_announce",
    "source": "()"
  },
  {
    "name": "checked_mem_read",
    "source": "match phys_access_check(t, priv, paddr, width) {\n    Some(e) => MemException(e),\n    None() => {\n      if   within_mmio_readable(paddr, width)\n      then MemoryOpResult_add_meta(mmio_read(t, paddr, width), default_meta)\n      else if within_phys_mem(paddr, width)\n      then match ext_check_phys_mem_read(t, paddr, width, aq, rl, res, meta) {\n        Ext_PhysAddr_OK()     => phys_mem_read(t, paddr, width, aq, rl, res, meta),\n        Ext_PhysAddr_Error(e) => MemException(e)\n      } else match t {\n        Execute()  => MemException(E_Fetch_Access_Fault()),\n        Read(Data) => MemException(E_Load_Access_Fault()),\n        _          => MemException(E_SAMO_Access_Fault())\n      }\n    }\n  }"
  },
  {
    "name": "illegal_reduction_widen",
    "source": "{\n  not(valid_vtype()) | not(assert_vstart(0)) | not(valid_eew_emul(SEW_widen, LMUL_pow_widen))\n}"
  },
  {
    "name": "undefined_TLB_Entry",
    "source": "Error - couldn't locate func"
  },
  {
    "name": "illegal_fp_reduction",
    "source": "{\n  not(valid_vtype()) | not(assert_vstart(0)) | not(valid_fp_op(SEW, rm_3b))\n}"
  },
  {
    "name": "valid_reg_overlap",
    "source": "{\n  let rs_group = if EMUL_pow_rs > 0 then 2 ^ (EMUL_pow_rs) else 1;\n  let rd_group = if EMUL_pow_rd > 0 then 2 ^ (EMUL_pow_rd) else 1;\n  let rs_int = unsigned(rs);\n  let rd_int = unsigned(rd);\n  if EMUL_pow_rs < EMUL_pow_rd then {\n    (rs_int + rs_group <= rd_int) | (rs_int >= rd_int + rd_group) |\n    ((rs_int + rs_group == rd_int + rd_group) & (EMUL_pow_rs >= 0))\n  } else if EMUL_pow_rs > EMUL_pow_rd then {\n    (rd_int <= rs_int) | (rd_int >= rs_int + rs_group)\n  } else true;\n}"
  },
  {
    "name": "pmpWriteAddr",
    "source": "if   sizeof(xlen) == 32\n  then { if (locked | tor_locked) then reg else v }\n  else { if (locked | tor_locked) then reg else zero_extend(v[53..0]) }"
  },
  {
    "name": "wF_or_X_S",
    "source": "{\n  assert(sizeof(flen) >= 32);\n  assert(sys_enable_fdext() != sys_enable_zfinx());\n  if   sys_enable_fdext()\n  then F_S(i) = data\n  else X(i) = sign_extend(data)\n}"
  },
  {
    "name": "undefined_Explicit_access_kind",
    "source": "Error - couldn't locate func"
  },
  {
    "name": "fp_lt",
    "source": "{\n  let (fflags, result_val) : (bits_fflags, bool) = match 'm {\n    16  => riscv_f16Lt(op1, op2),\n    32  => riscv_f32Lt(op1, op2),\n    64  => riscv_f64Lt(op1, op2)\n  };\n  accrue_fflags(fflags);\n  result_val\n}"
  },
  {
    "name": "wF_or_X_H",
    "source": "{\n  assert(sizeof(flen) >= 16);\n  assert(sys_enable_fdext() != sys_enable_zfinx());\n  if   sys_enable_fdext()\n  then F_H(i) = data\n  else X(i) = sign_extend(data)\n}"
  },
  {
    "name": "translate",
    "source": "{\n  // On first reading, assume lookup_TLB returns None(), since TLBs\n  // are not part of RISC-V archticture spec (see TLB_NOTE above)\n  match lookup_TLB(asid, vAddr) {\n    Some(index, ent) => translate_TLB_hit(sv_params, asid, ptb, vAddr, ac, priv,\n                                          mxr, do_sum, ext_ptw, index, ent),\n    None()           => translate_TLB_miss(sv_params, asid, ptb, vAddr, ac, priv,\n                                           mxr, do_sum, ext_ptw)\n  }\n}"
  },
  {
    "name": "within_mmio_writable",
    "source": "within_clint(addr, width) | (within_htif_writable(addr, width) & 'n <= 8)"
  },
  {
    "name": "feq_quiet_S",
    "source": "{\n  let (s1, e1, m1) = fsplit_S (v1);\n  let (s2, e2, m2) = fsplit_S (v2);\n\n  let v1Is0    = f_is_neg_zero_S(v1) | f_is_pos_zero_S(v1);\n  let v2Is0    = f_is_neg_zero_S(v2) | f_is_pos_zero_S(v2);\n\n  let result = ((v1 == v2) | (v1Is0 & v2Is0));\n\n  let fflags = if   (f_is_SNaN_S(v1) | f_is_SNaN_S(v2))\n               then nvFlag()\n               else zeros();\n\n  (result, fflags)\n}"
  },
  {
    "name": "add_to_TLB",
    "source": "{\n  let shift = pagesize_bits + (level * levelBitSize);\n  assert(shift <= 64);\n  let vAddrMask  : bits(64)  = zero_extend(ones(shift));\n  let vMatchMask : bits(64)  = ~ (vAddrMask);\n\n  let entry : TLB_Entry = struct{asid       = asid,\n                                 global     = global,\n                                 pte        = pte,\n                                 pteAddr    = pteAddr,\n                                 vAddrMask  = vAddrMask,\n                                 vMatchMask = vMatchMask,\n                                 vAddr      = vAddr & vMatchMask,\n                                 pAddr      = pAddr & vMatchMask,\n                                 age        = mcycle};\n\n  // Add the TLB entry. Note that this may be a super-page, but we still want\n  // to add it to the index corresponding to the page because that is how\n  // lookup_TLB looks it up. For superpages will just end up with the same\n  // TLB entry in multiple slots.\n  let index = tlb_hash(vAddr);\n  tlb[index] = Some(entry);\n}"
  },
  {
    "name": "pmpMatchAddr",
    "source": "{\n  match rng {\n    None()         => PMP_NoMatch,\n    Some((lo, hi)) => {\n      // Convert to integers.\n      let addr  = unsigned(addr);\n      let width = unsigned(width);\n      // These are in units of 4 bytes.\n      let lo = unsigned(lo) * 4;\n      let hi = unsigned(hi) * 4;\n\n      if   hi <= lo   /* to handle mis-configuration */\n      then PMP_NoMatch\n      else {\n        if      (addr + width <= lo) | (hi <= addr)\n        then    PMP_NoMatch\n        else if (lo <= addr) & (addr + width <= hi)\n        then    PMP_Match\n        else    PMP_PartialMatch\n      }\n    },\n  }\n}"
  },
  {
    "name": "lift_uip",
    "source": "{\n  let s : Sinterrupts = o;\n  let s = if d[USI] == 0b1 then [s with USI = u[USI]] else s;\n  s\n}"
  },
  {
    "name": "count_leadingzeros",
    "source": "{\n  var idx : int = -1;\n  assert(len == 10 | len == 23 | len == 52);\n  foreach (i from 0 to (len - 1)) {\n    if sig[i] == bitone then idx = i;\n  };\n  len - idx - 1\n}"
  },
  {
    "name": "sign_extend",
    "source": "sail_sign_extend(v, m)"
  },
  {
    "name": "riscv_f16Add",
    "source": "{\n  extern_f16Add(rm, v1, v2);\n  (float_fflags[4 .. 0], float_result[15 .. 0])\n}"
  },
  {
    "name": "to_bits",
    "source": "get_slice_int(l, n, 0)"
  },
  {
    "name": "calculate_new_vl",
    "source": "{\n  /* Note: ceil(AVL / 2) <= vl <= VLMAX when VLMAX < AVL < (2 * VLMAX)\n   * TODO: configuration support for either using ceil(AVL / 2) or VLMAX\n   */\n  if AVL <= VLMAX then to_bits(sizeof(xlen), AVL)\n  else if AVL < 2 * VLMAX then to_bits(sizeof(xlen), (AVL + 1) / 2)\n  else to_bits(sizeof(xlen), VLMAX)\n}"
  },
  {
    "name": "aes_get_column",
    "source": "(state >> (to_bits(7, 32 * c)))[31..0]"
  },
  {
    "name": "handle_trap_extension",
    "source": "()"
  },
  {
    "name": "wF_or_X_D",
    "source": "{\n  assert (sizeof(flen) >= 64);\n  assert(sys_enable_fdext() != sys_enable_zfinx());\n  if   sys_enable_fdext()\n  then F_D(i) = data\n  else if sizeof(xlen) >= 64\n  then X(i) = sign_extend(data)\n  else {\n    assert (i[0] == bitzero);\n    if i != zeros() then {\n      X(i)     = data[31..0];\n      X(i + 1) = data[63..32];\n    }\n  }\n}"
  },
  {
    "name": "valid_segment",
    "source": "{\n  if EMUL_pow < 0 then nf / (2 ^ (0 - EMUL_pow)) <= 8\n  else nf * 2 ^ (EMUL_pow) <= 8\n}"
  },
  {
    "name": "exception_handler",
    "source": "{\n  match (cur_priv, ctl) {\n    (_, CTL_TRAP(e)) => {\n      let del_priv = exception_delegatee(e.trap, cur_priv);\n      if   get_config_print_platform()\n      then print_platform(\"trapping from \" ^ to_str(cur_priv) ^ \" to \" ^ to_str(del_priv)\n                          ^ \" to handle \" ^ to_str(e.trap));\n      trap_handler(del_priv, false, exceptionType_to_bits(e.trap), pc, e.excinfo, e.ext)\n    },\n    (_, CTL_MRET())  => {\n      let prev_priv   = cur_privilege;\n      mstatus[MIE]  = mstatus[MPIE];\n      mstatus[MPIE] = 0b1;\n      cur_privilege   = privLevel_of_bits(mstatus[MPP]);\n      mstatus[MPP]  = privLevel_to_bits(if extensionEnabled(Ext_U) then User else Machine);\n      if   cur_privilege != Machine\n      then mstatus[MPRV] = 0b0;\n\n      if   get_config_print_reg()\n      then print_reg(\"CSR mstatus <- \" ^ BitStr(mstatus.bits));\n      if   get_config_print_platform()\n      then print_platform(\"ret-ing from \" ^ to_str(prev_priv) ^ \" to \" ^ to_str(cur_privilege));\n\n      prepare_xret_target(Machine) & pc_alignment_mask()\n    },\n    (_, CTL_SRET())  => {\n      let prev_priv   = cur_privilege;\n      mstatus[SIE]  = mstatus[SPIE];\n      mstatus[SPIE] = 0b1;\n      cur_privilege   = if mstatus[SPP] == 0b1 then Supervisor else User;\n      mstatus[SPP]  = 0b0;\n      if   cur_privilege != Machine\n      then mstatus[MPRV] = 0b0;\n\n      if   get_config_print_reg()\n      then print_reg(\"CSR mstatus <- \" ^ BitStr(mstatus.bits));\n      if   get_config_print_platform()\n      then print_platform(\"ret-ing from \" ^ to_str(prev_priv)\n                          ^ \" to \" ^ to_str(cur_privilege));\n\n      prepare_xret_target(Supervisor) & pc_alignment_mask()\n    },\n    (_, CTL_URET())  => {\n      let prev_priv   = cur_privilege;\n      mstatus[UIE]  = mstatus[UPIE];\n      mstatus[UPIE] = 0b1;\n      cur_privilege   = User;\n\n      if   get_config_print_reg()\n      then print_reg(\"CSR mstatus <- \" ^ BitStr(mstatus.bits));\n      if   get_config_print_platform()\n      then print_platform(\"ret-ing from \" ^ to_str(prev_priv) ^ \" to \" ^ to_str(cur_privilege));\n\n      prepare_xret_target(User) & pc_alignment_mask()\n    }\n  }\n}"
  },
  {
    "name": "legalize_mie",
    "source": "{\n  let v = Mk_Minterrupts(v);\n  let m = [o with\n    MEI = v[MEI],\n    MTI = v[MTI],\n    MSI = v[MSI],\n    SEI = v[SEI],\n    STI = v[STI],\n    SSI = v[SSI]\n  ];\n  /* The U-mode bits will be modified if we have the 'N' extension. */\n  if extensionEnabled(Ext_U) & extensionEnabled(Ext_N) then {\n    [m with UEI = v[UEI], UTI = v[UTI], USI = v[USI]]\n  } else m\n}"
  },
  {
    "name": "concat_str_bits",
    "source": "concat_str(str, bits_str(x))"
  },
  {
    "name": "riscv_f64Sqrt",
    "source": "{\n  extern_f64Sqrt(rm, v);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "translate_TLB_hit",
    "source": "{\n  let pte       = ent.pte;\n  let ext_pte   = msbs_of_PTE(sv_params, pte);\n  let pte_flags = Mk_PTE_Flags(pte[7 .. 0]);\n  let pte_check = check_PTE_permission(ac, priv, mxr, do_sum, pte_flags,\n                                       ext_pte,\n                                       ext_ptw);\n  match pte_check {\n    PTE_Check_Failure(ext_ptw, ext_ptw_fail) =>\n      TR_Failure(ext_get_ptw_error(ext_ptw_fail), ext_ptw),\n    PTE_Check_Success(ext_ptw) =>\n      match update_PTE_Bits(sv_params, pte, ac) {\n        None()     => TR_Address(ent.pAddr | (vAddr & ent.vAddrMask), ext_ptw),\n        Some(pte') =>\n          // See riscv_platform.sail\n          if not(plat_enable_dirty_update()) then\n            // pte needs dirty/accessed update but that is not enabled\n            TR_Failure(PTW_PTE_Update(), ext_ptw)\n          else {\n            // Writeback the PTE (which has new A/D bits)\n            let n_ent = {ent with pte=pte'};\n            write_TLB(tlb_index, n_ent);\n            let pte_phys_addr = ent.pteAddr[(sizeof(xlen) - 1) .. 0];\n\n            match write_pte(pte_phys_addr, 2 ^ sv_params.log_pte_size_bytes, pte') {\n              MemValue(_)     => (),\n              MemException(e) => internal_error(__FILE__, __LINE__,\n                                                \"invalid physical address in TLB\")\n            };\n            TR_Address(ent.pAddr | (vAddr & ent.vAddrMask), ext_ptw)\n          }\n      }\n  }\n}"
  },
  {
    "name": "effective_fence_set",
    "source": "{\n  // The bits are IORW. If FIOM is set then I implies R and O implies W.\n  if fiom then {\n    set[3 .. 2] @ (set[1 .. 0] | set[3 .. 2])\n  } else set\n}"
  },
  {
    "name": "process_vlre",
    "source": "{\n  let width_type : word_width = size_bytes(load_width_bytes);\n  let start_element = get_start_element();\n  if start_element >= nf * elem_per_reg then return RETIRE_SUCCESS; /* no elements are written if vstart >= evl */\n  let elem_to_align : int = start_element % elem_per_reg;\n  var cur_field : int = start_element / elem_per_reg;\n  var cur_elem  : int = start_element;\n\n  if elem_to_align > 0 then {\n    foreach (i from elem_to_align to (elem_per_reg - 1)) {\n      vstart = to_bits(16, cur_elem);\n      let elem_offset = cur_elem * load_width_bytes;\n      match ext_data_get_addr(rs1, to_bits(sizeof(xlen), elem_offset), Read(Data), load_width_bytes) {\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); return RETIRE_FAIL },\n        Ext_DataAddr_OK(vaddr) =>\n          if check_misaligned(vaddr, width_type)\n          then { handle_mem_exception(vaddr, E_Load_Addr_Align()); return RETIRE_FAIL }\n          else match translateAddr(vaddr, Read(Data)) {\n            TR_Failure(e, _)     => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n            TR_Address(paddr, _) => {\n              match mem_read(Read(Data), paddr, load_width_bytes, false, false, false) {\n                MemValue(elem)   => write_single_element(load_width_bytes * 8, i, vd + to_bits(5, cur_field), elem),\n                MemException(e)  => { handle_mem_exception(vaddr, e); return RETIRE_FAIL }\n              }\n            }\n          }\n      };\n      cur_elem = cur_elem + 1\n    };\n    cur_field = cur_field + 1\n  };\n\n  foreach (j from cur_field to (nf - 1)) {\n    foreach (i from 0 to (elem_per_reg - 1)) {\n      vstart = to_bits(16, cur_elem);\n      let elem_offset = cur_elem * load_width_bytes;\n      match ext_data_get_addr(rs1, to_bits(sizeof(xlen), elem_offset), Read(Data), load_width_bytes) {\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); return RETIRE_FAIL },\n        Ext_DataAddr_OK(vaddr) =>\n          if check_misaligned(vaddr, width_type)\n          then { handle_mem_exception(vaddr, E_Load_Addr_Align()); return RETIRE_FAIL }\n          else match translateAddr(vaddr, Read(Data)) {\n            TR_Failure(e, _)     => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n            TR_Address(paddr, _) => {\n              match mem_read(Read(Data), paddr, load_width_bytes, false, false, false) {\n                MemValue(elem)   => write_single_element(load_width_bytes * 8, i, vd + to_bits(5, j), elem),\n                MemException(e)  => { handle_mem_exception(vaddr, e); return RETIRE_FAIL }\n              }\n            }\n          }\n      };\n      cur_elem = cur_elem + 1\n    }\n  };\n\n  vstart = zeros();\n  RETIRE_SUCCESS\n}"
  },
  {
    "name": "legalize_medeleg",
    "source": "{\n  /* M-EnvCalls delegation is not supported */\n  [Mk_Medeleg(v) with MEnvCall = 0b0]\n}"
  },
  {
    "name": "recip7",
    "source": "{\n  let (sig, exp, sign, e, s) : (bits(64), bits(64), bits(1), nat, nat) = match 'm {\n    16 => (zero_extend(64, v[9 .. 0]), zero_extend(64, v[14 .. 10]), [v[15]], 5, 10),\n    32 => (zero_extend(64, v[22 .. 0]), zero_extend(64, v[30 .. 23]), [v[31]], 8, 23),\n    64 => (zero_extend(64, v[51 .. 0]), zero_extend(64, v[62 .. 52]), [v[63]], 11, 52)\n  };\n  assert(s == 10 & e == 5 | s == 23 & e == 8 | s == 52 & e == 11);\n  let table : vector(128, dec, int) = [\n      127, 125, 123, 121, 119, 117, 116, 114,\n      112, 110, 109, 107, 105, 104, 102, 100,\n      99, 97, 96, 94, 93, 91, 90, 88,\n      87, 85, 84, 83, 81, 80, 79, 77,\n      76, 75, 74, 72, 71, 70, 69, 68,\n      66, 65, 64, 63, 62, 61, 60, 59,\n      58, 57, 56, 55, 54, 53, 52, 51,\n      50, 49, 48, 47, 46, 45, 44, 43,\n      42, 41, 40, 40, 39, 38, 37, 36,\n      35, 35, 34, 33, 32, 31, 31, 30,\n      29, 28, 28, 27, 26, 25, 25, 24,\n      23, 23, 22, 21, 21, 20, 19, 19,\n      18, 17, 17, 16, 15, 15, 14, 14,\n      13, 12, 12, 11, 11, 10, 9, 9,\n      8, 8, 7, 7, 6, 5, 5, 4,\n      4, 3, 3, 2, 2, 1, 1, 0];\n\n  let nr_leadingzeros = count_leadingzeros(sig, s);\n  assert(nr_leadingzeros >= 0);\n  let (normalized_exp, normalized_sig) =\n      if sub then {\n        (to_bits(64, (0 - nr_leadingzeros)), zero_extend(64, sig[(s - 1) .. 0] << (1 + nr_leadingzeros)))\n      } else {\n        (exp, sig)\n      };\n\n  let idx : nat = match 'm {\n    16 => unsigned(normalized_sig[9 .. 3]),\n    32 => unsigned(normalized_sig[22 .. 16]),\n    64 => unsigned(normalized_sig[51 .. 45])\n  };\n  assert(idx >= 0 & idx < 128);\n  let mid_exp = to_bits(e, 2 * (2 ^ (e - 1) - 1) - 1 - signed(normalized_exp));\n  let mid_sig = to_bits(s, table[(127 - idx)]) << (s - 7);\n\n  let (out_exp, out_sig)=\n      if mid_exp == zeros(e) then {\n        (mid_exp, mid_sig >> 1 | 0b1 @ zeros(s - 1))\n      } else if mid_exp == ones(e) then {\n        (zeros(e), mid_sig >> 2 | 0b01 @ zeros(s - 2))\n      } else (mid_exp, mid_sig);\n\n  if sub & nr_leadingzeros > 1 then {\n      if (rm_3b == 0b001 | rm_3b == 0b010 & sign == 0b0 | rm_3b == 0b011 & sign == 0b1) then {\n        (true, zero_extend(64, sign @ ones(e - 1) @ 0b0 @ ones(s)))\n      }\n      else (true, zero_extend(64, sign @ ones(e) @ zeros(s)))\n    } else (false, zero_extend(64, sign @ out_exp @ out_sig))\n}"
  },
  {
    "name": "riscv_f16Rsqrte7",
    "source": "{\n  match fp_class(v) {\n    0x0001 => (nvFlag(), 0x7e00),\n    0x0002 => (nvFlag(), 0x7e00),\n    0x0004 => (nvFlag(), 0x7e00),\n    0x0100 => (nvFlag(), 0x7e00),\n    0x0200 => (zeros(5), 0x7e00),\n    0x0008 => (dzFlag(), 0xfc00),\n    0x0010 => (dzFlag(), 0x7c00),\n    0x0080 => (zeros(5), 0x0000),\n    0x0020 => (zeros(5), rsqrt7(v, true)[15 .. 0]),\n    _      => (zeros(5), rsqrt7(v, false)[15 .. 0])\n  }\n}"
  },
  {
    "name": "legalize_mstatus",
    "source": "{\n  /*\n   * Populate all defined fields using the bits of v, stripping anything\n   * that does not have a matching bitfield entry. All bits above 32 are handled\n   * explicitly later.\n   */\n  let m : Mstatus = Mk_Mstatus(zero_extend(v[22 .. 7] @ 0b0 @ v[5 .. 3] @ 0b0 @ v[1 .. 0]));\n\n  /* Legalize MPP */\n  let m = [m with MPP = if have_privLevel(m[MPP]) then m[MPP]\n                        else privLevel_to_bits(lowest_supported_privLevel())];\n\n  /* We don't have any extension context yet. */\n  let m = [m with XS = extStatus_to_bits(Off)];\n\n  /* FS is WARL, and making FS writable can support the M-mode emulation of an FPU\n   * to support code running in S/U-modes.  Spike does this, and for now, we match it,\n   * but only if Zfinx isn't enabled.\n   * FIXME: This should be made a platform parameter.\n   */\n  let m = if sys_enable_zfinx() then [m with FS = extStatus_to_bits(Off)] else m;\n  let dirty = extStatus_of_bits(m[FS]) == Dirty | extStatus_of_bits(m[XS]) == Dirty |\n              extStatus_of_bits(m[VS]) == Dirty;\n  let m = [m with SD = bool_to_bits(dirty)];\n\n  /* We don't support dynamic changes to SXL and UXL. */\n  let m = set_mstatus_SXL(m, get_mstatus_SXL(o));\n  let m = set_mstatus_UXL(m, get_mstatus_UXL(o));\n\n  /* We don't currently support changing MBE and SBE. */\n  let m = if sizeof(xlen) == 64 then {\n             Mk_Mstatus([m.bits with 37 .. 36 = 0b00])\n          } else m;\n\n  /* Hardwired to zero in the absence of 'U' or 'N'. */\n  let m = if not(extensionEnabled(Ext_N)) then {\n             let m = [m with UPIE = 0b0];\n             let m = [m with UIE = 0b0];\n             m\n          } else m;\n\n  if not(extensionEnabled(Ext_U)) then {\n    let m = [m with MPRV = 0b0];\n    m\n  } else m\n}"
  },
  {
    "name": "tvec_addr",
    "source": "{\n  let base : xlenbits = m[Base] @ 0b00;\n  match (trapVectorMode_of_bits(m[Mode])) {\n    TV_Direct => Some(base),\n    TV_Vector => if   c[IsInterrupt] == 0b1\n                 then Some(base + (zero_extend(c[Cause]) << 2))\n                 else Some(base),\n    TV_Reserved => None()\n  }\n}"
  },
  {
    "name": "process_vm",
    "source": "{\n  let width_type : word_width = BYTE;\n  let start_element = get_start_element();\n  let vd_or_vs3_val : vector('n, dec, bits(8)) = read_vreg(num_elem, 8, 0, vd_or_vs3);\n\n  foreach (i from start_element to (num_elem - 1)) {\n    if i < evl then { /* active elements */\n      vstart = to_bits(16, i);\n      if op == VLM then { /* load */\n        match ext_data_get_addr(rs1, to_bits(sizeof(xlen), i), Read(Data), 1) {\n          Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); return RETIRE_FAIL },\n          Ext_DataAddr_OK(vaddr) =>\n            if check_misaligned(vaddr, width_type)\n            then { handle_mem_exception(vaddr, E_Load_Addr_Align()); return RETIRE_FAIL }\n            else match translateAddr(vaddr, Read(Data)) {\n              TR_Failure(e, _)     => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n              TR_Address(paddr, _) => {\n                match mem_read(Read(Data), paddr, 1, false, false, false) {\n                  MemValue(elem)   => write_single_element(8, i, vd_or_vs3, elem),\n                  MemException(e)  => { handle_mem_exception(vaddr, e); return RETIRE_FAIL }\n                }\n              }\n            }\n        }\n      } else if op == VSM then { /* store */\n        match ext_data_get_addr(rs1, to_bits(sizeof(xlen), i), Write(Data), 1) {\n          Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); return RETIRE_FAIL },\n          Ext_DataAddr_OK(vaddr) =>\n            if check_misaligned(vaddr, width_type)\n            then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); return RETIRE_FAIL }\n            else match translateAddr(vaddr, Write(Data)) {\n              TR_Failure(e, _)     => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n              TR_Address(paddr, _) => {\n                let eares : MemoryOpResult(unit) = mem_write_ea(paddr, 1, false, false, false);\n                match (eares) {\n                  MemException(e) => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n                  MemValue(_) => {\n                    let res : MemoryOpResult(bool) = mem_write_value(paddr, 1, vd_or_vs3_val[i], false, false, false);\n                    match (res) {\n                      MemValue(true)  => (),\n                      MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                      MemException(e) => { handle_mem_exception(vaddr, e); return RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n        }\n      }\n    } else { /* tail elements for mask load, always with agnostic policy */\n      if op == VLM then {\n        write_single_element(8, i, vd_or_vs3, vd_or_vs3_val[i])\n        /* TODO: configuration support for agnostic behavior */\n      }\n    }\n  };\n\n  vstart = zeros();\n  RETIRE_SUCCESS\n}"
  },
  {
    "name": "write_single_vreg",
    "source": "{\n  var r : vregtype = zeros();\n\n  assert(8 <= SEW & SEW <= 64);\n  foreach (i from (num_elem - 1) downto 0) {\n    r = r << SEW;\n    r = r | zero_extend(v[i]);\n  };\n\n  V(vrid) = r\n}"
  },
  {
    "name": "wV",
    "source": "{\n  let v = in_v;\n  match r {\n    0 => vr0 = v,\n    1 => vr1 = v,\n    2 => vr2 = v,\n    3 => vr3 = v,\n    4 => vr4 = v,\n    5 => vr5 = v,\n    6 => vr6 = v,\n    7 => vr7 = v,\n    8 => vr8 = v,\n    9 => vr9 = v,\n    10 => vr10 = v,\n    11 => vr11 = v,\n    12 => vr12 = v,\n    13 => vr13 = v,\n    14 => vr14 = v,\n    15 => vr15 = v,\n    16 => vr16 = v,\n    17 => vr17 = v,\n    18 => vr18 = v,\n    19 => vr19 = v,\n    20 => vr20 = v,\n    21 => vr21 = v,\n    22 => vr22 = v,\n    23 => vr23 = v,\n    24 => vr24 = v,\n    25 => vr25 = v,\n    26 => vr26 = v,\n    27 => vr27 = v,\n    28 => vr28 = v,\n    29 => vr29 = v,\n    30 => vr30 = v,\n    31 => vr31 = v,\n    _ => assert(false, \"invalid vector register number\")\n  };\n\n  dirty_v_context();\n\n  let VLEN = unsigned(vlenb) * 8;\n  assert(0 < VLEN & VLEN <= sizeof(vlenmax));\n  if   get_config_print_reg()\n  then print_reg(\"v\" ^ dec_str(r) ^ \" <- \" ^ BitStr(v[VLEN - 1 .. 0]));\n}"
  },
  {
    "name": "clint_store",
    "source": "{\n  let addr = addr - plat_clint_base ();\n  if addr == MSIP_BASE & ('n == 8 | 'n == 4) then {\n    if   get_config_print_platform()\n    then print_platform(\"clint[\" ^ BitStr(addr) ^ \"] <- \" ^ BitStr(data) ^ \" (mip.MSI <- \" ^ BitStr(data[0]) ^ \")\");\n    mip[MSI] = [data[0]];\n    clint_dispatch();\n    MemValue(true)\n  } else if addr == MTIMECMP_BASE & 'n == 8 then {\n    if   get_config_print_platform()\n    then print_platform(\"clint<8>[\" ^ BitStr(addr) ^ \"] <- \" ^ BitStr(data) ^ \" (mtimecmp)\");\n    mtimecmp = sail_zero_extend(data, 64); /* FIXME: Redundant zero_extend currently required by Lem backend */\n    clint_dispatch();\n    MemValue(true)\n  } else if addr == MTIMECMP_BASE & 'n == 4 then {\n    if   get_config_print_platform()\n    then print_platform(\"clint<4>[\" ^ BitStr(addr) ^ \"] <- \" ^ BitStr(data) ^ \" (mtimecmp)\");\n    mtimecmp = vector_update_subrange(mtimecmp, 31, 0, sail_zero_extend(data, 32));  /* FIXME: Redundant zero_extend currently required by Lem backend */\n    clint_dispatch();\n    MemValue(true)\n  } else if addr == MTIMECMP_BASE_HI & 'n == 4 then {\n    if   get_config_print_platform()\n    then print_platform(\"clint<4>[\" ^ BitStr(addr) ^ \"] <- \" ^ BitStr(data) ^ \" (mtimecmp)\");\n    mtimecmp = vector_update_subrange(mtimecmp, 63, 32, sail_zero_extend(data, 32)); /* FIXME: Redundant zero_extend currently required by Lem backend */\n    clint_dispatch();\n    MemValue(true)\n  } else if addr == MTIME_BASE & 'n == 8 then {\n    if   get_config_print_platform()\n    then print_platform(\"clint<8>[\" ^ BitStr(addr) ^ \"] <- \" ^ BitStr(data) ^ \" (mtime)\");\n    mtime = data;\n    clint_dispatch();\n    MemValue(true)\n  } else if addr == MTIME_BASE & 'n == 4 then {\n    if   get_config_print_platform()\n    then print_platform(\"clint<4>[\" ^ BitStr(addr) ^ \"] <- \" ^ BitStr(data) ^ \" (mtime)\");\n    mtime[31 .. 0] = data;\n    clint_dispatch();\n    MemValue(true)\n  } else if addr == MTIME_BASE_HI & 'n == 4 then {\n    if   get_config_print_platform()\n    then print_platform(\"clint<4>[\" ^ BitStr(addr) ^ \"] <- \" ^ BitStr(data) ^ \" (mtime)\");\n    mtime[63 .. 32] = data;\n    clint_dispatch();\n    MemValue(true)\n  } else {\n    if   get_config_print_platform()\n    then print_platform(\"clint[\" ^ BitStr(addr) ^ \"] <- \" ^ BitStr(data) ^ \" (<unmapped>)\");\n    MemException(E_SAMO_Access_Fault())\n  }\n}"
  },
  {
    "name": "zero_extend",
    "source": "sail_zero_extend(v, m)"
  },
  {
    "name": "feature_enabled_for_priv",
    "source": "match p {\n  Machine => true,\n  Supervisor => machine_enable_bit == bitone,\n  User => machine_enable_bit == bitone & (not(extensionEnabled(Ext_S)) | supervisor_enable_bit == bitone),\n}"
  },
  {
    "name": "legalize_mcountinhibit",
    "source": "{\n  [c with IR = [v[2]], CY = [v[0]]]\n}"
  },
  {
    "name": "riscv_f64Lt_quiet",
    "source": "{\n  extern_f64Lt_quiet(v1, v2);\n  (float_fflags[4 .. 0], bit_to_bool(float_result[0]))\n}"
  },
  {
    "name": "hex_bits_backwards_matches",
    "source": "valid_hex_bits(n, str)"
  },
  {
    "name": "fmod_int",
    "source": "{\n  n - (m * fdiv_int(n, m))\n}"
  },
  {
    "name": "processPending",
    "source": "{\n  /* interrupts that are enabled but not delegated are pending */\n  let  effective_pend = xip.bits & xie.bits & (~ (xideleg));\n  /* the others are delegated */\n  let  effective_delg = xip.bits & xideleg;\n  /* we have pending interrupts if this privilege is enabled */\n  if      priv_enabled & (effective_pend != zero_extend(0b0))\n  then    Ints_Pending(effective_pend)\n  else if effective_delg != zero_extend(0b0)\n  then    Ints_Delegated(effective_delg)\n  else    Ints_Empty()\n}"
  },
  {
    "name": "fle_S",
    "source": "{\n  let (s1, e1, m1) = fsplit_S (v1);\n  let (s2, e2, m2) = fsplit_S (v2);\n\n  let v1Is0    = f_is_neg_zero_S(v1) | f_is_pos_zero_S(v1);\n  let v2Is0    = f_is_neg_zero_S(v2) | f_is_pos_zero_S(v2);\n\n  let result : bool =\n    if (s1 == 0b0) & (s2 == 0b0) then\n      if   (e1 == e2)\n      then unsigned (m1) <=  unsigned (m2)\n      else unsigned (e1)  <  unsigned (e2)\n    else if (s1 == 0b0) & (s2 == 0b1)\n    then (v1Is0 & v2Is0)                         /* Equal in this case (+0=-0) */\n    else if (s1 == 0b1) & (s2 == 0b0)\n    then true\n    else\n      if   (e1 == e2)\n      then unsigned (m1) >=  unsigned (m2)\n      else unsigned (e1)  >  unsigned (e2);\n\n  let fflags = if is_quiet then\n                 if   (f_is_SNaN_S(v1) | f_is_SNaN_S(v2))\n                 then nvFlag()\n                 else zeros()\n               else\n                 if   (f_is_NaN_S(v1) | f_is_NaN_S(v2))\n                 then nvFlag()\n                 else zeros();\n\n  (result, fflags)\n}"
  },
  {
    "name": "write_vmask",
    "source": "{\n  let VLEN = unsigned(vlenb) * 8;\n  assert(0 < VLEN & VLEN <= sizeof(vlenmax));\n  assert(0 < num_elem & num_elem <= VLEN);\n  let vreg_val : vregtype = V(vrid);\n  var result   : vregtype = undefined;\n\n  foreach (i from 0 to (num_elem - 1)) {\n    result[i] = bool_to_bit(v[i])\n  };\n  foreach (i from num_elem to (VLEN - 1)) {\n    /* Mask tail is always agnostic */\n    result[i] = vreg_val[i] /* TODO: configuration support */\n  };\n\n  V(vrid) = result\n}"
  },
  {
    "name": "ext_check_phys_mem_write",
    "source": "Ext_PhysAddr_OK ()"
  },
  {
    "name": "shift_right_arith32",
    "source": "let v64 : bits(64) = sign_extend(v) in\n    (v64 >> shift)[31..0]"
  },
  {
    "name": "rsqrt7",
    "source": "{\n  let (sig, exp, sign, e, s) : (bits(64), bits(64), bits(1), nat, nat) = match 'm {\n    16 => (zero_extend(64, v[9 .. 0]), zero_extend(64, v[14 .. 10]), [v[15]], 5, 10),\n    32 => (zero_extend(64, v[22 .. 0]), zero_extend(64, v[30 .. 23]), [v[31]], 8, 23),\n    64 => (zero_extend(64, v[51 .. 0]), zero_extend(64, v[62 .. 52]), [v[63]], 11, 52)\n  };\n  assert(s == 10 & e == 5 | s == 23 & e == 8 | s == 52 & e == 11);\n  let table : vector(128, dec, int) = [\n      52, 51, 50, 48, 47, 46, 44, 43,\n      42, 41, 40, 39, 38, 36, 35, 34,\n      33, 32, 31, 30, 30, 29, 28, 27,\n      26, 25, 24, 23, 23, 22, 21, 20,\n      19, 19, 18, 17, 16, 16, 15, 14,\n      14, 13, 12, 12, 11, 10, 10, 9,\n      9, 8, 7, 7, 6, 6, 5, 4,\n      4, 3, 3, 2, 2, 1, 1, 0,\n      127, 125, 123, 121, 119, 118, 116, 114,\n      113, 111, 109, 108, 106, 105, 103, 102,\n      100, 99, 97, 96, 95, 93, 92, 91,\n      90, 88, 87, 86, 85, 84, 83, 82,\n      80, 79, 78, 77, 76, 75, 74, 73,\n      72, 71, 70, 70, 69, 68, 67, 66,\n      65, 64, 63, 63, 62, 61, 60, 59,\n      59, 58, 57, 56, 56, 55, 54, 53];\n\n  let (normalized_exp, normalized_sig) =\n      if sub then {\n        let nr_leadingzeros = count_leadingzeros(sig, s);\n        assert(nr_leadingzeros >= 0);\n        (to_bits(64, (0 - nr_leadingzeros)), zero_extend(64, sig[(s - 1) .. 0] << (1 + nr_leadingzeros)))\n      } else {\n        (exp, sig)\n      };\n\n  let idx : nat = match 'm {\n    16 => unsigned([normalized_exp[0]] @ normalized_sig[9 .. 4]),\n    32 => unsigned([normalized_exp[0]] @ normalized_sig[22 .. 17]),\n    64 => unsigned([normalized_exp[0]] @ normalized_sig[51 .. 46])\n  };\n  assert(idx >= 0 & idx < 128);\n  let out_sig = to_bits(s, table[(127 - idx)]) << (s - 7);\n  let out_exp = to_bits(e, (3 * (2 ^ (e - 1) - 1) - 1 - signed(normalized_exp)) / 2);\n  zero_extend(64, sign @ out_exp @ out_sig)\n}"
  },
  {
    "name": "prepare_trap_vector",
    "source": "{\n  let tvec : Mtvec = match p {\n                       Machine    => mtvec,\n                       Supervisor => stvec,\n                       User       => utvec\n                     };\n  match tvec_addr(tvec, cause) {\n    Some(epc) => epc,\n    None()    => internal_error(__FILE__, __LINE__, \"Invalid tvec mode\")\n  }\n}"
  },
  {
    "name": "flush_TLB",
    "source": "{\n  let asid : option(asidbits) =\n    match asid_xlen {\n      None()  => None(),\n      Some(a) => Some(a[15 .. 0])\n    };\n  let addr_64b : option(bits(64)) =\n    match addr_xlen {\n      None()  => None(),\n      Some(a) => Some(zero_extend(a))\n    };\n  foreach (i from 0 to (length(tlb) - 1)) {\n    match tlb[i] {\n      Some(e) => if flush_TLB_Entry(e, asid, addr_64b) then { tlb[i] = None(); },\n      None()  => (),\n    }\n  }\n}"
  },
  {
    "name": "riscv_f32Lt",
    "source": "{\n  extern_f32Lt(v1, v2);\n  (float_fflags[4 .. 0], bit_to_bool(float_result[0]))\n}"
  },
  {
    "name": "check_CSR_access",
    "source": "not(isWrite == true & csrrw == 0b11)  /* read/write */\n  & (privLevel_to_bits(p) >=_u csrpr)"
  },
  {
    "name": "hex_bits_signed_backwards_matches",
    "source": "valid_hex_bits_signed(n, str)"
  },
  {
    "name": "fp_muladd",
    "source": "{\n  let (fflags, result_val) : (bits_fflags, bits('m)) = match 'm {\n    16  => riscv_f16MulAdd(rm_3b, op1, op2, opadd),\n    32  => riscv_f32MulAdd(rm_3b, op1, op2, opadd),\n    64  => riscv_f64MulAdd(rm_3b, op1, op2, opadd)\n  };\n  accrue_fflags(fflags);\n  result_val\n}"
  },
  {
    "name": "fp_nmulsub",
    "source": "{\n  let opsub = negate_fp(opsub);\n  let op1 = negate_fp(op1);\n  let (fflags, result_val) : (bits_fflags, bits('m)) = match 'm {\n    16  => riscv_f16MulAdd(rm_3b, op1, op2, opsub),\n    32  => riscv_f32MulAdd(rm_3b, op1, op2, opsub),\n    64  => riscv_f64MulAdd(rm_3b, op1, op2, opsub)\n  };\n  accrue_fflags(fflags);\n  result_val\n}"
  },
  {
    "name": "read_single_vreg",
    "source": "{\n  let bv     : vregtype                  = V(vrid);\n  var result : vector('n, dec, bits('m)) = undefined;\n\n  assert(8 <= SEW & SEW <= 64);\n  foreach (i from 0 to (num_elem - 1)) {\n    let start_index = i * SEW;\n    result[i] = slice(bv, start_index, SEW);\n  };\n\n  result\n}"
  },
  {
    "name": "riscv_f64Le",
    "source": "{\n  extern_f64Le(v1, v2);\n  (float_fflags[4 .. 0], bit_to_bool(float_result[0]))\n}"
  },
  {
    "name": "riscv_f64Div",
    "source": "{\n  extern_f64Div(rm, v1, v2);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "riscv_ui32ToF16",
    "source": "{\n  extern_ui32ToF16(rm, v);\n  (float_fflags[4 .. 0], float_result[15 .. 0])\n}"
  },
  {
    "name": "get_shift_amount",
    "source": "{\n  let lowlog2bits = log2(SEW);\n  assert(0 < lowlog2bits & lowlog2bits < 'n);\n  unsigned(bit_val[lowlog2bits - 1 .. 0]);\n}"
  },
  {
    "name": "legalize_satp",
    "source": "{       // new legal value of satp\n  if sizeof(xlen) == 32 then {\n    // The slice and extend ops below are no-ops when xlen==32,\n    // but appease the type-checker when xlen==64 (when this code is not executed!)\n    let o32      : bits(32) = o[31 .. 0];\n    let v32      : bits(32) = v[31 .. 0];\n    let new_satp : bits(32) = legalize_satp32(a, o32, v32);\n    zero_extend(new_satp);\n  } else if sizeof(xlen) == 64 then {\n    // The extend and truncate ops below are no-ops when xlen==64,\n    // but appease the type-checker when xlen==32 (when this code is not executed!)\n    let o64      : bits(64) = zero_extend(o);\n    let v64      : bits(64) = zero_extend(v);\n    let new_satp : bits(64) = legalize_satp64(a, o64, v64);\n    truncate(new_satp, sizeof(xlen))\n  } else\n    internal_error(__FILE__, __LINE__, \"Unsupported xlen\" ^ dec_str(sizeof(xlen)))\n}"
  },
  {
    "name": "checked_mem_write",
    "source": "match phys_access_check(typ, priv, paddr, width) {\n    Some(e) => MemException(e),\n    None() => {\n      if   within_mmio_writable(paddr, width)\n      then mmio_write(paddr, width, data)\n      else if within_phys_mem(paddr, width)\n      then {\n        let wk = write_kind_of_flags(aq, rl, con);\n        match ext_check_phys_mem_write (wk, paddr, width, data, meta) {\n          Ext_PhysAddr_OK() => phys_mem_write(wk, paddr, width, data, meta),\n          Ext_PhysAddr_Error(e)  => MemException(e),\n        }\n      } else MemException(E_SAMO_Access_Fault())\n    }\n  }"
  },
  {
    "name": "fp_ge",
    "source": "{\n  let (fflags, temp_val) : (bits_fflags, bool) = match 'm {\n    16  => riscv_f16Lt(op1, op2),\n    32  => riscv_f32Lt(op1, op2),\n    64  => riscv_f64Lt(op1, op2)\n  };\n  let result_val = (if fflags == 0b10000 then false else not(temp_val));\n  accrue_fflags(fflags);\n  result_val\n}"
  },
  {
    "name": "__ReadRAM_Meta",
    "source": "()"
  },
  {
    "name": "feq_quiet_D",
    "source": "{\n  let (s1, e1, m1) = fsplit_D (v1);\n  let (s2, e2, m2) = fsplit_D (v2);\n\n  let v1Is0    = f_is_neg_zero_D(v1) | f_is_pos_zero_D(v1);\n  let v2Is0    = f_is_neg_zero_D(v2) | f_is_pos_zero_D(v2);\n\n  let result = ((v1 == v2) | (v1Is0 & v2Is0));\n\n  let fflags = if   (f_is_SNaN_D(v1) | f_is_SNaN_D(v2))\n               then nvFlag()\n               else zeros();\n\n  (result, fflags)\n}"
  },
  {
    "name": "read_vmask_carry",
    "source": "{\n  let VLEN = unsigned(vlenb) * 8;\n  assert(0 < num_elem & num_elem <= sizeof(vlenmax));\n  let vreg_val : vregtype = V(vrid);\n  var result   : vector('n, dec, bool) = undefined;\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if vm == 0b1 then {\n      result[i] = false\n    } else {\n      result[i] = bit_to_bool(vreg_val[i])\n    }\n  };\n\n  result\n}"
  },
  {
    "name": "riscv_f64Le_quiet",
    "source": "{\n  extern_f64Le_quiet(v1, v2);\n  (float_fflags[4 .. 0], bit_to_bool(float_result[0]))\n}"
  },
  {
    "name": "wF_H",
    "source": "{\n  assert(sizeof(flen) >= 16);\n  assert(sys_enable_fdext() & not(sys_enable_zfinx()));\n  F(i) = nan_box(data)\n}"
  },
  {
    "name": "illegal_store",
    "source": "{\n  not(valid_vtype()) | not(valid_eew_emul(EEW, EMUL_pow)) | not(valid_segment(nf, EMUL_pow))\n}"
  },
  {
    "name": "set_mstatus_UXL",
    "source": "{\n  if   sizeof(xlen) == 32\n  then m\n  else {\n    let m = vector_update_subrange(m.bits, 33, 32,  a);\n    Mk_Mstatus(m)\n  }\n}"
  },
  {
    "name": "write_vreg",
    "source": "{\n  let VLEN = unsigned(vlenb) * 8;\n  let LMUL_pow_reg = if LMUL_pow < 0 then 0 else LMUL_pow;\n\n  let 'num_elem_single  : int = VLEN / SEW;\n  assert('num_elem_single >= 0);\n  foreach (i_lmul from 0 to (2 ^ LMUL_pow_reg - 1)) {\n    var single_vec : vector('num_elem_single, dec, bits('m)) = undefined;\n    let vrid_lmul  : regidx = vrid + to_bits(5, i_lmul);\n    let r_start_i  : int = i_lmul * 'num_elem_single;\n    let r_end_i    : int = r_start_i + 'num_elem_single - 1;\n    foreach (r_i from r_start_i to r_end_i) {\n      let s_i : int = r_i - r_start_i;\n      assert(0 <= r_i & r_i < num_elem);\n      assert(0 <= s_i & s_i < 'num_elem_single);\n      single_vec[s_i] = vec[r_i]\n    };\n    write_single_vreg('num_elem_single, SEW, vrid_lmul, single_vec)\n  }\n}"
  },
  {
    "name": "riscv_f32Le",
    "source": "{\n  extern_f32Le(v1, v2);\n  (float_fflags[4 .. 0], bit_to_bool(float_result[0]))\n}"
  },
  {
    "name": "PPNs_of_PTE",
    "source": "{\n  let mask : bits(64) = zero_extend(ones(sv_params.pte_PPNs_size_bits));\n  (pte >> sv_params.pte_PPNs_lsb_index) & mask\n}"
  },
  {
    "name": "neq_bits",
    "source": "not_bool(eq_bits(x, y))"
  },
  {
    "name": "aes_rv64_shiftrows_inv",
    "source": "{\n  getbyte(rs2, 3) @\n  getbyte(rs2, 6) @\n  getbyte(rs1, 1) @\n  getbyte(rs1, 4) @\n  getbyte(rs1, 7) @\n  getbyte(rs2, 2) @\n  getbyte(rs2, 5) @\n  getbyte(rs1, 0)\n}"
  },
  {
    "name": "process_fload32",
    "source": "match value {\n    MemValue(result) => { F(rd) = nan_box(result); RETIRE_SUCCESS },\n    MemException(e)  => { handle_mem_exception(addr, e); RETIRE_FAIL }\n  }"
  },
  {
    "name": "init_masked_result_cmp",
    "source": "{\n  let start_element = get_start_element();\n  let end_element   = get_end_element();\n  let mask_ag : agtype = get_vtype_vma();\n  var mask : vector('n, dec, bool) = undefined;\n  var result : vector('n, dec, bool) = undefined;\n\n  /* Determine the actual number of elements when lmul < 1 */\n  let real_num_elem = if LMUL_pow >= 0 then num_elem else num_elem / (2 ^ (0 - LMUL_pow));\n  assert(num_elem >= real_num_elem);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if i < start_element then {\n      /* Prestart elements defined by vstart */\n      result[i] = vd_val[i];\n      mask[i] = false\n    } else if i > end_element then {\n      /* Tail elements defined by vl */\n      /* Mask tail is always agnostic */\n      result[i] = vd_val[i]; /* TODO: configuration support */\n      mask[i] = false\n    } else if i >= real_num_elem then {\n      /* Tail elements defined by lmul < 1 */\n      /* Mask tail is always agnostic */\n      result[i] = vd_val[i]; /* TODO: configuration support */\n      mask[i] = false\n    } else if not(vm_val[i]) then {\n      /* Inactive body elements defined by vm */\n      result[i] = match mask_ag {\n        UNDISTURBED => vd_val[i],\n        AGNOSTIC    => vd_val[i] /* TODO: configuration support */\n      };\n      mask[i] = false\n    } else {\n      /* Active body elements */\n      mask[i] = true\n    }\n  };\n\n  (result, mask)\n}"
  },
  {
    "name": "ext_write_fcsr",
    "source": "{\n  fcsr[FRM]    = frm;      /* Note: frm can be an illegal value, 101, 110, 111 */\n  fcsr[FFLAGS] = fflags;\n  dirty_fd_context_if_present();\n}"
  },
  {
    "name": "phys_mem_write",
    "source": "{\n  let result = MemValue(write_ram(wk, paddr, width, data, meta));\n  if   get_config_print_mem()\n  then print_mem(\"mem[\" ^ BitStr(paddr) ^ \"] <- \" ^ BitStr(data));\n  result\n}"
  },
  {
    "name": "pmpWriteCfgReg",
    "source": "{\n  if sizeof(xlen) == 32\n  then {\n    foreach (i from 0 to 3) {\n      let idx = n*4 + i;\n      pmpcfg_n[idx]  = pmpWriteCfg(idx,  pmpcfg_n[idx],  v[8*i+7 .. 8*i]);\n    }\n  }\n  else {\n    assert(n % 2 == 0, \"Unexpected pmp config reg write\");\n    foreach (i from 0 to 7) {\n      let idx = n*4 + i;\n      pmpcfg_n[idx]  = pmpWriteCfg(idx,  pmpcfg_n[idx],  v[8*i+7 .. 8*i]);\n    }\n  }\n}"
  },
  {
    "name": "riscv_f16roundToInt",
    "source": "{\n  extern_f16roundToInt(rm, v, exact);\n  (float_fflags[4 .. 0], float_result[15 .. 0])\n}"
  },
  {
    "name": "msbs_of_PTE",
    "source": "{\n  let mask : bits(64) = zero_extend(ones(sv_params.pte_msbs_size_bits));\n  (pte >> sv_params.pte_msbs_lsb_index) & mask\n}"
  },
  {
    "name": "report_invalid_width",
    "source": "{\n  internal_error(f, l, \"Invalid width, \" ^ size_mnemonic(w) ^ \", for \" ^ k ^\n     \" with xlen=\" ^ dec_str(sizeof(xlen)))\n}"
  },
  {
    "name": "legalize_misa",
    "source": "{\n  let  v = Mk_Misa(v);\n  /* Suppress updates to MISA if MISA is not writable or if by disabling C next PC would become misaligned or an extension vetoes */\n  if   not(sys_enable_writable_misa()) | (v[C] == 0b0 & (nextPC[1] == bitone | ext_veto_disable_C()))\n  then m\n  else {\n    /* Suppress enabling C if C was disabled at boot (i.e. not supported) */\n    let m = if not(sys_enable_rvc()) then m else [m with C = v[C]];\n    /* Suppress updates to misa.{f,d} if disabled at boot */\n    if   not(sys_enable_fdext())\n    then m\n    else [m with F = v[F], D = v[D] & v[F]]\n  }\n}"
  },
  {
    "name": "riscv_ui32ToF32",
    "source": "{\n  extern_ui32ToF32(rm, v);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "riscv_ui64ToF16",
    "source": "{\n  extern_ui64ToF16(rm, v);\n  (float_fflags[4 .. 0], float_result[15 .. 0])\n}"
  },
  {
    "name": "flush_TLB_Entry",
    "source": "{\n  match (asid, addr) {\n    ( None(),  None()) => true,\n    ( None(), Some(a)) => e.vAddr == (e.vMatchMask & a),\n    (Some(i),  None()) => (e.asid == i) & not(e.global),\n    (Some(i), Some(a)) => (  (e.asid == i) & (e.vAddr == (a & e.vMatchMask))\n                           & not(e.global))\n  }\n}"
  },
  {
    "name": "legalize_sstatus",
    "source": "{\n  legalize_mstatus(m, lift_sstatus(m, Mk_Sstatus(v)).bits)\n}"
  },
  {
    "name": "vpns_of_va",
    "source": "{\n  let mask : bits(64) = zero_extend(ones(sv_params.va_size_bits));\n  (va & mask) >> pagesize_bits\n}"
  },
  {
    "name": "illegal_indexed_store",
    "source": "{\n  not(valid_vtype()) | not(valid_eew_emul(EEW_index, EMUL_pow_index)) |\n  not(valid_segment(nf, EMUL_pow_data))\n}"
  },
  {
    "name": "parse_hex_bits_signed",
    "source": "{\n  if string_take(str, 1) == \"-\"\n  then {\n    let str = string_drop(str, 1);\n    let bv = parse_hex_bits(n, str);\n    not_vec(bv) + 1\n  }\n  else parse_hex_bits(n, str)\n}"
  },
  {
    "name": "riscv_f16ToF64",
    "source": "{\n  extern_f16ToF64(rm, v);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "sbox_lookup",
    "source": "{\n  table[255 - unsigned(x)]\n}"
  },
  {
    "name": "satp64Mode_of_bits",
    "source": "match (a, m) {\n    (_,    0x0) => Some(Sbare),\n    (RV32, 0x1) => Some(Sv32),\n    (RV64, 0x8) => Some(Sv39),\n    (RV64, 0x9) => Some(Sv48),\n    (_, _)      => None()\n  }"
  },
  {
    "name": "process_vsseg",
    "source": "{\n  let EMUL_reg : int = if EMUL_pow <= 0 then 1 else 2 ^ (EMUL_pow);\n  let width_type : word_width = size_bytes(load_width_bytes);\n  let vm_val  : vector('n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\n  let vs3_seg : vector('n, dec, bits('f * 'b * 8)) = read_vreg_seg(num_elem, load_width_bytes * 8, EMUL_pow, nf, vs3);\n  let mask    : vector('n, dec, bool) = init_masked_source(num_elem, EMUL_pow, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if vm_val[i] then { /* active segments */\n      vstart = to_bits(16, i);\n      foreach (j from 0 to (nf - 1)) {\n        let elem_offset = (i * nf + j) * load_width_bytes;\n        match ext_data_get_addr(rs1, to_bits(sizeof(xlen), elem_offset), Write(Data), load_width_bytes) {\n          Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); return RETIRE_FAIL },\n          Ext_DataAddr_OK(vaddr) =>\n            if check_misaligned(vaddr, width_type)\n            then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); return RETIRE_FAIL }\n            else match translateAddr(vaddr, Write(Data)) {\n              TR_Failure(e, _)     => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n              TR_Address(paddr, _) => {\n                let eares : MemoryOpResult(unit) = mem_write_ea(paddr, load_width_bytes, false, false, false);\n                match (eares) {\n                  MemException(e) => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n                  MemValue(_) => {\n                    let elem_val : bits('b * 8) = read_single_element(load_width_bytes * 8, i, vs3 + to_bits(5, j * EMUL_reg));\n                    let res : MemoryOpResult(bool) = mem_write_value(paddr, load_width_bytes, elem_val, false, false, false);\n                    match (res) {\n                      MemValue(true)  => (),\n                      MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                      MemException(e) => { handle_mem_exception(vaddr, e); return RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n        }\n      }\n    }\n  };\n\n  vstart = zeros();\n  RETIRE_SUCCESS\n}"
  },
  {
    "name": "rotate_bits_left",
    "source": "(v << n) | (v >> (to_bits(length(n), length(v)) - n))"
  },
  {
    "name": "clint_load",
    "source": "{\n  let addr = addr - plat_clint_base ();\n  /* FIXME: For now, only allow exact aligned access. */\n  if addr == MSIP_BASE & ('n == 8 | 'n == 4)\n  then {\n    if   get_config_print_platform()\n    then print_platform(\"clint[\" ^ BitStr(addr) ^ \"] -> \" ^ BitStr(mip[MSI]));\n    MemValue(sail_zero_extend(mip[MSI], sizeof(8 * 'n)))\n  }\n  else if addr == MTIMECMP_BASE & ('n == 4)\n  then {\n    if   get_config_print_platform()\n    then print_platform(\"clint<4>[\" ^ BitStr(addr) ^ \"] -> \" ^ BitStr(mtimecmp[31..0]));\n    /* FIXME: Redundant zero_extend currently required by Lem backend */\n    MemValue(sail_zero_extend(mtimecmp[31..0], 32))\n  }\n  else if addr == MTIMECMP_BASE & ('n == 8)\n  then {\n    if   get_config_print_platform()\n    then print_platform(\"clint<8>[\" ^ BitStr(addr) ^ \"] -> \" ^ BitStr(mtimecmp));\n    /* FIXME: Redundant zero_extend currently required by Lem backend */\n    MemValue(sail_zero_extend(mtimecmp, 64))\n  }\n  else if addr == MTIMECMP_BASE_HI & ('n == 4)\n  then {\n    if   get_config_print_platform()\n    then print_platform(\"clint-hi<4>[\" ^ BitStr(addr) ^ \"] -> \" ^ BitStr(mtimecmp[63..32]));\n    /* FIXME: Redundant zero_extend currently required by Lem backend */\n    MemValue(sail_zero_extend(mtimecmp[63..32], 32))\n  }\n  else if addr == MTIME_BASE & ('n == 4)\n  then {\n    if   get_config_print_platform()\n    then print_platform(\"clint[\" ^ BitStr(addr) ^ \"] -> \" ^ BitStr(mtime));\n    MemValue(sail_zero_extend(mtime[31..0], 32))\n  }\n  else if addr == MTIME_BASE & ('n == 8)\n  then {\n    if   get_config_print_platform()\n    then print_platform(\"clint[\" ^ BitStr(addr) ^ \"] -> \" ^ BitStr(mtime));\n    MemValue(sail_zero_extend(mtime, 64))\n  }\n  else if addr == MTIME_BASE_HI & ('n == 4)\n  then {\n    if   get_config_print_platform()\n    then print_platform(\"clint[\" ^ BitStr(addr) ^ \"] -> \" ^ BitStr(mtime));\n    MemValue(sail_zero_extend(mtime[63..32], 32))\n  }\n  else {\n    if   get_config_print_platform()\n    then print_platform(\"clint[\" ^ BitStr(addr) ^ \"] -> <not-mapped>\");\n    match t {\n      Execute()  => MemException(E_Fetch_Access_Fault()),\n      Read(Data) => MemException(E_Load_Access_Fault()),\n      _          => MemException(E_SAMO_Access_Fault())\n    }\n  }\n}"
  },
  {
    "name": "riscv_f16Le",
    "source": "{\n  extern_f16Le(v1, v2);\n  (float_fflags[4 .. 0], bit_to_bool(float_result[0]))\n}"
  },
  {
    "name": "riscv_ui32ToF64",
    "source": "{\n  extern_ui32ToF64(rm, v);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "riscv_f32Le_quiet",
    "source": "{\n  extern_f32Le_quiet(v1, v2);\n  (float_fflags[4 .. 0], bit_to_bool(float_result[0]))\n}"
  },
  {
    "name": "check_misaligned",
    "source": "not(plat_enable_misaligned_access()) & not(is_aligned(vaddr, width))"
  },
  {
    "name": "riscv_f32Recip7",
    "source": "{\n  let (round_abnormal_true, res_true) = recip7(v, rm, true);\n  let (round_abnormal_false, res_false) = recip7(v, rm, false);\n  match fp_class(v)[15 .. 0] {\n    0x0001 => (zeros(5), 0x80000000),\n    0x0080 => (zeros(5), 0x00000000),\n    0x0008 => (dzFlag(), 0xff800000),\n    0x0010 => (dzFlag(), 0x7f800000),\n    0x0100 => (nvFlag(), 0x7fc00000),\n    0x0200 => (zeros(5), 0x7fc00000),\n    0x0004 => if round_abnormal_true then (nxFlag() | ofFlag(), res_true[31 .. 0]) else (zeros(5), res_true[31 .. 0]),\n    0x0020 => if round_abnormal_true then (nxFlag() | ofFlag(), res_true[31 .. 0]) else (zeros(5), res_true[31 .. 0]),\n    _      => if round_abnormal_false then (nxFlag() | ofFlag(), res_false[31 .. 0]) else (zeros(5), res_false[31 .. 0])\n  }\n}"
  },
  {
    "name": "wX",
    "source": "{\n  let v = regval_into_reg(in_v);\n  match r {\n    0  => (),\n    1  => x1 = v,\n    2  => x2 = v,\n    3  => x3 = v,\n    4  => x4 = v,\n    5  => x5 = v,\n    6  => x6 = v,\n    7  => x7 = v,\n    8  => x8 = v,\n    9  => x9 = v,\n    10 => x10 = v,\n    11 => x11 = v,\n    12 => x12 = v,\n    13 => x13 = v,\n    14 => x14 = v,\n    15 => x15 = v,\n    16 => x16 = v,\n    17 => x17 = v,\n    18 => x18 = v,\n    19 => x19 = v,\n    20 => x20 = v,\n    21 => x21 = v,\n    22 => x22 = v,\n    23 => x23 = v,\n    24 => x24 = v,\n    25 => x25 = v,\n    26 => x26 = v,\n    27 => x27 = v,\n    28 => x28 = v,\n    29 => x29 = v,\n    30 => x30 = v,\n    31 => x31 = v,\n    _  => assert(false, \"invalid register number\")\n  };\n  if (r != 0) then {\n     rvfi_wX(r, in_v);\n     if   get_config_print_reg()\n     then print_reg(\"x\" ^ dec_str(r) ^ \" <- \" ^ RegStr(v));\n  }\n}"
  },
  {
    "name": "read_kind_of_flags",
    "source": "match (aq, rl, res) {\n    (false, false, false) => Some(Read_plain),\n    (true, false, false)  => Some(Read_RISCV_acquire),\n    (true, true, false)   => Some(Read_RISCV_strong_acquire),\n    (false, false, true)  => Some(Read_RISCV_reserved),\n    (true, false, true)   => Some(Read_RISCV_reserved_acquire),\n    (true, true, true)    => Some(Read_RISCV_reserved_strong_acquire),\n    (false, true, false)  => None(), /* should these be instead throwing error_not_implemented as below? */\n    (false, true, true)   => None()\n  }"
  },
  {
    "name": "is_aligned_addr",
    "source": "unsigned(addr) % width == 0"
  },
  {
    "name": "legalize_tvec",
    "source": "{\n let v = Mk_Mtvec(v);\n match (trapVectorMode_of_bits(v[Mode])) {\n   TV_Direct => v,\n   TV_Vector => v,\n   _         => [v with Mode = o[Mode]]\n }\n}"
  },
  {
    "name": "fmake_D",
    "source": "sign @ exp @ mant"
  },
  {
    "name": "write_ram",
    "source": "{\n  let request : Mem_write_request('n, 64, xlenbits, unit, RISCV_strong_access) = struct {\n    access_kind = match wk {\n      Write_plain => AK_explicit(struct { variety = AV_plain, strength = AS_normal }),\n      Write_RISCV_release => AK_explicit(struct { variety = AV_plain, strength = AS_rel_or_acq }),\n      Write_RISCV_strong_release => AK_arch(struct { variety = AV_plain }),\n      Write_RISCV_conditional => AK_explicit(struct { variety = AV_exclusive, strength = AS_normal }),\n      Write_RISCV_conditional_release => AK_explicit(struct { variety = AV_exclusive, strength = AS_rel_or_acq }),\n      Write_RISCV_conditional_strong_release => AK_arch(struct { variety = AV_exclusive }),\n    },\n    va = None(),\n    pa = addr,\n    translation = (),\n    size = width,\n    value = Some(data),\n    tag = None(),\n  };\n  /* Write out metadata only if the value write succeeds.\n   * It is assumed for now that this write always succeeds;\n   * there is currently no return value.\n   * FIXME: We should convert the external API for all backends\n   * (not just for Lem) to consume the value along with the\n   * metadata to ensure atomicity.\n   */\n  match sail_mem_write(request) {\n    Ok(_) => {\n      __WriteRAM_Meta(addr, width, meta);\n      true\n    },\n    Err() => false,\n  }\n}"
  },
  {
    "name": "handle_mem_exception",
    "source": "{\n  let t : sync_exception = struct { trap    = e,\n                                    excinfo = Some(addr),\n                                    ext     = None() } in\n  set_next_pc(exception_handler(cur_privilege, CTL_TRAP(t), PC))\n}"
  },
  {
    "name": "exception_delegatee",
    "source": "{\n  let idx   = num_of_ExceptionType(e);\n  let super = bit_to_bool(medeleg.bits[idx]);\n  /* if S-mode is absent, medeleg delegates to U-mode if 'N' is supported. */\n  let user  = if   extensionEnabled(Ext_S)\n              then super & extensionEnabled(Ext_N) & bit_to_bool(sedeleg.bits[idx])\n              else super & extensionEnabled(Ext_N);\n  let deleg = if      extensionEnabled(Ext_U) & user  then User\n              else if extensionEnabled(Ext_S) & super then Supervisor\n              else                               Machine;\n  /* We cannot transition to a less-privileged mode. */\n  if   privLevel_to_bits(deleg) <_u privLevel_to_bits(p)\n  then p else deleg\n}"
  },
  {
    "name": "legalize_sedeleg",
    "source": "{\n  Mk_Sedeleg(zero_extend(v[8..0]))\n}"
  },
  {
    "name": "riscv_f64ToF32",
    "source": "{\n  extern_f64ToF32(rm, v);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "legalize_satp64",
    "source": "{\n  let s = Mk_Satp64(v);\n  match satp64Mode_of_bits(a, s[Mode]) {\n    None()     => o,\n    Some(Sv32) => o,  /* Sv32 is unsupported for now */\n    Some(_)    => s.bits\n  }\n}"
  },
  {
    "name": "__WriteRAM_Meta",
    "source": "()"
  },
  {
    "name": "rotate_bits_right",
    "source": "(v >> n) | (v << (to_bits(length(n), length(v)) - n))"
  },
  {
    "name": "init_masked_source",
    "source": "{\n  let start_element = get_start_element();\n  let end_element   = get_end_element();\n  var mask : vector('n, dec, bool) = undefined;\n\n  /* Determine the actual number of elements when lmul < 1 */\n  let real_num_elem = if LMUL_pow >= 0 then num_elem else num_elem / (2 ^ (0 - LMUL_pow));\n  assert(num_elem >= real_num_elem);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if i < start_element then {\n      /* Prestart elements defined by vstart */\n      mask[i] = false\n    } else if i > end_element then {\n      /* Tail elements defined by vl */\n      mask[i] = false\n    } else if i >= real_num_elem then {\n      /* Tail elements defined by lmul < 1 */\n      mask[i] = false\n    } else if not(vm_val[i]) then {\n      /* Inactive body elements defined by vm */\n      mask[i] = false\n    } else {\n      /* Active body elements */\n      mask[i] = true;\n    }\n  };\n\n  mask\n}"
  },
  {
    "name": "sail_mark_register_pair",
    "source": "()"
  },
  {
    "name": "legalize_uip",
    "source": "{\n  lift_uip(s, d, Mk_Uinterrupts(v))\n}"
  },
  {
    "name": "gfmul",
    "source": "{\n  (if bit_to_bool(y[0]) then             x    else 0x00) ^\n  (if bit_to_bool(y[1]) then xt2(        x)   else 0x00) ^\n  (if bit_to_bool(y[2]) then xt2(xt2(    x))  else 0x00) ^\n  (if bit_to_bool(y[3]) then xt2(xt2(xt2(x))) else 0x00)\n}"
  },
  {
    "name": "mem_read_meta",
    "source": "mem_read_priv_meta(typ, effectivePrivilege(typ, mstatus, cur_privilege), paddr, width, aq, rl, res, meta)"
  },
  {
    "name": "process_vlseg",
    "source": "{\n  let EMUL_reg : int = if EMUL_pow <= 0 then 1 else 2 ^ (EMUL_pow);\n  let width_type : word_width = size_bytes(load_width_bytes);\n  let vm_val : vector('n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\n  let vd_seg : vector('n, dec, bits('f * 'b * 8)) = read_vreg_seg(num_elem, load_width_bytes * 8, EMUL_pow, nf, vd);\n\n  let (result, mask) = init_masked_result(num_elem, nf * load_width_bytes * 8, EMUL_pow, vd_seg, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then { /* active segments */\n      vstart = to_bits(16, i);\n      foreach (j from 0 to (nf - 1)) {\n        let elem_offset = (i * nf + j) * load_width_bytes;\n        match ext_data_get_addr(rs1, to_bits(sizeof(xlen), elem_offset), Read(Data), load_width_bytes) {\n          Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); return RETIRE_FAIL },\n          Ext_DataAddr_OK(vaddr) =>\n              if check_misaligned(vaddr, width_type)\n              then { handle_mem_exception(vaddr, E_Load_Addr_Align()); return RETIRE_FAIL }\n              else match translateAddr(vaddr, Read(Data)) {\n                TR_Failure(e, _)     => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n                TR_Address(paddr, _) => {\n                  match mem_read(Read(Data), paddr, load_width_bytes, false, false, false) {\n                    MemValue(elem)   => write_single_element(load_width_bytes * 8, i, vd + to_bits(5, j * EMUL_reg), elem),\n                    MemException(e)  => { handle_mem_exception(vaddr, e); return RETIRE_FAIL }\n                  }\n                }\n              }\n        }\n      }\n    } else { /* prestart, masked or tail segments */\n      foreach (j from 0 to (nf - 1)) {\n        let skipped_elem = (result[i] >> (j * load_width_bytes * 8))[(load_width_bytes * 8 - 1) .. 0];\n        write_single_element(load_width_bytes * 8, i, vd + to_bits(5, j * EMUL_reg), skipped_elem)\n      }\n    }\n  };\n\n  vstart = zeros();\n  RETIRE_SUCCESS\n}"
  },
  {
    "name": "write_ram_ea",
    "source": "()"
  },
  {
    "name": "mem_read_priv",
    "source": "MemoryOpResult_drop_meta(mem_read_priv_meta(typ, priv, paddr, width, aq, rl, res, false))"
  },
  {
    "name": "neq_int",
    "source": "not_bool(eq_int(x, y))"
  },
  {
    "name": "within_clint",
    "source": "{\n  /* To avoid overflow issues when physical memory extends to the end\n   * of the addressable range, we need to perform address bound checks\n   * on unsigned unbounded integers.\n   */\n  let addr_int       = unsigned(addr);\n  let clint_base_int = unsigned(plat_clint_base ());\n  let clint_size_int = unsigned(plat_clint_size ());\n    clint_base_int <= addr_int\n  & (addr_int + sizeof('n)) <= (clint_base_int + clint_size_int)\n}"
  },
  {
    "name": "phys_mem_read",
    "source": "{\n  let result = (match read_kind_of_flags(aq, rl, res) {\n    Some(rk) => Some(read_ram(rk, paddr, width, meta)),\n    None()   => None()\n  }) : option((bits(8 * 'n), mem_meta));\n  match (t, result) {\n    (Execute(),  None()) => MemException(E_Fetch_Access_Fault()),\n    (Read(Data), None()) => MemException(E_Load_Access_Fault()),\n    (_,          None()) => MemException(E_SAMO_Access_Fault()),\n    (_,      Some(v, m)) => { if   get_config_print_mem()\n                              then print_mem(\"mem[\" ^ to_str(t) ^ \",\" ^ BitStr(paddr) ^ \"] -> \" ^ BitStr(v));\n                              MemValue(v, m) }\n  }\n}"
  },
  {
    "name": "set_sstatus_UXL",
    "source": "{\n  let m = Mk_Mstatus(s.bits);\n  let m = set_mstatus_UXL(m, a);\n  Mk_Sstatus(m.bits)\n}"
  },
  {
    "name": "riscv_f64MulAdd",
    "source": "{\n  extern_f64MulAdd(rm, v1, v2, v3);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "write_kind_of_flags",
    "source": "match (aq, rl, con) {\n    (false, false, false) => Write_plain,\n    (false, true,  false) => Write_RISCV_release,\n    (false, false, true)  => Write_RISCV_conditional,\n    (false, true , true)  => Write_RISCV_conditional_release,\n    (true,  true,  false) => Write_RISCV_strong_release,\n    (true,  true , true)  => Write_RISCV_conditional_strong_release,\n    // throw an illegal instruction here?\n    (true,  false, false) => throw(Error_not_implemented(\"store.aq\")),\n    (true,  false, true)  => throw(Error_not_implemented(\"sc.aq\"))\n  }"
  },
  {
    "name": "getbyte",
    "source": "(x >> to_bits(6, i * 8))[7..0]"
  },
  {
    "name": "_shr_int_general",
    "source": "if n >= 0 then _shr_int(m, n) else _shl_int(m, negate(n))"
  },
  {
    "name": "effectivePrivilege",
    "source": "if   t != Execute() & m[MPRV] == 0b1\n  then privLevel_of_bits(m[MPP])\n  else priv"
  },
  {
    "name": "fle_H",
    "source": "{\n  let (s1, e1, m1) = fsplit_H (v1);\n  let (s2, e2, m2) = fsplit_H (v2);\n\n  let v1Is0    = f_is_neg_zero_H(v1) | f_is_pos_zero_H(v1);\n  let v2Is0    = f_is_neg_zero_H(v2) | f_is_pos_zero_H(v2);\n\n  let result : bool =\n    if (s1 == 0b0) & (s2 == 0b0) then\n      if   (e1 == e2)\n      then unsigned (m1) <=  unsigned (m2)\n      else unsigned (e1)  <  unsigned (e2)\n    else if (s1 == 0b0) & (s2 == 0b1)\n    then (v1Is0 & v2Is0)                         /* Equal in this case (+0=-0) */\n    else if (s1 == 0b1) & (s2 == 0b0)\n    then true\n    else\n      if   (e1 == e2)\n      then unsigned (m1) >=  unsigned (m2)\n      else unsigned (e1)  >  unsigned (e2);\n\n  let fflags = if is_quiet then\n                 if   (f_is_SNaN_H(v1) | f_is_SNaN_H(v2))\n                 then nvFlag()\n                 else zeros()\n               else\n                 if   (f_is_NaN_H(v1) | f_is_NaN_H(v2))\n                 then nvFlag()\n                 else zeros();\n\n  (result, fflags)\n}"
  },
  {
    "name": "sail_branch_announce",
    "source": "()"
  },
  {
    "name": "rvfi_write",
    "source": "()"
  },
  {
    "name": "read_vmask",
    "source": "{\n  let VLEN = unsigned(vlenb) * 8;\n  assert(num_elem <= sizeof(vlenmax));\n  let vreg_val : vregtype = V(vrid);\n  var result   : vector('n, dec, bool) = undefined;\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if vm == 0b1 then {\n      result[i] = true\n    } else {\n      result[i] = bit_to_bool(vreg_val[i])\n    }\n  };\n\n  result\n}"
  },
  {
    "name": "fp_mul",
    "source": "{\n  let (fflags, result_val) : (bits_fflags, bits('m)) = match 'm {\n    16  => riscv_f16Mul(rm_3b, op1, op2),\n    32  => riscv_f32Mul(rm_3b, op1, op2),\n    64  => riscv_f64Mul(rm_3b, op1, op2)\n  };\n  accrue_fflags(fflags);\n  result_val\n}"
  },
  {
    "name": "trap_handler",
    "source": "{\n  rvfi_trap();\n  if   get_config_print_platform()\n  then print_platform(\"handling \" ^ (if intr then \"int#\" else \"exc#\")\n                      ^ BitStr(c) ^ \" at priv \" ^ to_str(del_priv)\n                      ^ \" with tval \" ^ BitStr(tval(info)));\n\n  match (del_priv) {\n    Machine => {\n       mcause[IsInterrupt] = bool_to_bits(intr);\n       mcause[Cause]       = zero_extend(c);\n\n       mstatus[MPIE] = mstatus[MIE];\n       mstatus[MIE]  = 0b0;\n       mstatus[MPP]  = privLevel_to_bits(cur_privilege);\n       mtval           = tval(info);\n       mepc            = pc;\n\n       cur_privilege   = del_priv;\n\n       handle_trap_extension(del_priv, pc, ext);\n\n       if   get_config_print_reg()\n       then print_reg(\"CSR mstatus <- \" ^ BitStr(mstatus.bits));\n\n       prepare_trap_vector(del_priv, mcause)\n    },\n    Supervisor => {\n       assert (extensionEnabled(Ext_S), \"no supervisor mode present for delegation\");\n\n       scause[IsInterrupt] = bool_to_bits(intr);\n       scause[Cause]       = zero_extend(c);\n\n       mstatus[SPIE] = mstatus[SIE];\n       mstatus[SIE]  = 0b0;\n       mstatus[SPP]  = match cur_privilege {\n                           User => 0b0,\n                           Supervisor => 0b1,\n                           Machine => internal_error(__FILE__, __LINE__, \"invalid privilege for s-mode trap\")\n                         };\n       stval           = tval(info);\n       sepc            = pc;\n\n       cur_privilege   = del_priv;\n\n       handle_trap_extension(del_priv, pc, ext);\n\n       if   get_config_print_reg()\n       then print_reg(\"CSR mstatus <- \" ^ BitStr(mstatus.bits));\n\n       prepare_trap_vector(del_priv, scause)\n    },\n    User => {\n       assert(extensionEnabled(Ext_U), \"no user mode present for delegation\");\n\n       ucause[IsInterrupt] = bool_to_bits(intr);\n       ucause[Cause]       = zero_extend(c);\n\n       mstatus[UPIE] = mstatus[UIE];\n       mstatus[UIE]  = 0b0;\n       utval           = tval(info);\n       uepc            = pc;\n\n       cur_privilege   = del_priv;\n\n       handle_trap_extension(del_priv, pc, ext);\n\n       if   get_config_print_reg()\n       then print_reg(\"CSR mstatus <- \" ^ BitStr(mstatus.bits));\n\n       prepare_trap_vector(del_priv, ucause)\n    }\n  };\n}"
  },
  {
    "name": "process_vssseg",
    "source": "{\n  let EMUL_reg : int = if EMUL_pow <= 0 then 1 else 2 ^ (EMUL_pow);\n  let width_type : word_width = size_bytes(load_width_bytes);\n  let vm_val  : vector('n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\n  let vs3_seg : vector('n, dec, bits('f * 'b * 8)) = read_vreg_seg(num_elem, load_width_bytes * 8, EMUL_pow, nf, vs3);\n  let rs2_val : int = signed(get_scalar(rs2, sizeof(xlen)));\n  let mask    : vector('n, dec, bool) = init_masked_source(num_elem, EMUL_pow, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then { /* active segments */\n      vstart = to_bits(16, i);\n      foreach (j from 0 to (nf - 1)) {\n        let elem_offset = i * rs2_val + j * load_width_bytes;\n        match ext_data_get_addr(rs1, to_bits(sizeof(xlen), elem_offset), Write(Data), load_width_bytes) {\n          Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); return RETIRE_FAIL },\n          Ext_DataAddr_OK(vaddr) =>\n            if check_misaligned(vaddr, width_type)\n            then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); return RETIRE_FAIL }\n            else match translateAddr(vaddr, Write(Data)) {\n              TR_Failure(e, _)     => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n              TR_Address(paddr, _) => {\n                let eares : MemoryOpResult(unit) = mem_write_ea(paddr, load_width_bytes, false, false, false);\n                match (eares) {\n                  MemException(e) => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n                  MemValue(_) => {\n                    let elem_val : bits('b * 8) = read_single_element(load_width_bytes * 8, i, vs3 + to_bits(5, j * EMUL_reg));\n                    let res : MemoryOpResult(bool) = mem_write_value(paddr, load_width_bytes, elem_val, false, false, false);\n                    match (res) {\n                      MemValue(true)  => (),\n                      MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                      MemException(e) => { handle_mem_exception(vaddr, e); return RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n        }\n      }\n    }\n  };\n\n  vstart = zeros();\n  RETIRE_SUCCESS\n}"
  },
  {
    "name": "match_TLB_Entry",
    "source": "(ent.global | (ent.asid == asid))\n  & (ent.vAddr == (ent.vMatchMask & vaddr))"
  },
  {
    "name": "process_fload16",
    "source": "match value {\n    MemValue(result) => { F(rd) = nan_box(result); RETIRE_SUCCESS },\n    MemException(e)  => { handle_mem_exception(addr, e); RETIRE_FAIL }\n  }"
  },
  {
    "name": "legalize_menvcfg",
    "source": "{\n  let v = Mk_MEnvcfg(v);\n  let o = [o with FIOM = if sys_enable_writable_fiom() then v[FIOM] else 0b0];\n  // Other extensions are not implemented yet so all other fields are read only zero.\n  o\n}"
  },
  {
    "name": "writeCSR",
    "source": "{\n  let res : option(xlenbits) =\n  match (csr, sizeof(xlen)) {\n    /* machine mode */\n    (0x300,  _) => { mstatus = legalize_mstatus(mstatus, value); Some(mstatus.bits) },\n    (0x301,  _) => { misa = legalize_misa(misa, value); Some(misa.bits) },\n    (0x302,  _) => { medeleg = legalize_medeleg(medeleg, value); Some(medeleg.bits) },\n    (0x303,  _) => { mideleg = legalize_mideleg(mideleg, value); Some(mideleg.bits) },\n    (0x304,  _) => { mie = legalize_mie(mie, value); Some(mie.bits) },\n    (0x305,  _) => { Some(set_mtvec(value)) },\n    (0x306,  _) => { mcounteren = legalize_mcounteren(mcounteren, value); Some(zero_extend(mcounteren.bits)) },\n    (0x30A, 32) => { menvcfg = legalize_menvcfg(menvcfg, menvcfg.bits[63 .. 32] @ value); Some(menvcfg.bits[31 .. 0]) },\n    (0x30A, 64) => { menvcfg = legalize_menvcfg(menvcfg, value); Some(menvcfg.bits) },\n    (0x310, 32) => { Some(mstatush.bits) }, // ignore writes for now\n    (0x31A, 32) => { menvcfg = legalize_menvcfg(menvcfg, value @ menvcfg.bits[31 .. 0]); Some(menvcfg.bits[63 .. 32]) },\n    (0x320,  _) => { mcountinhibit = legalize_mcountinhibit(mcountinhibit, value); Some(zero_extend(mcountinhibit.bits)) },\n    (0x340,  _) => { mscratch = value; Some(mscratch) },\n    (0x341,  _) => { Some(set_xret_target(Machine, value)) },\n    (0x342,  _) => { mcause.bits = value; Some(mcause.bits) },\n    (0x343,  _) => { mtval = value; Some(mtval) },\n    (0x344,  _) => { mip = legalize_mip(mip, value); Some(mip.bits) },\n\n    // pmpcfgN\n    (0x3A @ idx : bits(4),  _) if idx[0] == bitzero | sizeof(xlen) == 32 => {\n      let idx = unsigned(idx);\n      pmpWriteCfgReg(idx, value); Some(pmpReadCfgReg(idx))\n    },\n\n    // pmpaddrN. Unfortunately the PMP index does not nicely align with the CSR index bits.\n    (0x3B @ idx : bits(4),  _) => { let idx = unsigned(0b00 @ idx); pmpWriteAddrReg(idx, value); Some(pmpReadAddrReg(idx)) },\n    (0x3C @ idx : bits(4),  _) => { let idx = unsigned(0b01 @ idx); pmpWriteAddrReg(idx, value); Some(pmpReadAddrReg(idx)) },\n    (0x3D @ idx : bits(4),  _) => { let idx = unsigned(0b10 @ idx); pmpWriteAddrReg(idx, value); Some(pmpReadAddrReg(idx)) },\n    (0x3E @ idx : bits(4),  _) => { let idx = unsigned(0b11 @ idx); pmpWriteAddrReg(idx, value); Some(pmpReadAddrReg(idx)) },\n\n    /* machine mode counters */\n    (0xB00,  _) => { mcycle[(sizeof(xlen) - 1) .. 0] = value; Some(value) },\n    (0xB02,  _) => { minstret[(sizeof(xlen) - 1) .. 0] = value; minstret_increment = false; Some(value) },\n    (0xB80, 32) => { mcycle[63 .. 32] = value; Some(value) },\n    (0xB82, 32) => { minstret[63 .. 32] = value; minstret_increment = false; Some(value) },\n\n    /* trigger/debug */\n    (0x7a0,  _) => { tselect = value; Some(tselect) },\n\n    /* supervisor mode */\n    (0x100,  _) => { mstatus = legalize_sstatus(mstatus, value); Some(mstatus.bits) },\n    (0x102,  _) => { sedeleg = legalize_sedeleg(sedeleg, value); Some(sedeleg.bits) },\n    (0x103,  _) => { sideleg.bits = value; Some(sideleg.bits) }, /* TODO: does this need legalization? */\n    (0x104,  _) => { mie = legalize_sie(mie, mideleg, value); Some(mie.bits) },\n    (0x105,  _) => { Some(set_stvec(value)) },\n    (0x106,  _) => { scounteren = legalize_scounteren(scounteren, value); Some(zero_extend(scounteren.bits)) },\n    (0x10A,  _) => { senvcfg = legalize_senvcfg(senvcfg, zero_extend(value)); Some(senvcfg.bits[sizeof(xlen) - 1 .. 0]) },\n    (0x140,  _) => { sscratch = value; Some(sscratch) },\n    (0x141,  _) => { Some(set_xret_target(Supervisor, value)) },\n    (0x142,  _) => { scause.bits = value; Some(scause.bits) },\n    (0x143,  _) => { stval = value; Some(stval) },\n    (0x144,  _) => { mip = legalize_sip(mip, mideleg, value); Some(mip.bits) },\n    (0x180,  _) => { satp = legalize_satp(cur_Architecture(), satp, value); Some(satp) },\n\n    /* user mode: seed (entropy source). writes are ignored */\n    (0x015,  _) => write_seed_csr(),\n\n    /* vector */\n    (0x008, _) => { let vstart_length = get_vlen_pow(); vstart = zero_extend(16, value[(vstart_length - 1) .. 0]); Some(zero_extend(vstart)) },\n    (0x009, _) => { vxsat = value[0 .. 0]; Some(zero_extend(vxsat)) },\n    (0x00A, _) => { vxrm = value[1 .. 0]; Some(zero_extend(vxrm)) },\n    (0x00F, _) => { vcsr.bits = value[2 ..0]; Some(zero_extend(vcsr.bits)) },\n    (0xC20, _) => { vl = value; Some(vl) },\n    (0xC21, _) => { vtype.bits = value; Some(vtype.bits) },\n    (0xC22, _) => { vlenb = value; Some(vlenb) },\n\n    _           => ext_write_CSR(csr, value)\n  };\n  match res {\n    Some(v) => if   get_config_print_reg()\n               then print_reg(\"CSR \" ^ to_str(csr) ^ \" <- \" ^ BitStr(v) ^ \" (input: \" ^ BitStr(value) ^ \")\"),\n    None()  => print_bits(\"unhandled write to CSR \", csr)\n  }\n}"
  },
  {
    "name": "ext_check_CSR",
    "source": "true"
  },
  {
    "name": "riscv_i64ToF64",
    "source": "{\n  extern_i64ToF64(rm, v);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "process_rfvv_widen",
    "source": "{\n  let rm_3b          = fcsr[FRM];\n  let SEW_widen      = SEW * 2;\n  let LMUL_pow_widen = LMUL_pow + 1;\n  let num_elem_vd = get_num_elem(0, SEW_widen); /* vd regardless of LMUL setting */\n\n  if illegal_fp_reduction_widen(SEW, rm_3b, SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW >= 16 & SEW_widen <= 64);\n\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\n\n  let 'n = num_elem_vs;\n  let 'd = num_elem_vd;\n  let 'm = SEW;\n  let 'o = SEW_widen;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\n  let vd_val  : vector('d, dec, bits('o)) = read_vreg(num_elem_vd, SEW_widen, 0, vd);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\n  let mask    : vector('n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\n\n  var sum : bits('o) = read_single_element(SEW_widen, 0, vs1); /* vs1 regardless of LMUL setting */\n  foreach (i from 0 to (num_elem_vs - 1)) {\n    if mask[i] then {\n      /* currently ordered/unordered sum reductions do the same operations */\n      sum = fp_add(rm_3b, sum, fp_widen(vs2_val[i]))\n    }\n  };\n\n  write_single_element(SEW_widen, 0, vd, sum);\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\n  /* TODO: configuration support for agnostic behavior */\n  vstart = zeros();\n  RETIRE_SUCCESS\n}"
  },
  {
    "name": "riscv_f32Sqrt",
    "source": "{\n  extern_f32Sqrt(rm, v);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "init_masked_result",
    "source": "{\n  let start_element = get_start_element();\n  let end_element   = get_end_element();\n  let tail_ag : agtype = get_vtype_vta();\n  let mask_ag : agtype = get_vtype_vma();\n  var mask : vector('n, dec, bool) = undefined;\n  var result : vector('n, dec, bits('m)) = undefined;\n\n  /* Determine the actual number of elements when lmul < 1 */\n  let real_num_elem = if LMUL_pow >= 0 then num_elem else num_elem / (2 ^ (0 - LMUL_pow));\n  assert(num_elem >= real_num_elem);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if i < start_element then {\n      /* Prestart elements defined by vstart */\n      result[i] = vd_val[i];\n      mask[i] = false\n    } else if i > end_element then {\n      /* Tail elements defined by vl */\n      result[i] = match tail_ag {\n        UNDISTURBED => vd_val[i],\n        AGNOSTIC    => vd_val[i] /* TODO: configuration support */\n      };\n      mask[i] = false\n    } else if i >= real_num_elem then {\n      /* Tail elements defined by lmul < 1 */\n      result[i] = match tail_ag {\n        UNDISTURBED => vd_val[i],\n        AGNOSTIC    => vd_val[i] /* TODO: configuration support */\n      };\n      mask[i] = false\n    } else if not(vm_val[i]) then {\n      /* Inactive body elements defined by vm */\n      result[i] = match mask_ag {\n        UNDISTURBED => vd_val[i],\n        AGNOSTIC    => vd_val[i] /* TODO: configuration support */\n      };\n      mask[i] = false\n    } else {\n      /* Active body elements */\n      mask[i] = true;\n    }\n  };\n\n  (result, mask)\n}"
  },
  {
    "name": "riscv_f16Sub",
    "source": "{\n  extern_f16Sub(rm, v1, v2);\n  (float_fflags[4 .. 0], float_result[15 .. 0])\n}"
  },
  {
    "name": "lower_mie",
    "source": "{\n  let s : Sinterrupts = Mk_Sinterrupts(zero_extend(0b0));\n  let s = [s with SEI = m[SEI] & d[SEI]];\n  let s = [s with STI = m[STI] & d[STI]];\n  let s = [s with SSI = m[SSI] & d[SSI]];\n  let s = [s with UEI = m[UEI] & d[UEI]];\n  let s = [s with UTI = m[UTI] & d[UTI]];\n  let s = [s with USI = m[USI] & d[USI]];\n  s\n}"
  },
  {
    "name": "mem_write_value_priv_meta",
    "source": "{\n  if (rl | con) & not(is_aligned_addr(paddr, width))\n  then MemException(E_SAMO_Addr_Align())\n  else {\n    let result = checked_mem_write(paddr, width, value, typ, priv, meta, aq, rl, con);\n    rvfi_write(paddr, width, value, meta, result);\n    result\n  }\n}"
  },
  {
    "name": "riscv_f32ToUi16",
    "source": "{\n  let (_, sig32) = riscv_f32ToUi32(rm, v);\n  if unsigned(sig32) > unsigned(ones(16)) then (nvFlag(), ones(16))\n  else (zeros(5), sig32[15 .. 0]);\n}"
  },
  {
    "name": "handle_interrupt",
    "source": "set_next_pc(trap_handler(del_priv, true, interruptType_to_bits(i), PC, None(), None()))"
  },
  {
    "name": "flt_D",
    "source": "{\n  let (s1, e1, m1) = fsplit_D (v1);\n  let (s2, e2, m2) = fsplit_D (v2);\n\n  let result : bool =\n    if (s1 == 0b0) & (s2 == 0b0) then\n      if   (e1 == e2)\n      then unsigned (m1) < unsigned (m2)\n      else unsigned (e1) < unsigned (e2)\n    else if (s1 == 0b0) & (s2 == 0b1) then\n      false\n    else if (s1 == 0b1) & (s2 == 0b0) then\n      true\n    else\n      if   (e1 == e2)\n      then unsigned (m1) > unsigned (m2)\n      else unsigned (e1) > unsigned (e2);\n\n  let fflags = if is_quiet then\n                 if   (f_is_SNaN_D(v1) | f_is_SNaN_D(v2))\n                 then nvFlag()\n                 else zeros()\n               else\n                 if   (f_is_NaN_D(v1) | f_is_NaN_D(v2))\n                 then nvFlag()\n                 else zeros();\n\n  (result, fflags)\n}"
  },
  {
    "name": "mem_read_priv_meta",
    "source": "{\n  let result : MemoryOpResult((bits(8 * 'n), mem_meta)) =\n    if (aq | res) & not(is_aligned_addr(paddr, width))\n    then MemException(E_Load_Addr_Align())\n    else match (aq, rl, res) {\n      (false, true,  false) => throw(Error_not_implemented(\"load.rl\")),\n      (false, true,  true)  => throw(Error_not_implemented(\"lr.rl\")),\n      (_, _, _)             => checked_mem_read(typ, priv, paddr, width, aq, rl, res, meta)\n    };\n  rvfi_read(paddr, width, result);\n  result\n}"
  },
  {
    "name": "riscv_f16Recip7",
    "source": "{\n  let (round_abnormal_true, res_true) = recip7(v, rm, true);\n  let (round_abnormal_false, res_false) = recip7(v, rm, false);\n  match fp_class(v) {\n    0x0001 => (zeros(5), 0x8000),\n    0x0080 => (zeros(5), 0x0000),\n    0x0008 => (dzFlag(), 0xfc00),\n    0x0010 => (dzFlag(), 0x7c00),\n    0x0100 => (nvFlag(), 0x7e00),\n    0x0200 => (zeros(5), 0x7e00),\n    0x0004 => if round_abnormal_true then (nxFlag() | ofFlag(), res_true[15 .. 0]) else (zeros(5), res_true[15 .. 0]),\n    0x0020 => if round_abnormal_true then (nxFlag() | ofFlag(), res_true[15 .. 0]) else (zeros(5), res_true[15 .. 0]),\n    _      => if round_abnormal_false then (nxFlag() | ofFlag(), res_false[15 .. 0]) else (zeros(5), res_false[15 .. 0])\n  }\n}"
  },
  {
    "name": "riscv_ui64ToF32",
    "source": "{\n  extern_ui64ToF32(rm, v);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "aqrl_str",
    "source": "match (aq, rl) {\n    (false, false) => \"\",\n    (false, true)  => \".rl\",\n    (true, false)  => \".aq\",\n    (true, true)   => \".aqrl\"\n  }"
  },
  {
    "name": "ext_data_get_addr",
    "source": "let addr = X(base) + offset in\n  Ext_DataAddr_OK(addr)"
  },
  {
    "name": "process_clean_inval",
    "source": "{\n  let rs1_val = X(rs1);\n  let cache_block_size_exp = plat_cache_block_size_exp();\n  let cache_block_size = 2 ^ cache_block_size_exp;\n\n  // Offset from rs1 to the beginning of the cache block. This is 0 if rs1\n  // is aligned to the cache block, or negative if rs1 is misaligned.\n  let offset = (rs1_val & ~(zero_extend(ones(cache_block_size_exp)))) - rs1_val;\n\n  // TODO: This is incorrect since CHERI only requires at least one byte\n  // to be in bounds here, whereas `ext_data_get_addr()` checks that all bytes\n  // are in bounds. We will need to add a new function, parameter or access type.\n  match ext_data_get_addr(rs1, offset, Read(Data), cache_block_size) {\n    Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL },\n    Ext_DataAddr_OK(vaddr) => {\n      let res: option(ExceptionType) = match translateAddr(vaddr, Read(Data)) {\n        TR_Address(paddr, _) => {\n          // \"A cache-block management instruction is permitted to access the\n          // specified cache block whenever a load instruction or store instruction\n          // is permitted to access the corresponding physical addresses. If\n          // neither a load instruction nor store instruction is permitted to\n          // access the physical addresses, but an instruction fetch is permitted\n          // to access the physical addresses, whether a cache-block management\n          // instruction is permitted to access the cache block is UNSPECIFIED.\"\n          //\n          // In this implementation we currently don't allow access for fetches.\n          let exc_read = phys_access_check(Read(Data), cur_privilege, paddr, cache_block_size);\n          let exc_write = phys_access_check(Write(Data), cur_privilege, paddr, cache_block_size);\n          match (exc_read, exc_write) {\n            // Access is permitted if read OR write are allowed. If neither\n            // are allowed then we always report a store exception.\n            (Some(exc_read), Some(exc_write)) => Some(exc_write),\n            _ => None(),\n          }\n        },\n        TR_Failure(e, _) => Some(e)\n      };\n      // \"If access to the cache block is not permitted, a cache-block management\n      //  instruction raises a store page fault or store guest-page fault exception\n      //  if address translation does not permit any access or raises a store access\n      //  fault exception otherwise.\"\n      match res {\n        // The model has no caches so there's no action required.\n        None() => RETIRE_SUCCESS,\n        Some(e) => {\n          let e : ExceptionType = match e {\n            E_Load_Access_Fault() => E_SAMO_Access_Fault(),\n            E_SAMO_Access_Fault() => E_SAMO_Access_Fault(),\n            E_Load_Page_Fault() => E_SAMO_Page_Fault(),\n            E_SAMO_Page_Fault() => E_SAMO_Page_Fault(),\n            // No other exceptions should be generated since we're not checking\n            // for fetch access and it's can't be misaligned.\n            _ => internal_error(__FILE__, __LINE__, \"unexpected exception for cmo.clean/inval\"),\n          };\n          handle_mem_exception(vaddr, e);\n          RETIRE_FAIL\n        }\n      }\n    }\n  }\n}"
  },
  {
    "name": "pmpCheck",
    "source": "{\n  let width : xlenbits = to_bits(sizeof(xlen), width);\n\n  foreach (i from 0 to 63) {\n    let prev_pmpaddr = (if i > 0 then pmpReadAddrReg(i - 1) else zeros());\n    match pmpMatchEntry(addr, width, acc, priv, pmpcfg_n[i], pmpReadAddrReg(i), prev_pmpaddr) {\n      PMP_Success  => { return None(); },\n      PMP_Fail     => { return Some(accessToFault(acc)); },\n      PMP_Continue => (),\n    }\n  };\n  if priv == Machine then None() else Some(accessToFault(acc))\n}"
  },
  {
    "name": "riscv_f64Sub",
    "source": "{\n  extern_f64Sub(rm, v1, v2);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "fp_eq",
    "source": "{\n  let (fflags, result_val) : (bits_fflags, bool) = match 'm {\n    16  => riscv_f16Eq(op1, op2),\n    32  => riscv_f32Eq(op1, op2),\n    64  => riscv_f64Eq(op1, op2)\n  };\n  accrue_fflags(fflags);\n  result_val\n}"
  },
  {
    "name": "riscv_i32ToF32",
    "source": "{\n  extern_i32ToF32(rm, v);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "sail_mark_register",
    "source": "()"
  },
  {
    "name": "riscv_f16Eq",
    "source": "{\n  extern_f16Eq(v1, v2);\n  (float_fflags[4 .. 0], bit_to_bool(float_result[0]))\n}"
  },
  {
    "name": "fp_mulsub",
    "source": "{\n  let opsub = negate_fp(opsub);\n  let (fflags, result_val) : (bits_fflags, bits('m)) = match 'm {\n    16  => riscv_f16MulAdd(rm_3b, op1, op2, opsub),\n    32  => riscv_f32MulAdd(rm_3b, op1, op2, opsub),\n    64  => riscv_f64MulAdd(rm_3b, op1, op2, opsub)\n  };\n  accrue_fflags(fflags);\n  result_val\n}"
  },
  {
    "name": "illegal_load",
    "source": "{\n  not(valid_vtype()) | not(valid_rd_mask(vd, vm)) |\n  not(valid_eew_emul(EEW, EMUL_pow)) | not(valid_segment(nf, EMUL_pow))\n}"
  },
  {
    "name": "neq_anything",
    "source": "not_bool(eq_anything(x, y))"
  },
  {
    "name": "lookup_TLB",
    "source": "{\n  let index = tlb_hash(vaddr);\n  match tlb[index] {\n    None() => None(),\n    Some(entry) => if match_TLB_Entry(entry, asid, vaddr) then Some((index, entry)) else None(),\n  }\n}"
  },
  {
    "name": "extend_value",
    "source": "if is_unsigned then zero_extend(value) else sign_extend(value)"
  },
  {
    "name": "read_vreg_seg",
    "source": "{\n  assert('q * 'm > 0);\n  let LMUL_reg : int = if LMUL_pow <= 0 then 1 else 2 ^ (LMUL_pow);\n  var vreg_list : vector('q, dec, vector('n, dec, bits('m))) = undefined;\n  var result : vector('n, dec, bits('q * 'm)) = undefined;\n  foreach (j from 0 to (nf - 1)) {\n    vreg_list[j] = read_vreg(num_elem, SEW, LMUL_pow, vrid + to_bits(5, j * LMUL_reg));\n  };\n  foreach (i from 0 to (num_elem - 1)) {\n    result[i] = zeros('q * 'm);\n    foreach (j from 0 to (nf - 1)) {\n      result[i] = result[i] | (zero_extend(vreg_list[j][i]) << (j * 'm))\n    }\n  };\n  result\n}"
  },
  {
    "name": "riscv_f32Rsqrte7",
    "source": "{\n  match fp_class(v)[15 .. 0] {\n    0x0001 => (nvFlag(), 0x7fc00000),\n    0x0002 => (nvFlag(), 0x7fc00000),\n    0x0004 => (nvFlag(), 0x7fc00000),\n    0x0100 => (nvFlag(), 0x7fc00000),\n    0x0200 => (zeros(5), 0x7fc00000),\n    0x0008 => (dzFlag(), 0xff800000),\n    0x0010 => (dzFlag(), 0x7f800000),\n    0x0080 => (zeros(5), 0x00000000),\n    0x0020 => (zeros(5), rsqrt7(v, true)[31 .. 0]),\n    _      => (zeros(5), rsqrt7(v, false)[31 .. 0])\n  }\n}"
  },
  {
    "name": "neq_bool",
    "source": "not_bool(eq_bool(x, y))"
  },
  {
    "name": "ext_write_vcsr",
    "source": "{\n  vcsr[vxrm]  = vxrm_val; /* Note: frm can be an illegal value, 101, 110, 111 */\n  vcsr[vxsat] = vxsat_val;\n  dirty_v_context_if_present()\n}"
  },
  {
    "name": "signed_saturation",
    "source": "{\n  if signed(elem) > signed(0b0 @ ones('m - 1)) then {\n    vxsat = 0b1;\n    0b0 @ ones('m - 1)\n  } else if signed(elem) < signed(0b1 @ zeros('m - 1)) then {\n    vxsat = 0b1;\n    0b1 @ zeros('m - 1)\n  } else {\n    vxsat = 0b0;\n    elem['m - 1 .. 0]\n  };\n}"
  },
  {
    "name": "riscv_f32ToUi32",
    "source": "{\n  extern_f32ToUi32(rm, v);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "process_rfvv_single",
    "source": "{\n  let rm_3b = fcsr[FRM];\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\n\n  if illegal_fp_reduction(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\n  assert(SEW != 8);\n\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\n\n  let 'n = num_elem_vs;\n  let 'd = num_elem_vd;\n  let 'm = SEW;\n\n  let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\n  let vd_val  : vector('d, dec, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd);\n  let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\n  let mask    : vector('n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\n\n  var sum : bits('m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\n  foreach (i from 0 to (num_elem_vs - 1)) {\n    if mask[i] then {\n      sum = match funct6 {\n        /* currently ordered/unordered sum reductions do the same operations */\n        FVV_VFREDOSUM   => fp_add(rm_3b, sum, vs2_val[i]),\n        FVV_VFREDUSUM   => fp_add(rm_3b, sum, vs2_val[i]),\n        FVV_VFREDMAX    => fp_max(sum, vs2_val[i]),\n        FVV_VFREDMIN    => fp_min(sum, vs2_val[i]),\n        _               => internal_error(__FILE__, __LINE__, \"Widening op unexpected\")\n      }\n    }\n  };\n\n  write_single_element(SEW, 0, vd, sum);\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\n  /* TODO: configuration support for agnostic behavior */\n  vstart = zeros();\n  RETIRE_SUCCESS\n}"
  },
  {
    "name": "legalize_sip",
    "source": "{\n  lift_sip(m, d, Mk_Sinterrupts(v))\n}"
  },
  {
    "name": "riscv_f64ToF16",
    "source": "{\n  extern_f64ToF16(rm, v);\n  (float_fflags[4 .. 0], float_result[15 .. 0])\n}"
  },
  {
    "name": "wF",
    "source": "{\n  assert(sys_enable_fdext());\n  let v = fregval_into_freg(in_v);\n  match r {\n    0  => f0 = v,\n    1  => f1 = v,\n    2  => f2 = v,\n    3  => f3 = v,\n    4  => f4 = v,\n    5  => f5 = v,\n    6  => f6 = v,\n    7  => f7 = v,\n    8  => f8 = v,\n    9  => f9 = v,\n    10 => f10 = v,\n    11 => f11 = v,\n    12 => f12 = v,\n    13 => f13 = v,\n    14 => f14 = v,\n    15 => f15 = v,\n    16 => f16 = v,\n    17 => f17 = v,\n    18 => f18 = v,\n    19 => f19 = v,\n    20 => f20 = v,\n    21 => f21 = v,\n    22 => f22 = v,\n    23 => f23 = v,\n    24 => f24 = v,\n    25 => f25 = v,\n    26 => f26 = v,\n    27 => f27 = v,\n    28 => f28 = v,\n    29 => f29 = v,\n    30 => f30 = v,\n    31 => f31 = v,\n    _  => assert(false, \"invalid floating point register number\")\n  };\n\n  dirty_fd_context();\n\n  if   get_config_print_reg()\n  then\n      /* TODO: will only print bits; should we print in floating point format? */\n      print_reg(\"f\" ^ dec_str(r) ^ \" <- \" ^ FRegStr(v));\n}"
  },
  {
    "name": "unwrap_or",
    "source": "match r {\n    Ok(x) => x,\n    Err(_) => y\n}"
  },
  {
    "name": "is_valid_vAddr",
    "source": "vAddr == sign_extend(vAddr[va_size_bits - 1 .. 0])"
  },
  {
    "name": "check_Counteren",
    "source": "match(csr, p) {\n    (0xC00, Supervisor) => mcounteren[CY] == 0b1,\n    (0xC01, Supervisor) => mcounteren[TM] == 0b1,\n    (0xC02, Supervisor) => mcounteren[IR] == 0b1,\n\n    (0xC00, User) => mcounteren[CY] == 0b1 & (not(extensionEnabled(Ext_S)) | scounteren[CY] == 0b1),\n    (0xC01, User) => mcounteren[TM] == 0b1 & (not(extensionEnabled(Ext_S)) | scounteren[TM] == 0b1),\n    (0xC02, User) => mcounteren[IR] == 0b1 & (not(extensionEnabled(Ext_S)) | scounteren[IR] == 0b1),\n\n    (_, _) => /* no HPM counters for now */\n              if   0xC03 <=_u csr & csr <=_u 0xC1F\n              then false\n              else true\n  }"
  },
  {
    "name": "htif_load",
    "source": "{\n  if   get_config_print_platform()\n  then print_platform(\"htif[\" ^ BitStr(paddr) ^ \"] -> \" ^ BitStr(htif_tohost));\n  /* FIXME: For now, only allow the expected access widths. */\n  if      width == 8 & (paddr == plat_htif_tohost())\n  then    MemValue(sail_zero_extend(htif_tohost, 64))         /* FIXME: Redundant zero_extend currently required by Lem backend */\n  else if width == 4 & paddr == plat_htif_tohost()\n  then    MemValue(sail_zero_extend(htif_tohost[31..0], 32))  /* FIXME: Redundant zero_extend currently required by Lem backend */\n  else if width == 4 & paddr == plat_htif_tohost() + 4\n  then    MemValue(sail_zero_extend(htif_tohost[63..32], 32)) /* FIXME: Redundant zero_extend currently required by Lem backend */\n  else match t {\n    Execute()  => MemException(E_Fetch_Access_Fault()),\n    Read(Data) => MemException(E_Load_Access_Fault()),\n    _          => MemException(E_SAMO_Access_Fault())\n  }\n}"
  },
  {
    "name": "pmpMatchEntry",
    "source": "{\n  let rng = pmpAddrRange(ent, pmpaddr, prev_pmpaddr);\n  match pmpMatchAddr(addr, width, rng) {\n    PMP_NoMatch      => PMP_Continue,\n    PMP_PartialMatch => PMP_Fail,\n    PMP_Match        => if   pmpCheckPerms(ent, acc, priv)\n                        then PMP_Success\n                        else PMP_Fail\n  }\n}"
  },
  {
    "name": "translateAddr",
    "source": "{\n  // Internally the vmem code works with 64-bit values, whether xlen==32 or xlen==64\n  // This 'extend' is a no-op when xlen==64 and extends when xlen==32\n  let vAddr_64b : bits(64) = zero_extend(vAddr);\n  // Effective privilege takes into account mstatus.PRV, mstatus.MPP\n  // See riscv_sys_regs.sail for effectivePrivilege() and cur_privilege\n  let effPriv   : Privilege = effectivePrivilege(ac, mstatus, cur_privilege);\n  let mode      : SATPMode  = translationMode(effPriv);\n  let (valid_va, sv_params) : (bool, SV_Params) = match mode {\n    Sbare => return TR_Address(vAddr, init_ext_ptw),\n    Sv32  => (true,                                 sv32_params),\n    Sv39  => (is_valid_vAddr(sv39_params, vAddr_64b), sv39_params),\n    Sv48  => (is_valid_vAddr(sv48_params, vAddr_64b), sv48_params),\n    // Sv57 => (is_valid_vAddr(sv57_params, vAddr_64b), sv57_params),    // TODO\n  };\n  if not(valid_va) then\n    TR_Failure(translationException(ac, PTW_Invalid_Addr()), init_ext_ptw)\n  else {\n    let mxr               = mstatus[MXR] == 0b1;\n    let do_sum            = mstatus[SUM] == 0b1;\n    let asid   : asidbits = satp_to_asid(satp);\n    let ptb    : bits(64) = satp_to_PT_base(satp);\n    let tr_result1 = translate(sv_params,\n                               asid,\n                               ptb,\n                               vAddr_64b,\n                               ac, effPriv, mxr, do_sum,\n                               init_ext_ptw);\n    // Fixup result PA or exception\n    match tr_result1 {\n      TR_Address(pa, ext_ptw) => TR_Address(truncate(pa, sizeof(xlen)), ext_ptw),\n      TR_Failure(f, ext_ptw)  => TR_Failure(translationException(ac, f), ext_ptw)\n    }\n  }\n}"
  },
  {
    "name": "lower_sie",
    "source": "{\n  let u : Uinterrupts = Mk_Uinterrupts(zero_extend(0b0));\n  let u = [u with UEI = s[UEI] & d[UEI]];\n  let u = [u with UTI = s[UTI] & d[UTI]];\n  let u = [u with USI = s[USI] & d[USI]];\n  u\n}"
  },
  {
    "name": "process_vsre",
    "source": "{\n  let width_type : word_width = BYTE;\n  let start_element = get_start_element();\n  if start_element >= nf * elem_per_reg then return RETIRE_SUCCESS; /* no elements are written if vstart >= evl */\n  let elem_to_align : int = start_element % elem_per_reg;\n  var cur_field : int = start_element / elem_per_reg;\n  var cur_elem  : int = start_element;\n\n  if elem_to_align > 0 then {\n    foreach (i from elem_to_align to (elem_per_reg - 1)) {\n      vstart = to_bits(16, cur_elem);\n      let elem_offset : int = cur_elem * load_width_bytes;\n      match ext_data_get_addr(rs1, to_bits(sizeof(xlen), elem_offset), Write(Data), load_width_bytes) {\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); return RETIRE_FAIL },\n        Ext_DataAddr_OK(vaddr) =>\n          if check_misaligned(vaddr, width_type)\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); return RETIRE_FAIL }\n          else match translateAddr(vaddr, Write(Data)) {\n            TR_Failure(e, _)     => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n            TR_Address(paddr, _) => {\n              let eares : MemoryOpResult(unit) = mem_write_ea(paddr, load_width_bytes, false, false, false);\n              match (eares) {\n                MemException(e) => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n                MemValue(_) => {\n                  let elem : bits('b * 8) = read_single_element(load_width_bytes * 8, i, vs3 + to_bits(5, cur_field));\n                  let res : MemoryOpResult(bool) = mem_write_value(paddr, load_width_bytes, elem, false, false, false);\n                  match (res) {\n                    MemValue(true)  => (),\n                    MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                    MemException(e) => { handle_mem_exception(vaddr, e); return RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n      };\n      cur_elem = cur_elem + 1\n    };\n    cur_field = cur_field + 1\n  };\n\n  foreach (j from cur_field to (nf - 1)) {\n    let vs3_val : vector('n, dec, bits('b * 8)) = read_vreg(elem_per_reg, load_width_bytes * 8, 0, vs3 + to_bits(5, j));\n    foreach (i from 0 to (elem_per_reg - 1)) {\n      vstart = to_bits(16, cur_elem);\n      let elem_offset = cur_elem * load_width_bytes;\n      match ext_data_get_addr(rs1, to_bits(sizeof(xlen), elem_offset), Write(Data), load_width_bytes) {\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); return RETIRE_FAIL },\n        Ext_DataAddr_OK(vaddr) =>\n          if check_misaligned(vaddr, width_type)\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); return RETIRE_FAIL }\n          else match translateAddr(vaddr, Write(Data)) {\n            TR_Failure(e, _)     => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n            TR_Address(paddr, _) => {\n              let eares : MemoryOpResult(unit) = mem_write_ea(paddr, load_width_bytes, false, false, false);\n              match (eares) {\n                MemException(e) => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n                MemValue(_) => {\n                  let res : MemoryOpResult(bool) = mem_write_value(paddr, load_width_bytes, vs3_val[i], false, false, false);\n                  match (res) {\n                    MemValue(true)  => (),\n                    MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                    MemException(e) => { handle_mem_exception(vaddr, e); return RETIRE_FAIL }\n                  }\n                }\n              }\n            }\n          }\n      };\n      cur_elem = cur_elem + 1\n    }\n  };\n\n  vstart = zeros();\n  RETIRE_SUCCESS\n}"
  },
  {
    "name": "illegal_indexed_load",
    "source": "{\n  not(valid_vtype()) | not(valid_rd_mask(vd, vm)) |\n  not(valid_eew_emul(EEW_index, EMUL_pow_index)) | not(valid_segment(nf, EMUL_pow_data))\n}"
  },
  {
    "name": "vpn_j_of_va",
    "source": "{\n  let lsb  : range(0,63) = pagesize_bits + level * sv_params.vpn_size_bits;\n  assert (lsb < sizeof(xlen));\n  let mask : bits(64) = zero_extend(ones(sv_params.vpn_size_bits));\n  ((va >> lsb) & mask)\n}"
  },
  {
    "name": "mem_write_value",
    "source": "{\n  mem_write_value_meta(paddr, width, value, default_write_acc, default_meta, aq, rl, con)\n}"
  },
  {
    "name": "eq_unit",
    "source": "true"
  },
  {
    "name": "phys_access_check",
    "source": "{\n  let pmpError : option(ExceptionType) = if sys_pmp_count() == 0 then None() else pmpCheck(paddr, width, t, p);\n  // TODO: Also check PMAs and select the highest priority fault.\n  pmpError\n}"
  },
  {
    "name": "valid_eew_emul",
    "source": "{\n  let ELEN = 2 ^ get_elen_pow();\n  EEW >= 8 & EEW <= ELEN & EMUL_pow >= -3 & EMUL_pow <= 3\n}"
  },
  {
    "name": "update_PTE_Bits",
    "source": "{\n  let pte_flags = Mk_PTE_Flags(pte [7 .. 0]);\n\n  // Update 'dirty' bit?\n  let update_d : bool = (pte_flags[D] == 0b0)\n                        & (match a {\n                             Execute()       => false,\n                             Read()          => false,\n                             Write(_)        => true,\n                             ReadWrite(_, _) => true\n                           });\n  // Update 'accessed'-bit?\n  let update_a = (pte_flags[A] == 0b0);\n\n  if update_d | update_a then {\n    let pte_flags = [pte_flags with\n                      A = 0b1,\n                      D = (if update_d then 0b1 else pte_flags[D])];\n    Some(pte[63 .. 8] @ pte_flags.bits)\n  }\n  else\n    None()\n}"
  },
  {
    "name": "check_TVM_SATP",
    "source": "not(csr == 0x180 & p == Supervisor & mstatus[TVM] == 0b1)"
  },
  {
    "name": "check_seed_CSR",
    "source": "{\n  if not(csr == 0x015) then {\n    true\n  } else if not(isWrite) then {\n    /* Read-only access to the seed CSR is not allowed */\n    false\n  } else {\n    match (p) {\n      Machine => true,\n      Supervisor => false, /* TODO: base this on mseccfg */\n      User => false, /* TODO: base this on mseccfg */\n    }\n  }\n}"
  },
  {
    "name": "write_TLB",
    "source": "tlb[index] = Some(ent)"
  },
  {
    "name": "riscv_f16Lt_quiet",
    "source": "{\n  extern_f16Lt_quiet(v1, v2);\n  (float_fflags[4 .. 0], bit_to_bool(float_result[0]))\n}"
  },
  {
    "name": "rotater",
    "source": "(v >> n) | (v << (length(v) - n))"
  },
  {
    "name": "internal_error",
    "source": "{\n    assert (false, file ^ \":\" ^ dec_str(line) ^ \": \" ^ s);\n    throw Error_internal_error()\n}"
  },
  {
    "name": "riscv_f32ToUi64",
    "source": "{\n  extern_f32ToUi64(rm, v);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "riscv_f16ToUi32",
    "source": "{\n  extern_f16ToUi32(rm, v);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "check_CSR",
    "source": "is_CSR_defined(csr)\n  & check_CSR_access(csrAccess(csr), csrPriv(csr), p, isWrite)\n  & check_TVM_SATP(csr, p)\n  & check_Counteren(csr, p)\n  & check_seed_CSR(csr, p, isWrite)"
  },
  {
    "name": "within_htif_writable",
    "source": "plat_htif_tohost() == addr | (plat_htif_tohost() + 4 == addr & width == 4)"
  },
  {
    "name": "fp_min",
    "source": "{\n  let (fflags, op1_lt_op2) : (bits_fflags, bool) = match 'm {\n    16  => riscv_f16Lt_quiet(op1, op2),\n    32  => riscv_f32Lt_quiet(op1, op2),\n    64  => riscv_f64Lt_quiet(op1, op2)\n  };\n\n  let result_val = if (f_is_NaN(op1) & f_is_NaN(op2)) then canonical_NaN('m)\n                else if f_is_NaN(op1) then op2\n                else if f_is_NaN(op2) then op1\n                else if (f_is_neg_zero(op1) & f_is_pos_zero(op2)) then op1\n                else if (f_is_neg_zero(op2) & f_is_pos_zero(op1)) then op2\n                else if op1_lt_op2 then op1\n                else op2;\n  accrue_fflags(fflags);\n  result_val\n}"
  },
  {
    "name": "riscv_f64Add",
    "source": "{\n  extern_f64Add(rm, v1, v2);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "riscv_f32Mul",
    "source": "{\n  extern_f32Mul(rm, v1, v2);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "lift_sip",
    "source": "{\n  let m : Minterrupts = o;\n  let m = if d[SSI] == 0b1 then [m with SSI = s[SSI]] else m;\n  if extensionEnabled(Ext_N) then {\n    let m = if d[UEI] == 0b1 then [m with UEI = s[UEI]] else m;\n    let m = if d[USI] == 0b1 then [m with USI = s[USI]] else m;\n    m\n  } else m\n}"
  },
  {
    "name": "riscv_f32roundToInt",
    "source": "{\n  extern_f32roundToInt(rm, v, exact);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "riscv_f16ToF32",
    "source": "{\n  extern_f16ToF32(rm, v);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "is_aligned",
    "source": "match width {\n    BYTE   => true,\n    HALF   => vaddr[0..0] == zeros(),\n    WORD   => vaddr[1..0] == zeros(),\n    DOUBLE => vaddr[2..0] == zeros(),\n  }"
  },
  {
    "name": "legalize_satp32",
    "source": "{\n  /* all 32-bit satp modes are valid */\n  v\n}"
  },
  {
    "name": "slice_mask",
    "source": "if l >= n then {\n    sail_shiftleft(sail_ones(n), i)\n  } else {\n    let one : bits('n) = sail_mask(n, [bitone] : bits(1)) in\n    sail_shiftleft(sub_bits(sail_shiftleft(one, l), one), i)\n  }"
  },
  {
    "name": "sail_mask",
    "source": "if len <= length(v) then truncate(v, len) else sail_zero_extend(v, len)"
  },
  {
    "name": "mmio_write",
    "source": "if   within_clint(paddr, width)\n  then clint_store(paddr, width, data)\n  else if within_htif_writable(paddr, width) & 'n <= 8\n  then htif_store(paddr, width, data)\n  else MemException(E_SAMO_Access_Fault())"
  },
  {
    "name": "riscv_f64ToI32",
    "source": "{\n  extern_f64ToI32(rm, v);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "rotatel",
    "source": "(v << n) | (v >> (length(v) - n))"
  },
  {
    "name": "legalize_mip",
    "source": "{\n  /* The only writable bits are the S-mode bits, and with the 'N'\n   * extension, the U-mode bits. */\n  let v = Mk_Minterrupts(v);\n  let m = [o with SEI = v[SEI], STI = v[STI], SSI = v[SSI]];\n  if extensionEnabled(Ext_U) & extensionEnabled(Ext_N) then {\n    [m with UEI = v[UEI], UTI = v[UTI], USI = v[USI]]\n  } else m\n}"
  },
  {
    "name": "process_vlsseg",
    "source": "{\n  let EMUL_reg : int = if EMUL_pow <= 0 then 1 else 2 ^ (EMUL_pow);\n  let width_type : word_width = size_bytes(load_width_bytes);\n  let vm_val  : vector('n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\n  let vd_seg  : vector('n, dec, bits('f * 'b * 8)) = read_vreg_seg(num_elem, load_width_bytes * 8, EMUL_pow, nf, vd);\n  let rs2_val : int = signed(get_scalar(rs2, sizeof(xlen)));\n\n  let (result, mask) = init_masked_result(num_elem, nf * load_width_bytes * 8, EMUL_pow, vd_seg, vm_val);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then { /* active segments */\n      vstart = to_bits(16, i);\n      foreach (j from 0 to (nf - 1)) {\n        let elem_offset = i * rs2_val + j * load_width_bytes;\n        match ext_data_get_addr(rs1, to_bits(sizeof(xlen), elem_offset), Read(Data), load_width_bytes) {\n          Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); return RETIRE_FAIL },\n          Ext_DataAddr_OK(vaddr) =>\n            if check_misaligned(vaddr, width_type)\n            then { handle_mem_exception(vaddr, E_Load_Addr_Align()); return RETIRE_FAIL }\n            else match translateAddr(vaddr, Read(Data)) {\n              TR_Failure(e, _)     => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n              TR_Address(paddr, _) => {\n                match mem_read(Read(Data), paddr, load_width_bytes, false, false, false) {\n                  MemValue(elem)   => write_single_element(load_width_bytes * 8, i, vd + to_bits(5, j * EMUL_reg), elem),\n                  MemException(e)  => { handle_mem_exception(vaddr, e); return RETIRE_FAIL }\n                }\n              }\n            }\n        }\n      }\n    } else { /* prestart, masked or tail segments */\n      foreach (j from 0 to (nf - 1)) {\n        let skipped_elem = (result[i] >> (j * load_width_bytes * 8))[(load_width_bytes * 8 - 1) .. 0];\n        write_single_element(load_width_bytes * 8, i, vd + to_bits(5, j * EMUL_reg), skipped_elem)\n      }\n    }\n  };\n\n  vstart = zeros();\n  RETIRE_SUCCESS\n}"
  },
  {
    "name": "read_ram",
    "source": "{\n  let meta = if read_meta then __ReadRAM_Meta(addr, width) else default_meta;\n  let request : Mem_read_request('n, 64, xlenbits, unit, RISCV_strong_access) = struct {\n    access_kind = match rk {\n      Read_plain => AK_explicit(struct { variety = AV_plain, strength = AS_normal }),\n      Read_ifetch => AK_ifetch(),\n      Read_RISCV_acquire => AK_explicit(struct { variety = AV_plain, strength = AS_rel_or_acq }),\n      Read_RISCV_strong_acquire => AK_arch(struct { variety = AV_plain }),\n      Read_RISCV_reserved => AK_explicit(struct { variety = AV_exclusive, strength = AS_normal }),\n      Read_RISCV_reserved_acquire => AK_explicit(struct { variety = AV_exclusive, strength = AS_rel_or_acq }),\n      Read_RISCV_reserved_strong_acquire => AK_arch(struct { variety = AV_exclusive }),\n    },\n    va = None(),\n    pa = addr,\n    translation = (),\n    size = width,\n    tag = false,\n  };\n  match sail_mem_read(request) {\n    Ok((value, _)) => (value, meta),\n    Err() => exit(),\n  }\n}"
  },
  {
    "name": "lift_ustatus",
    "source": "{\n  let s = [s with UPIE = u[UPIE]];\n  let s = [s with UIE = u[UIE]];\n  s\n}"
  },
  {
    "name": "ext_write_CSR",
    "source": "{ ext_write_vcsr (vcsr[vxrm], value[0 .. 0]); Some(zero_extend(vcsr[vxsat])) }"
  },
  {
    "name": "ext_write_CSR",
    "source": "{ ext_write_vcsr (value[1 .. 0], vcsr[vxsat]); Some(zero_extend(vcsr[vxrm])) }"
  },
  {
    "name": "ext_write_CSR",
    "source": "{ ext_write_vcsr (value [2 .. 1], value [0 .. 0]); Some(zero_extend(vcsr.bits)) }"
  },
  {
    "name": "ext_write_CSR",
    "source": "{ mstatus = legalize_ustatus(mstatus, value); Some(mstatus.bits) }"
  },
  {
    "name": "ext_write_CSR",
    "source": "{ let sie = legalize_uie(lower_mie(mie, mideleg), sideleg, value);\n                                                 mie = lift_sie(mie, mideleg, sie);\n                                                 Some(mie.bits) }"
  },
  {
    "name": "ext_write_CSR",
    "source": "{ Some(set_utvec(value)) }"
  },
  {
    "name": "ext_write_CSR",
    "source": "{ uscratch = value; Some(uscratch) }"
  },
  {
    "name": "ext_write_CSR",
    "source": "{ Some(set_xret_target(User, value)) }"
  },
  {
    "name": "ext_write_CSR",
    "source": "{ ucause.bits = value; Some(ucause.bits) }"
  },
  {
    "name": "ext_write_CSR",
    "source": "{ utval = value; Some(utval) }"
  },
  {
    "name": "ext_write_CSR",
    "source": "{ let sip = legalize_uip(lower_mip(mip, mideleg), sideleg, value);\n                                                 mip = lift_sip(mip, mideleg, sip);\n                                                 Some(mip.bits) }"
  },
  {
    "name": "ext_write_CSR",
    "source": "{ ext_write_fcsr(fcsr[FRM], value[4..0]); Some(zero_extend(fcsr[FFLAGS])) }"
  },
  {
    "name": "ext_write_CSR",
    "source": "{ ext_write_fcsr(value[2..0], fcsr[FFLAGS]); Some(zero_extend(fcsr[FRM])) }"
  },
  {
    "name": "ext_write_CSR",
    "source": "{ ext_write_fcsr(value[7..5], value[4..0]); Some(zero_extend(fcsr.bits)) }"
  },
  {
    "name": "ext_write_CSR",
    "source": "None()"
  },
  {
    "name": "riscv_f16Mul",
    "source": "{\n  extern_f16Mul(rm, v1, v2);\n  (float_fflags[4 .. 0], float_result[15 .. 0])\n}"
  },
  {
    "name": "process_vlsegff",
    "source": "{\n  let EMUL_reg : int = if EMUL_pow <= 0 then 1 else 2 ^ (EMUL_pow);\n  let width_type : word_width = size_bytes(load_width_bytes);\n  let vm_val : vector('n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\n  let vd_seg : vector('n, dec, bits('f * 'b * 8)) = read_vreg_seg(num_elem, load_width_bytes * 8, EMUL_pow, nf, vd);\n  let tail_ag : agtype = get_vtype_vta();\n\n  let (result, mask) = init_masked_result(num_elem, nf * load_width_bytes * 8, EMUL_pow, vd_seg, vm_val);\n\n  var trimmed : bool = false;\n  foreach (i from 0 to (num_elem - 1)) {\n    if not(trimmed) then {\n      if vm_val[i] then { /* active segments */\n        foreach (j from 0 to (nf - 1)) {\n          let elem_offset = (i * nf + j) * load_width_bytes;\n          match ext_data_get_addr(rs1, to_bits(sizeof(xlen), elem_offset), Read(Data), load_width_bytes) {\n            Ext_DataAddr_Error(e)  => {\n              if i == 0 then { ext_handle_data_check_error(e); return RETIRE_FAIL }\n              else {\n                vl = to_bits(sizeof(xlen), i);\n                print_reg(\"CSR vl <- \" ^ BitStr(vl));\n                trimmed = true\n              }\n            },\n            Ext_DataAddr_OK(vaddr) => {\n              if check_misaligned(vaddr, width_type) then {\n                if i == 0 then { handle_mem_exception(vaddr, E_Load_Addr_Align()); return RETIRE_FAIL }\n                else {\n                  vl = to_bits(sizeof(xlen), i);\n                  print_reg(\"CSR vl <- \" ^ BitStr(vl));\n                  trimmed = true\n                }\n              } else match translateAddr(vaddr, Read(Data)) {\n                TR_Failure(e, _)     => {\n                  if i == 0 then { handle_mem_exception(vaddr, e); return RETIRE_FAIL }\n                  else {\n                    vl = to_bits(sizeof(xlen), i);\n                    print_reg(\"CSR vl <- \" ^ BitStr(vl));\n                    trimmed = true\n                  }\n                },\n                TR_Address(paddr, _) => {\n                  match mem_read(Read(Data), paddr, load_width_bytes, false, false, false) {\n                    MemValue(elem)   => write_single_element(load_width_bytes * 8, i, vd + to_bits(5, j * EMUL_reg), elem),\n                    MemException(e)  => {\n                      if i == 0 then { handle_mem_exception(vaddr, e); return RETIRE_FAIL }\n                      else {\n                        vl = to_bits(sizeof(xlen), i);\n                        print_reg(\"CSR vl <- \" ^ BitStr(vl));\n                        trimmed = true\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      } else { /* prestart, masked or tail segments */\n        foreach (j from 0 to (nf - 1)) {\n          let skipped_elem = (result[i] >> (j * load_width_bytes * 8))[(load_width_bytes * 8 - 1) .. 0];\n          write_single_element(load_width_bytes * 8, i, vd + to_bits(5, j * EMUL_reg), skipped_elem)\n        }\n      }\n    } else {\n      /* if vl is trimmed, elements past the new vl are treated as tail elements */\n      if tail_ag == AGNOSTIC then {\n        foreach (j from 0 to (nf - 1)) {\n          let skipped_elem = (vd_seg[i] >> (j * load_width_bytes * 8))[(load_width_bytes * 8 - 1) .. 0];\n          write_single_element(load_width_bytes * 8, i, vd + to_bits(5, j * EMUL_reg), skipped_elem)\n        }\n        /* TODO: configuration support for agnostic behavior */\n      }\n    }\n  };\n\n  vstart = zeros();\n  RETIRE_SUCCESS\n}"
  },
  {
    "name": "aes_rv64_shiftrows_fwd",
    "source": "{\n  getbyte(rs1, 3) @\n  getbyte(rs2, 6) @\n  getbyte(rs2, 1) @\n  getbyte(rs1, 4) @\n  getbyte(rs2, 7) @\n  getbyte(rs2, 2) @\n  getbyte(rs1, 5) @\n  getbyte(rs1, 0)\n}"
  },
  {
    "name": "mem_read",
    "source": "mem_read_priv(typ, effectivePrivilege(typ, mstatus, cur_privilege), paddr, width, aq, rel, res)"
  },
  {
    "name": "fle_D",
    "source": "{\n  let (s1, e1, m1) = fsplit_D (v1);\n  let (s2, e2, m2) = fsplit_D (v2);\n\n  let v1Is0    = f_is_neg_zero_D(v1) | f_is_pos_zero_D(v1);\n  let v2Is0    = f_is_neg_zero_D(v2) | f_is_pos_zero_D(v2);\n\n  let result : bool =\n    if (s1 == 0b0) & (s2 == 0b0) then\n      if   (e1 == e2)\n      then unsigned (m1) <=  unsigned (m2)\n      else unsigned (e1)  <  unsigned (e2)\n    else if (s1 == 0b0) & (s2 == 0b1) then\n      (v1Is0 & v2Is0)                         /* Equal in this case (+0=-0) */\n    else if (s1 == 0b1) & (s2 == 0b0) then\n      true\n    else\n      if   (e1 == e2)\n      then unsigned (m1) >=  unsigned (m2)\n      else unsigned (e1)  >  unsigned (e2);\n\n  let fflags = if is_quiet then\n                 if   (f_is_SNaN_D(v1) | f_is_SNaN_D(v2))\n                 then nvFlag()\n                 else zeros()\n               else\n                 if   (f_is_NaN_D(v1) | f_is_NaN_D(v2))\n                 then nvFlag()\n                 else zeros();\n\n  (result, fflags)\n}"
  },
  {
    "name": "fp_gt",
    "source": "{\n  let (fflags, temp_val) : (bits_fflags, bool) = match 'm {\n    16  => riscv_f16Le(op1, op2),\n    32  => riscv_f32Le(op1, op2),\n    64  => riscv_f64Le(op1, op2)\n  };\n  let result_val = (if fflags == 0b10000 then false else not(temp_val));\n  accrue_fflags(fflags);\n  result_val\n}"
  },
  {
    "name": "riscv_f64Rsqrte7",
    "source": "{\n  match fp_class(v)[15 .. 0] {\n    0x0001 => (nvFlag(), 0x7ff8000000000000),\n    0x0002 => (nvFlag(), 0x7ff8000000000000),\n    0x0004 => (nvFlag(), 0x7ff8000000000000),\n    0x0100 => (nvFlag(), 0x7ff8000000000000),\n    0x0200 => (zeros(5), 0x7ff8000000000000),\n    0x0008 => (dzFlag(), 0xfff0000000000000),\n    0x0010 => (dzFlag(), 0x7ff0000000000000),\n    0x0080 => (zeros(5), zeros(64)),\n    0x0020 => (zeros(5), rsqrt7(v, true)[63 .. 0]),\n    _      => (zeros(5), rsqrt7(v, false)[63 .. 0])\n  }\n}"
  },
  {
    "name": "riscv_ui64ToF64",
    "source": "{\n  extern_ui64ToF64(rm, v);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "fp_div",
    "source": "{\n  let (fflags, result_val) : (bits_fflags, bits('m)) = match 'm {\n    16  => riscv_f16Div(rm_3b, op1, op2),\n    32  => riscv_f32Div(rm_3b, op1, op2),\n    64  => riscv_f64Div(rm_3b, op1, op2)\n  };\n  accrue_fflags(fflags);\n  result_val\n}"
  },
  {
    "name": "get_fixed_rounding_incr",
    "source": "{\n  if shift_amount == 0 then 0b0\n  else {\n    let rounding_mode = vxrm[1 .. 0];\n    match rounding_mode {\n      0b00 => slice(vec_elem, shift_amount - 1, 1),\n      0b01 => bool_to_bits(\n        (slice(vec_elem, shift_amount - 1, 1) == 0b1) & (slice(vec_elem, 0, shift_amount - 1) != zeros() | slice(vec_elem, shift_amount, 1) == 0b1)),\n      0b10 => 0b0,\n      0b11 => bool_to_bits(\n        not(slice(vec_elem, shift_amount, 1) == 0b1) & (slice(vec_elem, 0, shift_amount) != zeros()))\n    }\n  }\n}"
  },
  {
    "name": "riscv_f32Lt_quiet",
    "source": "{\n  extern_f32Lt_quiet(v1, v2);\n  (float_fflags[4 .. 0], bit_to_bool(float_result[0]))\n}"
  },
  {
    "name": "process_vsxseg",
    "source": "{\n  let EMUL_data_reg : int = if EMUL_data_pow <= 0 then 1 else 2 ^ (EMUL_data_pow);\n  let width_type : word_width = size_bytes(EEW_data_bytes);\n  let vm_val  : vector('n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\n  let vs3_seg : vector('n, dec, bits('f * 'db * 8)) = read_vreg_seg(num_elem, EEW_data_bytes * 8, EMUL_data_pow, nf, vs3);\n  let vs2_val : vector('n, dec, bits('ib * 8)) = read_vreg(num_elem, EEW_index_bytes * 8, EMUL_index_pow, vs2);\n  let mask    : vector('n, dec, bool) = init_masked_source(num_elem, EMUL_data_pow, vm_val);\n\n  /* currently mop = 1 (unordered) or 3 (ordered) do the same operations */\n  foreach (i from 0 to (num_elem - 1)) {\n    if mask[i] then { /* active segments */\n      vstart = to_bits(16, i);\n      foreach (j from 0 to (nf - 1)) {\n        let elem_offset : int = signed(vs2_val[i]) + j * EEW_data_bytes;\n        match ext_data_get_addr(rs1, to_bits(sizeof(xlen), elem_offset), Write(Data), EEW_data_bytes) {\n          Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); return RETIRE_FAIL },\n          Ext_DataAddr_OK(vaddr) =>\n            if check_misaligned(vaddr, width_type)\n            then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); return RETIRE_FAIL }\n            else match translateAddr(vaddr, Write(Data)) {\n              TR_Failure(e, _)     => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n              TR_Address(paddr, _) => {\n                let eares : MemoryOpResult(unit) = mem_write_ea(paddr, EEW_data_bytes, false, false, false);\n                match (eares) {\n                  MemException(e) => { handle_mem_exception(vaddr, e); return RETIRE_FAIL },\n                  MemValue(_) => {\n                    let elem_val : bits('db * 8) = read_single_element(EEW_data_bytes * 8, i, vs3 + to_bits(5, j * EMUL_data_reg));\n                    let res : MemoryOpResult(bool) = mem_write_value(paddr, EEW_data_bytes, elem_val, false, false, false);\n                    match (res) {\n                      MemValue(true)  => (),\n                      MemValue(false) => internal_error(__FILE__, __LINE__, \"store got false from mem_write_value\"),\n                      MemException(e) => { handle_mem_exception(vaddr, e); return RETIRE_FAIL }\n                    }\n                  }\n                }\n              }\n            }\n        }\n      }\n    }\n  };\n\n  vstart = zeros();\n  RETIRE_SUCCESS\n}"
  },
  {
    "name": "riscv_f64Eq",
    "source": "{\n  extern_f64Eq(v1, v2);\n  (float_fflags[4 .. 0], bit_to_bool(float_result[0]))\n}"
  },
  {
    "name": "valid_rd_mask",
    "source": "{\n  vm != 0b0 | rd != 0b00000\n}"
  },
  {
    "name": "lift_uie",
    "source": "{\n  let s : Sinterrupts = o;\n  let s = if d[UEI] == 0b1 then [s with UEI = u[UEI]] else s;\n  let s = if d[UTI] == 0b1 then [s with UTI = u[UTI]] else s;\n  let s = if d[USI] == 0b1 then [s with USI = u[USI]] else s;\n  s\n}"
  },
  {
    "name": "riscv_f16ToI16",
    "source": "{\n  let (_, sig32) = riscv_f16ToI32(rm, v);\n  if signed(sig32) > signed(0b0 @ ones(15)) then (nvFlag(), 0b0 @ ones(15))\n  else if signed(sig32) < signed(0b1 @ zeros(15)) then (nvFlag(), 0b1 @ zeros(15))\n  else (zeros(5), sig32[15 .. 0]);\n}"
  },
  {
    "name": "riscv_f16ToUi64",
    "source": "{\n  extern_f16ToUi64(rm, v);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "riscv_f64ToUi32",
    "source": "{\n  extern_f64ToUi32(rm, v);\n  (float_fflags[4 .. 0], float_result[31 .. 0])\n}"
  },
  {
    "name": "mmio_read",
    "source": "if   within_clint(paddr, width)\n  then clint_load(t, paddr, width)\n  else if within_htif_readable(paddr, width) & (1 <= 'n)\n  then htif_load(t, paddr, width)\n  else match t {\n    Execute()  => MemException(E_Fetch_Access_Fault()),\n    Read(Data) => MemException(E_Load_Access_Fault()),\n    _          => MemException(E_SAMO_Access_Fault())\n  }"
  },
  {
    "name": "fp_add",
    "source": "{\n  let (fflags, result_val) : (bits_fflags, bits('m)) = match 'm {\n    16  => riscv_f16Add(rm_3b, op1, op2),\n    32  => riscv_f32Add(rm_3b, op1, op2),\n    64  => riscv_f64Add(rm_3b, op1, op2)\n  };\n  accrue_fflags(fflags);\n  result_val\n}"
  },
  {
    "name": "riscv_f64roundToInt",
    "source": "{\n  extern_f64roundToInt(rm, v, exact);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "wF_bits",
    "source": "{\n  wF(unsigned(i)) = data\n}"
  },
  {
    "name": "init_masked_result_carry",
    "source": "{\n  let start_element = get_start_element();\n  let end_element   = get_end_element();\n  var mask : vector('n, dec, bool) = undefined;\n  var result : vector('n, dec, bool) = undefined;\n\n  /* Determine the actual number of elements when lmul < 1 */\n  let real_num_elem = if LMUL_pow >= 0 then num_elem else num_elem / (2 ^ (0 - LMUL_pow));\n  assert(num_elem >= real_num_elem);\n\n  foreach (i from 0 to (num_elem - 1)) {\n    if i < start_element then {\n      /* Prestart elements defined by vstart */\n      result[i] = vd_val[i];\n      mask[i] = false\n    } else if i > end_element then {\n      /* Tail elements defined by vl */\n      /* Mask tail is always agnostic */\n      result[i] = vd_val[i]; /* TODO: configuration support */\n      mask[i] = false\n    } else if i >= real_num_elem then {\n      /* Tail elements defined by lmul < 1 */\n      /* Mask tail is always agnostic */\n      result[i] = vd_val[i]; /* TODO: configuration support */\n      mask[i] = false\n    } else {\n      /* Active body elements */\n      mask[i] = true\n    }\n  };\n\n  (result, mask)\n}"
  },
  {
    "name": "lift_sstatus",
    "source": "{\n  let m = [m with MXR = s[MXR]];\n  let m = [m with SUM = s[SUM]];\n\n  let m = [m with XS = s[XS]];\n  // See comment for mstatus.FS.\n  let m = [m with FS = s[FS]];\n  let m = [m with VS = s[VS]];\n  let dirty = extStatus_of_bits(m[FS]) == Dirty | extStatus_of_bits(m[XS]) == Dirty |\n              extStatus_of_bits(m[VS]) == Dirty;\n  let m = [m with SD = bool_to_bits(dirty)];\n\n  let m = [m with SPP = s[SPP]];\n  let m = [m with SPIE = s[SPIE]];\n  let m = [m with UPIE = s[UPIE]];\n  let m = [m with SIE = s[SIE]];\n  let m = [m with UIE = s[UIE]];\n  m\n}"
  },
  {
    "name": "wV_bits",
    "source": "{\n  wV(unsigned(i)) = data\n}"
  },
  {
    "name": "riscv_f64Mul",
    "source": "{\n  extern_f64Mul(rm, v1, v2);\n  (float_fflags[4 .. 0], float_result)\n}"
  },
  {
    "name": "riscv_f16ToI64",
    "source": "{\n  extern_f16ToI64(rm, v);\n  (float_fflags[4 .. 0], float_result)\n}"
  }
  ]
}
